<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>c++</title>
    <link href="/2025/02/19/c/"/>
    <url>/2025/02/19/c/</url>
    
    <content type="html"><![CDATA[<h2 id="何时需要创建类"><a href="#何时需要创建类" class="headerlink" title="何时需要创建类"></a>何时需要创建类</h2><p>在 C++ 编程中，创建类通常是在你需要组织、封装和管理数据及其相关行为时的一种设计手段。下面是一些常见的情境和原因，说明何时应该创建类：</p><hr><h3 id="1-当需要封装数据和行为时"><a href="#1-当需要封装数据和行为时" class="headerlink" title="1. 当需要封装数据和行为时"></a>1. 当需要封装数据和行为时</h3><ul><li><p>封装（Encapsulation）</p><p>：当你有一组数据和相关的操作，并且希望将它们组合在一起以隐藏内部实现细节时，类是很好的选择。</p><ul><li>例如，一个表示“学生”的类，可以封装姓名、学号和成绩，并提供操作这些数据的方法（如计算平均分、打印信息等）。</li></ul></li></ul><hr><h3 id="2-当有多个对象需要相同的结构时"><a href="#2-当有多个对象需要相同的结构时" class="headerlink" title="2. 当有多个对象需要相同的结构时"></a>2. 当有多个对象需要相同的结构时</h3><ul><li><p>复用和扩展性</p><p>：当你的程序中存在多个实体具有相同的属性和行为时，使用类可以提高代码复用性，并使代码更易于维护。</p><ul><li>例如，一个游戏程序中可能需要创建多个“敌人”或“角色”，它们都有共同的属性（血量、位置、速度）和行为（移动、攻击、防御）。</li></ul></li></ul><hr><h3 id="3-当需要实现面向对象设计原则时"><a href="#3-当需要实现面向对象设计原则时" class="headerlink" title="3. 当需要实现面向对象设计原则时"></a>3. 当需要实现面向对象设计原则时</h3><ul><li><p>继承和多态</p><p>：当你希望利用面向对象的设计原则（如继承、封装和多态）来组织代码时，创建类能够更好地支持这些特性。</p><ul><li>例如，定义一个基类 <code>Animal</code>，然后创建 <code>Dog</code>、<code>Cat</code> 等子类，可以在基类中定义共通接口，再在子类中实现各自特有的行为。</li></ul></li></ul><hr><h3 id="4-当需要隐藏实现细节时"><a href="#4-当需要隐藏实现细节时" class="headerlink" title="4. 当需要隐藏实现细节时"></a>4. 当需要隐藏实现细节时</h3><ul><li><p>抽象和信息隐藏</p><p>：通过将实现细节封装在类的私有成员中，可以让使用者只关心类的接口，而不必了解其内部工作原理。</p><ul><li>这在设计库和API时尤其重要，能够提高代码的健壮性和安全性。</li></ul></li></ul><hr><h3 id="5-当数据状态需要被管理和维护时"><a href="#5-当数据状态需要被管理和维护时" class="headerlink" title="5. 当数据状态需要被管理和维护时"></a>5. 当数据状态需要被管理和维护时</h3><ul><li><p>状态管理</p><p>：如果你的程序需要管理复杂的状态，并且这些状态需要随着程序的运行而变化，使用类能够将状态数据和状态转移逻辑组织在一起。</p><ul><li>例如，管理一个“连接”对象，其中封装了连接状态、超时处理和资源释放等逻辑。</li></ul></li></ul><hr><h3 id="6-当需要利用构造函数和析构函数管理资源时"><a href="#6-当需要利用构造函数和析构函数管理资源时" class="headerlink" title="6. 当需要利用构造函数和析构函数管理资源时"></a>6. 当需要利用构造函数和析构函数管理资源时</h3><ul><li><p>资源管理</p><p>：在需要动态分配内存、文件句柄、网络连接等资源时，类可以利用构造函数分配资源，利用析构函数释放资源，从而遵循 RAII（资源获取即初始化）的原则。</p><ul><li>这能显著降低内存泄漏和资源泄漏的风险。</li></ul></li></ul><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>创建类的时机主要体现在：</strong></p><ul><li>当你需要对数据和操作进行封装时；</li><li>当多个对象共享相似属性和行为时；</li><li>当你需要利用继承、多态等面向对象特性时；</li><li>当你希望隐藏内部实现、提高代码可维护性时；</li><li>当你需要管理复杂的状态和资源时。</li></ul><p>总之，类是实现模块化、重用和可扩展代码的强大工具。合理地设计和使用类，能够让你的程序更易于理解、维护和扩展。</p><h2 id="类中的公有成员和私有成员"><a href="#类中的公有成员和私有成员" class="headerlink" title="类中的公有成员和私有成员"></a>类中的公有成员和私有成员</h2><p>类中私有成员不能被对象直接访问，需要引入其他变量，将私有变量提取出来</p><h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><p>在基类函数前加上virtual，当派生类以不同的方法实现该函数时，主函数中的调用会根据对象的实际类型而不是根据声明时对象的类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Base::func()&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base <br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Derived::func()&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//对象是Derived类的</span><br>    Derived d;<br>    <span class="hljs-comment">//基类指针指向Derived类</span><br>    Base* p = &amp;d;<br>    p-&gt;<span class="hljs-built_in">func</span>();  <span class="hljs-comment">// 调用的是 Base::func()，而非 Derived::func()</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ol><li><p><strong>既然如此，为什么不直接声明派生类指针</strong></p><p>当问题规模达到一定程度之后，只需一个基类指针就可对所有派生类实现调用，程序不会充满繁杂的指针，便于阅读以及维护</p></li><li><p><strong>为什么不在类中用不同的名字命名</strong></p><p>派生类过多时，会导致命名困难。若采用有规律且独一无二的命名方式，会使得基类指针无法调用派生类中的函数（名称不同），我们这里就回到了问题1，就需要创建很多不同的指针，使程序复杂化。</p></li></ol><h3 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h3><p>纯虚函数就是基于<strong>问题</strong>所创造的，为了保证一个指针就可调用所有派生类的函数，即使基类中没有必要定义某个函数，也要声明此函数。纯虚函数通过等于零来实现。</p><h2 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h2><p><strong>数据封装</strong>是一种把数据和操作数据的函数捆绑在一起的机制，<strong>数据抽象</strong>是一种仅向用户暴露接口而把具体的实现细节隐藏起来的机制。</p><p>如果类中至少有一个函数被声明为<strong>纯虚函数</strong>，则这个类就是<strong>抽象类</strong>，抽象类不能被用于实例化对象，只能用于接口。纯虚函数是通过在声明中”&#x3D;0”来指定的。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Box</span>&#123;<br>   <span class="hljs-keyword">public</span>:<br>      <span class="hljs-comment">// 纯虚函数</span><br>      <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">double</span> <span class="hljs-title">getVolume</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>   <span class="hljs-keyword">private</span>:<br>      <span class="hljs-type">double</span> length;      <span class="hljs-comment">// 长度</span><br>      <span class="hljs-type">double</span> breadth;     <span class="hljs-comment">// 宽度</span><br>      <span class="hljs-type">double</span> height;      <span class="hljs-comment">// 高度&#125;;</span><br></code></pre></td></tr></table></figure><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>异常是程序在执行期间产生的问题。C++ 异常是指在程序运行时发生的特殊情况，比如尝试除以零的操作。</p><p>异常提供了一种转移程序控制权的方式。C++ 异常处理涉及到三个关键字：<strong>try、catch、throw</strong>。</p><ul><li><strong>throw:</strong> 当问题出现时，程序会抛出一个异常。这是通过使用 <strong>throw</strong> 关键字来完成的。</li><li><strong>catch:</strong> 在您想要处理问题的地方，通过异常处理程序捕获异常。<strong>catch</strong> 关键字用于捕获异常。</li><li><strong>try:</strong> <strong>try</strong> 块中的代码标识将被激活的特定异常。它后面通常跟着一个或多个 catch 块。</li></ul><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs zephir">#include &lt;iostream&gt;using <span class="hljs-keyword">namespace</span> <span class="hljs-title">std</span>;<span class="hljs-keyword">double</span> division(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)&#123;<br>   <span class="hljs-keyword">if</span>( b == <span class="hljs-number">0</span> )<br>   &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-string">&quot;Division by zero condition!&quot;</span>;<br>   &#125;<br>   <span class="hljs-keyword">return</span> (a/b);&#125;<span class="hljs-keyword">int</span> main ()&#123;<br>   <span class="hljs-keyword">int</span> x = <span class="hljs-number">50</span>;<br>   <span class="hljs-keyword">int</span> y = <span class="hljs-number">0</span>;<br>   <span class="hljs-keyword">double</span> z = <span class="hljs-number">0</span>;<br> <br>   <span class="hljs-keyword">try</span> &#123;<br>     z = division(x, y);<br>     cout &lt;&lt; z &lt;&lt; endl;<br>   &#125;<span class="hljs-keyword">catch</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* msg) &#123;<br>     cerr &lt;&lt; msg &lt;&lt; endl;<br>   &#125;<br><br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<br></code></pre></td></tr></table></figure><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cs-学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TCP-IP</title>
    <link href="/2025/02/19/TCP-IP/"/>
    <url>/2025/02/19/TCP-IP/</url>
    
    <content type="html"><![CDATA[<p>此文章转载自网络，原地址<a href="https://github.com/riba2534/TCP-IP-NetworkNote">https://github.com/riba2534/TCP-IP-NetworkNote</a></p><h1 id="《TCP-IP网络编程》学习笔记"><a href="#《TCP-IP网络编程》学习笔记" class="headerlink" title="《TCP&#x2F;IP网络编程》学习笔记"></a>《TCP&#x2F;IP网络编程》学习笔记</h1><p>:flags: 此仓库是我的《TCP&#x2F;IP网络编程》学习笔记及具体代码实现，代码部分请参考本仓库对应章节文件夹下的代码。如果本笔记的内容对你有用，请点击一个 <code>star</code> ，转载请注明出处，谢谢。</p><p>我的环境是：Ubuntu18.04 LTS</p><p>编译器版本：<code>g++ (Ubuntu 7.3.0-27ubuntu1~18.04) 7.3.0</code> 和 <code>gcc (Ubuntu 7.3.0-27ubuntu1~18.04) 7.3.0</code></p><p>所以本笔记中只学习有关于 Linux 的部分。</p><p>本项目在 GitHub 地址为：<a href="https://github.com/riba2534/TCP-IP-NetworkNote">TCP-IP-NetworkNote</a></p><p>如果在阅读本笔记的过程中发现错别字，及 bug ，请向本项目提交 <code>PR</code>.</p><p>笔记的 PDF 版本可以在本项目 <a href="https://github.com/riba2534/TCP-IP-NetworkNote/releases">releases</a> 中找到及下载。</p><h2 id="第-1-章：理解网络编程和套接字"><a href="#第-1-章：理解网络编程和套接字" class="headerlink" title="第 1 章：理解网络编程和套接字"></a>第 1 章：理解网络编程和套接字</h2><p>本章代码，在<a href="https://github.com/riba2534/TCP-IP-NetworkNote">TCP-IP-NetworkNote</a>中可以找到，直接点连接可能进不去。</p><h3 id="1-1-理解网络编程和套接字"><a href="#1-1-理解网络编程和套接字" class="headerlink" title="1.1 理解网络编程和套接字"></a>1.1 理解网络编程和套接字</h3><h4 id="1-1-1构建打电话套接字"><a href="#1-1-1构建打电话套接字" class="headerlink" title="1.1.1构建打电话套接字"></a>1.1.1构建打电话套接字</h4><p>以电话机打电话的方式来理解套接字。</p><p><strong>调用 socket 函数（安装电话机）时进行的对话</strong>：</p><blockquote><p>问：接电话需要准备什么？</p><p>答：当然是电话机。</p></blockquote><p>有了电话机才能安装电话，于是就要准备一个电话机，下面函数相当于电话机的套接字。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">socket</span><span class="hljs-params">(<span class="hljs-type">int</span> domain, <span class="hljs-type">int</span> type, <span class="hljs-type">int</span> protocol)</span>;<br><span class="hljs-comment">//成功时返回文件描述符，失败时返回-1</span><br></code></pre></td></tr></table></figure><p><strong>调用 bind 函数（分配电话号码）时进行的对话</strong>：</p><blockquote><p>问：请问我的电话号码是多少</p><p>答：我的电话号码是123-1234</p></blockquote><p>套接字同样如此。就想给电话机分配电话号码一样，利用以下函数给创建好的套接字分配地址信息（IP地址和端口号）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">bind</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-keyword">struct</span> sockaddr *myaddr, <span class="hljs-type">socklen_t</span> addrlen)</span>;<br><span class="hljs-comment">//成功时返回0，失败时返回-1</span><br></code></pre></td></tr></table></figure><p>调用 bind 函数给套接字分配地址之后，就基本完成了所有的准备工作。接下来是需要连接电话线并等待来电。</p><p><strong>调用 listen 函数（连接电话线）时进行的对话</strong>：</p><blockquote><p>问：已架设完电话机后是否只需链接电话线？</p><p>答：对，只需要连接就能接听电话。</p></blockquote><p>一连接电话线，电话机就可以转换为可接听状态，这时其他人可以拨打电话请求连接到该机。同样，需要把套接字转化成可接受连接状态。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">listen</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-type">int</span> backlog)</span>;<br><span class="hljs-comment">//成功时返回0，失败时返回-1</span><br></code></pre></td></tr></table></figure><p>连接好电话线以后，如果有人拨打电话就响铃，拿起话筒才能接听电话。</p><p><strong>调用 accept 函数（拿起话筒）时进行的对话</strong>：</p><blockquote><p>问：电话铃响了，我该怎么办？</p><p>答：接听啊。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd,<span class="hljs-keyword">struct</span> sockaddr *addr,<span class="hljs-type">socklen_t</span> *addrlen)</span>;<br><span class="hljs-comment">//成功时返回文件描述符，失败时返回-1</span><br></code></pre></td></tr></table></figure><p>网络编程中和接受连接请求的套接字创建过程可整理如下：</p><ol><li>第一步：调用 socket 函数创建套接字。</li><li>第二步：调用 bind 函数分配IP地址和端口号。</li><li>第三步：调用 listen 函数转换为可接受请求状态。</li><li>第四步：调用 accept 函数受理套接字请求。</li></ol><h4 id="1-1-2-编写Hello-World套接字程序"><a href="#1-1-2-编写Hello-World套接字程序" class="headerlink" title="1.1.2  编写Hello World套接字程序"></a>1.1.2  编写<code>Hello World</code>套接字程序</h4><p><strong>服务端</strong>：</p><p>服务器端（server）是能够受理连接请求的程序。下面构建服务端以验证之前提到的函数调用过程，该服务器端收到连接请求后向请求者返回<code>Hello World!</code>答复。除各种函数的调用顺序外，我们还未涉及任何实际编程。因此，阅读代码时请重点关注套接字相关的函数调用过程，不必理解全过程。</p><p>服务器端代码请参见：<a href="ch01/hello_server.c">hello_server.c</a></p><p><strong>客户端</strong>：</p><p>客户端程序只有<code>调用 socket 函数创建套接字</code> 和 <code>调用 connect 函数向服务端发送连接请求</code>这两个步骤，下面给出客户端，需要查看以下两方面的内容：</p><ol><li>调用 socket 函数 和 connect 函数</li><li>与服务端共同运行以收发字符串数据</li></ol><p>客户端代码请参见：<a href="ch01/hello_client.c">hello_client.c</a></p><p><strong>编译</strong>：</p><p>分别对客户端和服务端程序进行编译：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc hello_server.c -o hserver<br>gcc hello_client.c -o hclient<br></code></pre></td></tr></table></figure><p><strong>运行</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">./hserver 9190<br>./hclient 127.0.0.1 9190<br></code></pre></td></tr></table></figure><p>运行的时候，首先再 9190 端口启动服务，然后 heserver 就会一直等待客户端进行响应，当客户端监听位于本地的 IP 为 127.0.0.1 的地址的9190端口时，客户端就会收到服务端的回应，输出<code>Hello World!</code></p><h3 id="1-2-基于-Linux-的文件操作"><a href="#1-2-基于-Linux-的文件操作" class="headerlink" title="1.2 基于 Linux 的文件操作"></a>1.2 基于 Linux 的文件操作</h3><p>讨论套接字的过程中突然谈及文件也许有些奇怪。但是对于 Linux 而言，socket 操作与文件操作没有区别，因而有必要详细了解文件。在 Linux 世界里，socket 也被认为是文件的一种，因此在网络数据传输过程中自然可以使用 I&#x2F;O 的相关函数。Windows 与 Linux 不同，是要区分 socket 和文件的。因此在 Windows 中需要调用特殊的数据传输相关函数。</p><h4 id="1-2-1-底层访问和文件描述符"><a href="#1-2-1-底层访问和文件描述符" class="headerlink" title="1.2.1 底层访问和文件描述符"></a>1.2.1 底层访问和文件描述符</h4><p>分配给标准输入输出及标准错误的文件描述符。</p><table><thead><tr><th align="center">文件描述符</th><th align="center">对象</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">标准输入：Standard Input</td></tr><tr><td align="center">1</td><td align="center">标准输出：Standard Output</td></tr><tr><td align="center">2</td><td align="center">标准错误：Standard Error</td></tr></tbody></table><p>文件和套接字一般经过创建过程才会被分配文件描述符。</p><p>文件描述符也被称为「文件句柄」，但是「句柄」主要是 Windows 中的术语。因此，在本书中如果设计 Windows 平台将使用「句柄」，如果是 Linux 将使用「描述符」。</p><h4 id="1-2-2-打开文件"><a href="#1-2-2-打开文件" class="headerlink" title="1.2.2 打开文件:"></a>1.2.2 打开文件:</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">open</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path, <span class="hljs-type">int</span> flag)</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">成功时返回文件描述符，失败时返回-1</span><br><span class="hljs-comment">path : 文件名的字符串地址</span><br><span class="hljs-comment">flag : 文件打开模式信息</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>文件打开模式如下表：</p><table><thead><tr><th align="center">打开模式</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">O_CREAT</td><td align="center">必要时创建文件</td></tr><tr><td align="center">O_TRUNC</td><td align="center">删除全部现有数据</td></tr><tr><td align="center">O_APPEND</td><td align="center">维持现有数据，保存到其后面</td></tr><tr><td align="center">O_RDONLY</td><td align="center">只读打开</td></tr><tr><td align="center">O_WRONLY</td><td align="center">只写打开</td></tr><tr><td align="center">O_RDWR</td><td align="center">读写打开</td></tr></tbody></table><h4 id="1-2-3-关闭文件："><a href="#1-2-3-关闭文件：" class="headerlink" title="1.2.3 关闭文件："></a>1.2.3 关闭文件：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">close</span><span class="hljs-params">(<span class="hljs-type">int</span> fd)</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">成功时返回 0 ，失败时返回 -1</span><br><span class="hljs-comment">fd : 需要关闭的文件或套接字的文件描述符</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>若调用此函数同时传递文件描述符参数，则关闭（终止）响应文件。另外需要注意的是，此函数不仅可以关闭文件，还可以关闭套接字。再次证明了「Linux 操作系统不区分文件与套接字」的特点。</p><h4 id="1-2-4-将数据写入文件："><a href="#1-2-4-将数据写入文件：" class="headerlink" title="1.2.4 将数据写入文件："></a>1.2.4 将数据写入文件：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">write</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> nbytes)</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">成功时返回写入的字节数 ，失败时返回 -1</span><br><span class="hljs-comment">fd : 显示数据传输对象的文件描述符</span><br><span class="hljs-comment">buf : 保存要传输数据的缓冲值地址</span><br><span class="hljs-comment">nbytes : 要传输数据的字节数</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>在此函数的定义中，size_t 是通过 typedef 声明的 unsigned int 类型。对 ssize_t 来说，ssize_t 前面多加的 s 代表 signed ，即 ssize_t 是通过 typedef 声明的 signed int 类型。</p><p>创建新文件并保存数据：</p><p>代码见：<a href="ch01/low_open.c">low_open.c</a></p><p>编译运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc low_open.c -o lopen<br>./lopen<br></code></pre></td></tr></table></figure><p>然后会生成一个<code>data.txt</code>的文件，里面有<code>Let&#39;s go!</code></p><h4 id="1-2-5-读取文件中的数据："><a href="#1-2-5-读取文件中的数据：" class="headerlink" title="1.2.5 读取文件中的数据："></a>1.2.5 读取文件中的数据：</h4><p>与之前的<code>write()</code>函数相对应，<code>read()</code>用来输入（接收）数据。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">read</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> nbytes)</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">成功时返回接收的字节数（但遇到文件结尾则返回 0），失败时返回 -1</span><br><span class="hljs-comment">fd : 显示数据接收对象的文件描述符</span><br><span class="hljs-comment">buf : 要保存接收的数据的缓冲地址值。</span><br><span class="hljs-comment">nbytes : 要接收数据的最大字节数</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>下面示例通过 read() 函数读取 data.txt 中保存的数据。</p><p>代码见：<a href="ch01/low_read.c">low_read.c</a></p><p>编译运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc low_read.c -o lread<br>./lread<br></code></pre></td></tr></table></figure><p>在上一步的 data.txt 文件与没有删的情况下，会输出：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">file</span> descriptor: <span class="hljs-number">3</span><br><span class="hljs-keyword">file</span> <span class="hljs-keyword">data</span>: Let<span class="hljs-string">&#x27;s go!</span><br></code></pre></td></tr></table></figure><p>关于文件描述符的 I&#x2F;O 操作到此结束，要明白，这些内容同样适合于套接字。</p><h4 id="1-2-6-文件描述符与套接字"><a href="#1-2-6-文件描述符与套接字" class="headerlink" title="1.2.6 文件描述符与套接字"></a>1.2.6 文件描述符与套接字</h4><p>下面将同时创建文件和套接字，并用整数型态比较返回的文件描述符的值.</p><p>代码见：<a href="ch01/fd_seri.c">fd_seri.c</a></p><p><strong>编译运行</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc fd_seri.c -o fds<br>./fds<br></code></pre></td></tr></table></figure><p><strong>输出结果</strong>:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">file</span> descriptor <span class="hljs-number">1</span>: <span class="hljs-number">3</span><br><span class="hljs-attribute">file</span> descriptor <span class="hljs-number">2</span>: <span class="hljs-number">15</span><br><span class="hljs-attribute">file</span> descriptor <span class="hljs-number">3</span>: <span class="hljs-number">16</span><br></code></pre></td></tr></table></figure><h3 id="1-3-基于-Windows-平台的实现"><a href="#1-3-基于-Windows-平台的实现" class="headerlink" title="1.3 基于 Windows 平台的实现"></a>1.3 基于 Windows 平台的实现</h3><p>暂略</p><h3 id="1-4-基于-Windows-的套接字相关函数及示例"><a href="#1-4-基于-Windows-的套接字相关函数及示例" class="headerlink" title="1.4 基于 Windows 的套接字相关函数及示例"></a>1.4 基于 Windows 的套接字相关函数及示例</h3><p>暂略</p><h3 id="1-5-习题"><a href="#1-5-习题" class="headerlink" title="1.5 习题"></a>1.5 习题</h3><blockquote><p>:heavy_exclamation_mark:以下部分的答案，仅代表我个人观点，可能不是正确答案</p></blockquote><ol><li><p>套接字在网络编程中的作用是什么？为何称它为套接字？</p><blockquote><p>答：操作系统会提供「套接字」（socket）的部件，套接字是网络数据传输用的软件设备。因此，「网络编程」也叫「套接字编程」。「套接字」就是用来连接网络的工具。</p></blockquote></li><li><p>在服务器端创建套接字以后，会依次调用 listen 函数和 accept 函数。请比较二者作用。</p><blockquote><p>答：调用 listen 函数将套接字转换成可受连接状态（监听），调用 accept 函数受理连接请求。如果在没有连接请求的情况下调用该函数，则不会返回，直到有连接请求为止。</p></blockquote></li><li><p>Linux 中，对套接字数据进行 I&#x2F;O 时可以直接使用文件 I&#x2F;O 相关函数；而在 Windows 中则不可以。原因为何？</p><blockquote><p>答：Linux把套接字也看作是文件，所以可以用文件I&#x2F;O相关函数；而Windows要区分套接字和文件，所以设置了特殊的函数。</p></blockquote></li><li><p>创建套接字后一般会给他分配地址，为什么？为了完成地址分配需要调用哪个函数？</p><blockquote><p>答：套接字被创建之后，只有为其分配了IP地址和端口号后，客户端才能够通过IP地址及端口号与服务器端建立连接，需要调用 bind 函数来完成地址分配。</p></blockquote></li><li><p>Linux 中的文件描述符与 Windows 的句柄实际上非常类似。请以套接字为对象说明它们的含义。</p></li></ol><blockquote><p>答：暂略。</p></blockquote><ol start="6"><li><p>底层 I&#x2F;O 函数与 ANSI 标准定义的文件 I&#x2F;O 函数有何区别？</p><blockquote><p>答：文件 I&#x2F;O 又称为低级磁盘 I&#x2F;O，遵循 POSIX 相关标准。任何兼容 POSIX 标准的操作系统上都支持文件I&#x2F;O。标准 I&#x2F;O 被称为高级磁盘 I&#x2F;O，遵循 ANSI C 相关标准。只要开发环境中有标准 I&#x2F;O 库，标准 I&#x2F;O 就可以使用。（Linux 中使用的是 GLIBC，它是标准C库的超集。不仅包含 ANSI C 中定义的函数，还包括 POSIX 标准中定义的函数。因此，Linux 下既可以使用标准 I&#x2F;O，也可以使用文件 I&#x2F;O）。</p></blockquote></li><li><p>参考本书给出的示例<code>low_open.c</code>和<code>low_read.c</code>，分别利用底层文件 I&#x2F;O 和 ANSI 标准 I&#x2F;O 编写文件复制程序。可任意指定复制程序的使用方法。</p><blockquote><p>答：暂略。</p></blockquote></li></ol><h2 id="第-2-章-套接字类型与协议设置"><a href="#第-2-章-套接字类型与协议设置" class="headerlink" title="第 2 章 套接字类型与协议设置"></a>第 2 章 套接字类型与协议设置</h2><p>本章代码，在<a href="https://github.com/riba2534/TCP-IP-NetworkNote">TCP-IP-NetworkNote</a>中可以找到，直接点连接可能进不去。</p><p>本章仅需了解创建套接字时调用的 socket 函数。</p><h3 id="2-1-套接字协议及数据传输特性"><a href="#2-1-套接字协议及数据传输特性" class="headerlink" title="2.1 套接字协议及数据传输特性"></a>2.1 套接字协议及数据传输特性</h3><h4 id="2-1-1-创建套接字"><a href="#2-1-1-创建套接字" class="headerlink" title="2.1.1 创建套接字"></a>2.1.1 创建套接字</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">socket</span><span class="hljs-params">(<span class="hljs-type">int</span> domain, <span class="hljs-type">int</span> type, <span class="hljs-type">int</span> protocol)</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">成功时返回文件描述符，失败时返回-1</span><br><span class="hljs-comment">domain: 套接字中使用的协议族（Protocol Family）</span><br><span class="hljs-comment">type: 套接字数据传输的类型信息</span><br><span class="hljs-comment">protocol: 计算机间通信中使用的协议信息</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h4 id="2-1-2-协议族（Protocol-Family）"><a href="#2-1-2-协议族（Protocol-Family）" class="headerlink" title="2.1.2 协议族（Protocol Family）"></a>2.1.2 协议族（Protocol Family）</h4><p>通过 socket 函数的第一个参数传递套接字中使用的协议分类信息。此协议分类信息称为协议族，可分成如下几类：</p><blockquote><p>头文件 <code>sys/socket.h</code> 中声明的协议族</p></blockquote><table><thead><tr><th>名称</th><th>协议族</th></tr></thead><tbody><tr><td>PF_INET</td><td>IPV4 互联网协议族</td></tr><tr><td>PF_INET6</td><td>IPV6 互联网协议族</td></tr><tr><td>PF_LOCAL</td><td>本地通信 Unix 协议族</td></tr><tr><td>PF_PACKET</td><td>底层套接字的协议族</td></tr><tr><td>PF_IPX</td><td>IPX Novel 协议族</td></tr></tbody></table><p>本书着重讲 PF_INET 对应的 IPV4 互联网协议族。其他协议并不常用，或并未普及。<strong>另外，套接字中采用的最终的协议信息是通过 socket 函数的第三个参数传递的。在指定的协议族范围内通过第一个参数决定第三个参数。</strong></p><h4 id="2-1-3-套接字类型（Type）"><a href="#2-1-3-套接字类型（Type）" class="headerlink" title="2.1.3 套接字类型（Type）"></a>2.1.3 套接字类型（Type）</h4><p>套接字类型指的是套接字的数据传输方式，是通过 socket 函数的第二个参数进行传递，只有这样才能决定创建的套接字的数据传输方式。<strong>已经通过第一个参数传递了协议族信息，为什么还要决定数据传输方式？问题就在于，决定了协议族并不能同时决定数据传输方式。换言之， socket 函数的第一个参数 PF_INET 协议族中也存在多种数据传输方式。</strong></p><h4 id="2-1-4-套接字类型1：面向连接的套接字（SOCK-STREAM）"><a href="#2-1-4-套接字类型1：面向连接的套接字（SOCK-STREAM）" class="headerlink" title="2.1.4 套接字类型1：面向连接的套接字（SOCK_STREAM）"></a>2.1.4 套接字类型1：面向连接的套接字（SOCK_STREAM）</h4><p>如果 socket 函数的第二个参数传递<code>SOCK_STREAM</code>，将创建面向连接的套接字。</p><p>传输方式特征整理如下：</p><ul><li>传输过程中数据不会消失</li><li>按序传输数据</li><li>传输的数据不存在数据边界（Boundary）</li></ul><p>这种情形适用于之前说过的 write 和 read 函数</p><blockquote><p>传输数据的计算机通过调用3次 write 函数传递了 100 字节的数据，但是接受数据的计算机仅仅通过调用 1 次 read 函数调用就接受了全部 100 个字节。</p></blockquote><p>收发数据的套接字内部有缓冲（buffer），简言之就是字节数组。只要不超过数组容量，那么数据填满缓冲后过 1 次 read 函数的调用就可以读取全部，也有可能调用多次来完成读取。</p><p><strong>套接字缓冲已满是否意味着数据丢失？</strong></p><blockquote><p>答：缓冲并不总是满的。如果读取速度比数据传入过来的速度慢，则缓冲可能被填满，但是这时也不会丢失数据，因为传输套接字此时会停止数据传输，所以面向连接的套接字不会发生数据丢失。</p></blockquote><p>套接字联机必须一一对应。面向连接的套接字可总结为：</p><p><strong>可靠地、按序传递的、基于字节的面向连接的数据传输方式的套接字。</strong></p><h4 id="2-1-5-面向消息的套接字（SOCK-DGRAM）"><a href="#2-1-5-面向消息的套接字（SOCK-DGRAM）" class="headerlink" title="2.1.5 面向消息的套接字（SOCK_DGRAM）"></a>2.1.5 面向消息的套接字（SOCK_DGRAM）</h4><p>如果 socket 函数的第二个参数传递<code>SOCK_DGRAM</code>，则将创建面向消息的套接字。面向消息的套接字可以比喻成高速移动的摩托车队。特点如下：</p><ul><li>强调快速传输而非传输有序</li><li>传输的数据可能丢失也可能损毁</li><li>传输的数据有边界</li><li>限制每次传输数据的大小</li></ul><p>面向消息的套接字比面向连接的套接字更具哟传输速度，但可能丢失。特点可总结为：</p><p><strong>不可靠的、不按序传递的、以数据的高速传输为目的套接字。</strong></p><h4 id="2-1-6-协议的最终选择"><a href="#2-1-6-协议的最终选择" class="headerlink" title="2.1.6 协议的最终选择"></a>2.1.6 协议的最终选择</h4><p>socket 函数的第三个参数决定最终采用的协议。前面已经通过前两个参数传递了协议族信息和套接字数据传输方式，这些信息还不够吗？为什么要传输第三个参数呢？</p><blockquote><p>可以应对同一协议族中存在的多个数据传输方式相同的协议，所以数据传输方式相同，但是协议不同，需要用第三个参数指定具体的协议信息。</p></blockquote><p>本书用的是 Ipv4 的协议族，和面向连接的数据传输，满足这两个条件的协议只有 IPPROTO_TCP ，因此可以如下调用 socket 函数创建套接字，这种套接字称为 TCP 套接字。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> tcp_socket = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);<br></code></pre></td></tr></table></figure><p>SOCK_DGRAM 指的是面向消息的数据传输方式，满足上述条件的协议只有 TPPROTO_UDP 。这种套接字称为 UDP 套接字：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> udp_socket = socket(PF_INET, SOCK_DGRAM, IPPROTO_UDP);<br></code></pre></td></tr></table></figure><h4 id="2-1-7-面向连接的套接字：TCP-套接字示例"><a href="#2-1-7-面向连接的套接字：TCP-套接字示例" class="headerlink" title="2.1.7 面向连接的套接字：TCP 套接字示例"></a>2.1.7 面向连接的套接字：TCP 套接字示例</h4><p>需要对第一章的代码做出修改，修改好的代码如下：</p><ul><li><a href="https://github.com/riba2534/TCP-IP-NetworkNote/blob/master/ch02/tcp_client.c">tcp_client.c</a></li><li><a href="https://github.com/riba2534/TCP-IP-NetworkNote/blob/master/ch02/tcp_server.c">tcp_server.c</a></li></ul><p>编译：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc tcp_client.c -o hclient<br>gcc tcp_server.c -o hserver<br></code></pre></td></tr></table></figure><p>运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">./hserver 9190<br>./hclient 127.0.0.1 9190<br></code></pre></td></tr></table></figure><p>结果：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">Message <span class="hljs-keyword">from</span> <span class="hljs-keyword">server</span> : Hello World! <br><span class="hljs-keyword">Function</span> <span class="hljs-keyword">read</span> <span class="hljs-keyword">call</span> count: <span class="hljs-number">13</span><br></code></pre></td></tr></table></figure><p>从运行结果可以看出服务端发送了13字节的数据，客户端调用13次 read 函数进行读取。</p><h3 id="2-2-Windows-平台下的实现及验证"><a href="#2-2-Windows-平台下的实现及验证" class="headerlink" title="2.2 Windows 平台下的实现及验证"></a>2.2 Windows 平台下的实现及验证</h3><p>暂略</p><h3 id="2-3-习题"><a href="#2-3-习题" class="headerlink" title="2.3 习题"></a>2.3 习题</h3><ol><li><p>什么是协议？在收发数据中定义协议有何意义？</p><blockquote><p>答：协议是对话中使用的通信规则，简言之，协议就是为了完成数据交换而定好的约定。在收发数据中定义协议，能够让计算机之间进行对话，以此来实现信息交换和资源共享。</p></blockquote></li><li><p>面向连接的套接字 TCP 套接字传输特性有 3 点，请分别说明。</p><blockquote><p>答：①传输过程中数据不会消失②按序传输数据③传输的数据不存在数据边界（Boundary）</p></blockquote></li><li><p>下面那些是面向消息的套接字的特性？</p><ul><li><strong>传输数据可能丢失</strong></li><li>没有数据边界（Boundary）</li><li><strong>以快速传递为目标</strong></li><li>不限制每次传输数据大小</li><li><strong>与面向连接的套接字不同，不存在连接概念</strong></li></ul></li><li><p>下列数据适合用哪类套接字进行传输？</p><ul><li>演唱会现场直播的多媒体数据（UDP）</li><li>某人压缩过的文本文件（TCP）</li><li>网上银行用户与银行之间的数据传递（TCP）</li></ul></li><li><p>何种类型的套接字不存在数据边界？这类套接字接收数据时应该注意什么？</p><blockquote><p>答：TCP 不存在数据边界。在接收数据时，需要保证在接收套接字的缓冲区填充满之时就从buffer里读取数据。也就是，在接收套接字内部，写入buffer的速度要小于读出buffer的速度。</p></blockquote></li></ol><h2 id="第-3-章-地址族与数据序列"><a href="#第-3-章-地址族与数据序列" class="headerlink" title="第 3 章 地址族与数据序列"></a>第 3 章 地址族与数据序列</h2><p>本章代码，在<a href="https://github.com/riba2534/TCP-IP-NetworkNote">TCP-IP-NetworkNote</a>中可以找到。</p><p>把套接字比喻成电话，那么目前只安装了电话机，本章讲解给电话机分配号码的方法，即给套接字分配 IP 地址和端口号。</p><h3 id="3-1-分配给套接字的-IP-地址与端口号"><a href="#3-1-分配给套接字的-IP-地址与端口号" class="headerlink" title="3.1 分配给套接字的 IP 地址与端口号"></a>3.1 分配给套接字的 IP 地址与端口号</h3><p>IP 是 Internet Protocol（网络协议）的简写，是为手法网络数据而分配给计算机的值。端口号并非赋予计算机的值，而是为了区分程序中创建的套接字而分配给套接字的端口号。</p><h4 id="3-1-1-网络地址（Internet-Address）"><a href="#3-1-1-网络地址（Internet-Address）" class="headerlink" title="3.1.1 网络地址（Internet Address）"></a>3.1.1 网络地址（Internet Address）</h4><p>为使计算机连接到网络并收发数据，必须为其分配 IP 地址。IP 地址分为两类。</p><ul><li>IPV4（Internet Protocol version 4）4 字节地址族</li><li>IPV6（Internet Protocol version 6）6 字节地址族</li></ul><p>两者之间的主要差别是 IP 地址所用的字节数，目前通用的是 IPV4 , IPV6 的普及还需要时间。</p><p>IPV4 标准的 4 字节 IP 地址分为网络地址和主机（指计算机）地址，且分为 A、B、C、D、E 等类型。</p><p><img src="/.io//blog/blog/picture/5c3ab0eb17bbe.png"></p><p>数据传输过程：</p><p><img src="/.io//blog/blog/picture/5c3ab19174fa4.png"></p><p>某主机向 203.211.172.103 和 203.211.217.202 传递数据，其中 203.211.172 和 203.211.217 为该网络的网络地址，所以「向相应网络传输数据」实际上是向构成网络的路由器或者交换机传输数据，然后又路由器或者交换机根据数据中的主机地址向目标主机传递数据。</p><h4 id="3-1-2-网络地址分类与主机地址边界"><a href="#3-1-2-网络地址分类与主机地址边界" class="headerlink" title="3.1.2 网络地址分类与主机地址边界"></a>3.1.2 网络地址分类与主机地址边界</h4><p>只需通过IP地址的第一个字节即可判断网络地址占用的总字节数，因为我们根据IP地址的边界区分网络地址，如下所示：</p><ul><li>A 类地址的首字节范围为：0~127</li><li>B 类地址的首字节范围为：128~191</li><li>C 类地址的首字节范围为：192~223</li></ul><p>还有如下这种表示方式：</p><ul><li>A 类地址的首位以 0 开始</li><li>B 类地址的前2位以 10 开始</li><li>C 类地址的前3位以 110 开始</li></ul><p>因此套接字手法数据时，数据传到网络后即可轻松找到主机。</p><h4 id="3-1-3-用于区分套接字的端口号"><a href="#3-1-3-用于区分套接字的端口号" class="headerlink" title="3.1.3 用于区分套接字的端口号"></a>3.1.3 用于区分套接字的端口号</h4><p>IP地址用于区分计算机，只要有IP地址就能向目标主机传输数据，但是只有这些还不够，我们需要把信息传输给具体的应用程序。</p><p>所以计算机一般有 NIC（网络接口卡）数据传输设备。通过 NIC 接受的数据内有端口号，操作系统参考端口号把信息传给相应的应用程序。</p><p>端口号由 16 位无符号整数（0<del>2^16-1）构成，可分配的端口号范围是 0</del>65535 。但是 0~1023 是知名端口，一般分配给特定的应用程序，所以应当分配给此范围之外的值。</p><p>虽然端口号不能重复，但是 TCP 套接字和 UDP 套接字不会共用端接口号，所以允许重复。如果某 TCP 套接字使用了 9190 端口号，其他 TCP 套接字就无法使用该端口号，但是 UDP 套接字可以使用。</p><p>总之，数据传输目标地址同时包含IP地址和端口号，只有这样，数据才会被传输到最终的目的应用程序。</p><h3 id="3-2-地址信息的表示"><a href="#3-2-地址信息的表示" class="headerlink" title="3.2 地址信息的表示"></a>3.2 地址信息的表示</h3><p>应用程序中使用的IP地址和端口号以结构体的形式给出了定义。本节围绕结构体讨论目标地址的表示方法。</p><h4 id="3-2-1-表示-IPV4-地址的结构体"><a href="#3-2-1-表示-IPV4-地址的结构体" class="headerlink" title="3.2.1 表示 IPV4 地址的结构体"></a>3.2.1 表示 IPV4 地址的结构体</h4><p>结构体的定义如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">sa_family_t</span> sin_family;  <span class="hljs-comment">//地址族（Address Family）</span><br>    <span class="hljs-type">uint16_t</span> sin_port;       <span class="hljs-comment">//16 位 TCP/UDP 端口号</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">in_addr</span> <span class="hljs-title">sin_addr</span>;</span> <span class="hljs-comment">//32位 IP 地址</span><br>    <span class="hljs-type">char</span> sin_zero[<span class="hljs-number">8</span>];        <span class="hljs-comment">//不使用</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>该结构体中提到的另一个结构体 in_addr 定义如下，它用来存放 32 位IP地址</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">in_addr</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">in_addr_t</span> s_addr; <span class="hljs-comment">//32位IPV4地址</span><br>&#125;<br></code></pre></td></tr></table></figure><p>关于以上两个结构体的一些数据类型。</p><table><thead><tr><th align="center">数据类型名称</th><th align="center">数据类型说明</th><th align="center">声明的头文件</th></tr></thead><tbody><tr><td align="center">int 8_t</td><td align="center">signed 8-bit int</td><td align="center">sys&#x2F;types.h</td></tr><tr><td align="center">uint8_t</td><td align="center">unsigned 8-bit int (unsigned char)</td><td align="center">sys&#x2F;types.h</td></tr><tr><td align="center">int16_t</td><td align="center">signed 16-bit int</td><td align="center">sys&#x2F;types.h</td></tr><tr><td align="center">uint16_t</td><td align="center">unsigned 16-bit int (unsigned short)</td><td align="center">sys&#x2F;types.h</td></tr><tr><td align="center">int32_t</td><td align="center">signed 32-bit int</td><td align="center">sys&#x2F;types.h</td></tr><tr><td align="center">uint32_t</td><td align="center">unsigned 32-bit int (unsigned long)</td><td align="center">sys&#x2F;types.h</td></tr><tr><td align="center">sa_family_t</td><td align="center">地址族（address family）</td><td align="center">sys&#x2F;socket.h</td></tr><tr><td align="center">socklen_t</td><td align="center">长度（length of struct）</td><td align="center">sys&#x2F;socket.h</td></tr><tr><td align="center">in_addr_t</td><td align="center">IP地址，声明为 uint_32_t</td><td align="center">netinet&#x2F;in.h</td></tr><tr><td align="center">in_port_t</td><td align="center">端口号，声明为 uint_16_t</td><td align="center">netinet&#x2F;in.h</td></tr></tbody></table><p>为什么要额外定义这些数据类型呢？这是考虑扩展性的结果</p><h4 id="3-2-2-结构体-sockaddr-in-的成员分析"><a href="#3-2-2-结构体-sockaddr-in-的成员分析" class="headerlink" title="3.2.2 结构体 sockaddr_in 的成员分析"></a>3.2.2 结构体 sockaddr_in 的成员分析</h4><ul><li>成员 sin_family</li></ul><p>每种协议适用的地址族不同，比如，IPV4 使用 4 字节的地址族，IPV6 使用 16 字节的地址族。</p><blockquote><p>地址族</p></blockquote><table><thead><tr><th>地址族（Address Family）</th><th>含义</th></tr></thead><tbody><tr><td>AF_INET</td><td>IPV4用的地址族</td></tr><tr><td>AF_INET6</td><td>IPV6用的地址族</td></tr><tr><td>AF_LOCAL</td><td>本地通信中采用的 Unix 协议的地址族</td></tr></tbody></table><p>AF_LOACL 只是为了说明具有多种地址族而添加的。</p><ul><li><p>成员 sin_port</p><p>该成员保存 16 位端口号，重点在于，它以网络字节序保存。</p></li><li><p>成员 sin_addr</p><p>该成员保存 32 为IP地址信息，且也以网络字节序保存</p></li><li><p>成员 sin_zero</p><p>无特殊含义。只是为结构体 sockaddr_in 的大小与sockaddr结构体保持一致而插入的成员。填充零。</p><p>在之前的代码中 sockaddr_in 结构体变量地址值将以如下方式传递给 bind 函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (bind(serv_sock, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;serv_addr, <span class="hljs-keyword">sizeof</span>(serv_addr)) == <span class="hljs-number">-1</span>)<br>    error_handling(<span class="hljs-string">&quot;bind() error&quot;</span>);<br></code></pre></td></tr></table></figure><p>此处 bind 第二个参数期望得到的是 sockaddr 结构体变量的地址值，包括地址族、端口号、IP地址等。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">sa_family_t</span> sin_family; <span class="hljs-comment">//地址族</span><br>    <span class="hljs-type">char</span> sa_data[<span class="hljs-number">14</span>];       <span class="hljs-comment">//地址信息</span><br>&#125;<br></code></pre></td></tr></table></figure><p>sockaddr_in结构体作用：由于直接让结构体sockadd包含所需信息比较麻烦，所以用sockaddr_in结构体强制转换</p><p>此结构体 sa_data 保存的地址信息中需要包含IP地址和端口号，剩余部分应该填充 0 ，但是这样对于包含地址的信息非常麻烦，所以出现了 sockaddr_in 结构体，然后强制转换成 sockaddr 类型，则生成符合 bind 条件的参数。</p></li></ul><h3 id="3-3-网络字节序与地址变换"><a href="#3-3-网络字节序与地址变换" class="headerlink" title="3.3 网络字节序与地址变换"></a>3.3 网络字节序与地址变换</h3><p>不同的 CPU 中，4 字节整数值1在内存空间保存方式是不同的。</p><p>有些 CPU 这样保存：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">00000000 </span><span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000001</span><br></code></pre></td></tr></table></figure><p>有些 CPU 这样保存：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">00000001 </span><span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span><br></code></pre></td></tr></table></figure><p>两种一种是顺序保存，一种是倒序保存 。</p><h4 id="3-3-1-字节序（Order）与网络字节序"><a href="#3-3-1-字节序（Order）与网络字节序" class="headerlink" title="3.3.1 字节序（Order）与网络字节序"></a>3.3.1 字节序（Order）与网络字节序</h4><p>CPU 保存数据的方式有两种，这意味着 CPU 解析数据的方式也有 2 种：</p><ul><li>大端序（Big Endian）：高位字节存放到低位地址</li><li>小端序（Little Endian）：高位字节存放到高位地址</li></ul><p><img src="/.io//blog/blog/picture/5c3ac9c1b2550.png" alt="big.png"><br><img src="/.io//blog/blog/picture/5c3ac9c1c3348.png" alt="small.png"></p><p>两台字节序不同的计算机在数据传递的过程中可能出现的问题：</p><p><img src="/.io//blog/blog/picture/5c3aca956c8e9.png" alt="zijiexu.png"></p><p>因为这种原因，所以在通过网络传输数据时必须约定统一的方式，这种约定被称为网络字节序，&#x3D;&#x3D;<strong>非常简单，统一为大端序</strong>&#x3D;&#x3D;。即，先把数据数组转化成大端序格式再进行网络传输。</p><h4 id="3-3-2-字节序转换"><a href="#3-3-2-字节序转换" class="headerlink" title="3.3.2 字节序转换"></a>3.3.2 字节序转换</h4><p>帮助转换字节序的函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> <span class="hljs-title function_">htons</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">short</span>)</span>;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> <span class="hljs-title function_">ntohs</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">short</span>)</span>;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-title function_">htonl</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)</span>;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-title function_">ntohl</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)</span>;<br></code></pre></td></tr></table></figure><p>通过函数名称掌握其功能，只需要了解：</p><ul><li>htons 的 h 代表主机（host）字节序。</li><li>htons 的 n 代表网络（network）字节序。</li><li>s 代表 short</li><li>l 代表 long</li></ul><p>下面的代码是示例，说明以上函数调用过程：</p><p><a href="https://github.com/riba2534/TCP-IP-NetworkNote/blob/master/ch03/endian_conv.c">endian_conv.c</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> host_port = <span class="hljs-number">0x1234</span>;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> net_port;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> host_addr = <span class="hljs-number">0x12345678</span>;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> net_addr;<br><br>    net_port = <span class="hljs-built_in">htons</span>(host_port); <span class="hljs-comment">//转换为网络字节序</span><br>    net_addr = <span class="hljs-built_in">htonl</span>(host_addr);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Host ordered port: %#x \n&quot;</span>, host_port);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Network ordered port: %#x \n&quot;</span>, net_port);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Host ordered address: %#lx \n&quot;</span>, host_addr);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Network ordered address: %#lx \n&quot;</span>, net_addr);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc endian_conv.c -o conv<br>./conv<br></code></pre></td></tr></table></figure><p>结果：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">Host <span class="hljs-keyword">ordered </span>port: <span class="hljs-number">0x1234</span><br>Network <span class="hljs-keyword">ordered </span>port: <span class="hljs-number">0x3412</span><br>Host <span class="hljs-keyword">ordered </span><span class="hljs-keyword">address: </span><span class="hljs-number">0x12345678</span><br>Network <span class="hljs-keyword">ordered </span><span class="hljs-keyword">address: </span><span class="hljs-number">0x78563412</span><br></code></pre></td></tr></table></figure><p>这是在小端 CPU 的运行结果。大部分人会得到相同的结果，因为 Intel 和 AMD 的 CPU 都是小端序为标准。</p><h3 id="3-4-网络地址的初始化与分配"><a href="#3-4-网络地址的初始化与分配" class="headerlink" title="3.4 网络地址的初始化与分配"></a>3.4 网络地址的初始化与分配</h3><h4 id="3-4-1-将字符串信息转换为网络字节序的整数型"><a href="#3-4-1-将字符串信息转换为网络字节序的整数型" class="headerlink" title="3.4.1 将字符串信息转换为网络字节序的整数型"></a>3.4.1 将字符串信息转换为网络字节序的整数型</h4><p>sockaddr_in 中需要的是 32 位整数型，但是我们只熟悉点分十进制表示法，那么改如何把类似于 201.211.214.36 转换为 4 字节的整数类型数据呢 ?幸运的是，有一个函数可以帮助我们完成它。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-type">in_addr_t</span> <span class="hljs-title function_">inet_addr</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-built_in">string</span>)</span>;<br></code></pre></td></tr></table></figure><p>具体示例：</p><p><a href="https://github.com/riba2534/TCP-IP-NetworkNote/blob/master/ch03/inet_addr.c">inet_addr.c</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br>    <span class="hljs-type">char</span> *addr1 = <span class="hljs-string">&quot;1.2.3.4&quot;</span>;<br>    <span class="hljs-type">char</span> *addr2 = <span class="hljs-string">&quot;1.2.3.256&quot;</span>;<br><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> conv_addr = inet_addr(addr1);<br>    <span class="hljs-keyword">if</span> (conv_addr == INADDR_NONE)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Error occured! \n&quot;</span>);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Network ordered integer addr: %#lx \n&quot;</span>, conv_addr);<br><br>    conv_addr = inet_addr(addr2);<br>    <span class="hljs-keyword">if</span> (conv_addr == INADDR_NONE)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Error occured! \n&quot;</span>);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Network ordered integer addr: %#lx \n&quot;</span>, conv_addr);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc inet_addr.c -o addr<br>./addr<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs subunit">Network ordered integer addr: 0x4030201<br><span class="hljs-keyword">Error </span>occured!<br></code></pre></td></tr></table></figure><p>1个字节能表示的最大整数是255，所以代码中 addr2 是错误的IP地址。从运行结果看，inet_addr 不仅可以转换地址，还可以检测有效性。</p><p>inet_aton 函数与 inet_addr 函数在功能上完全相同，也是将字符串形式的IP地址转换成整数型的IP地址。只不过该函数用了 in_addr 结构体，且使用频率更高。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">inet_aton</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-built_in">string</span>, <span class="hljs-keyword">struct</span> in_addr *addr)</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">成功时返回 1 ，失败时返回 0</span><br><span class="hljs-comment">string: 含有需要转换的IP地址信息的字符串地址值</span><br><span class="hljs-comment">addr: 将保存转换结果的 in_addr 结构体变量的地址值</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>函数调用示例：</p><p><a href="https://github.com/riba2534/TCP-IP-NetworkNote/blob/master/ch03/inet_aton.c">inet_aton.c</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-type">void</span> <span class="hljs-title function_">error_handling</span><span class="hljs-params">(<span class="hljs-type">char</span> *message)</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br>    <span class="hljs-type">char</span> *addr = <span class="hljs-string">&quot;127.232.124.79&quot;</span>;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">addr_inet</span>;</span><br><br>    <span class="hljs-keyword">if</span> (!inet_aton(addr, &amp;addr_inet.sin_addr))<br>        error_handling(<span class="hljs-string">&quot;Conversion error&quot;</span>);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Network ordered integer addr: %#x \n&quot;</span>, addr_inet.sin_addr.s_addr);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">error_handling</span><span class="hljs-params">(<span class="hljs-type">char</span> *message)</span><br>&#123;<br>    <span class="hljs-built_in">fputs</span>(message, <span class="hljs-built_in">stderr</span>);<br>    fputc(<span class="hljs-string">&#x27;\n&#x27;</span>, <span class="hljs-built_in">stderr</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>编译运行：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">gcc inet_aton.c -o aton<br>./aton<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">Network <span class="hljs-keyword">ordered </span>integer <span class="hljs-keyword">addr: </span><span class="hljs-number">0x4f7ce87f</span><br></code></pre></td></tr></table></figure><p>可以看出，已经成功的把转换后的地址放进了 addr_inet.sin_addr.s_addr 中。</p><p>还有一个函数，与 inet_aton() 正好相反，它可以把网络字节序整数型IP地址转换成我们熟悉的字符串形式，函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-type">char</span> *<span class="hljs-title function_">inet_ntoa</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> in_addr adr)</span>;<br></code></pre></td></tr></table></figure><p>该函数将通过参数传入的整数型IP地址转换为字符串格式并返回。但要小心，返回值为 char 指针，返回字符串地址意味着字符串已经保存在内存空间，但是该函数未向程序员要求分配内存，而是再内部申请了内存保存了字符串。也就是说调用了该函数候要立即把信息复制到其他内存空间。因此，若再次调用 inet_ntoa 函数，则有可能覆盖之前保存的字符串信息。总之，再次调用 inet_ntoa 函数前返回的字符串地址是有效的。若需要长期保存，则应该将字符串复制到其他内存空间。</p><p>示例：</p><p><a href="https://github.com/riba2534/TCP-IP-NetworkNote/blob/master/ch03/inet_ntoa.c">inet_ntoa.c</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">addr1</span>, <span class="hljs-title">addr2</span>;</span><br>    <span class="hljs-type">char</span> *str_ptr;<br>    <span class="hljs-type">char</span> str_arr[<span class="hljs-number">20</span>];<br><br>    addr1.sin_addr.s_addr = htonl(<span class="hljs-number">0x1020304</span>);<br>    addr2.sin_addr.s_addr = htonl(<span class="hljs-number">0x1010101</span>);<br>    <span class="hljs-comment">//把addr1中的结构体信息转换为字符串的IP地址形式</span><br>    str_ptr = inet_ntoa(addr1.sin_addr);<br>    <span class="hljs-built_in">strcpy</span>(str_arr, str_ptr);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Dotted-Decimal notation1: %s \n&quot;</span>, str_ptr);<br><br>    inet_ntoa(addr2.sin_addr);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Dotted-Decimal notation2: %s \n&quot;</span>, str_ptr);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Dotted-Decimal notation3: %s \n&quot;</span>, str_arr);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc inet_ntoa.c -o ntoa<br>./ntoa<br></code></pre></td></tr></table></figure><p>输出:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">Dotted-Decimal notation1: <span class="hljs-number">1.2</span><span class="hljs-number">.3</span><span class="hljs-number">.4</span><br>Dotted-Decimal notation2: <span class="hljs-number">1.1</span><span class="hljs-number">.1</span><span class="hljs-number">.1</span><br>Dotted-Decimal notation3: <span class="hljs-number">1.2</span><span class="hljs-number">.3</span><span class="hljs-number">.4</span><br></code></pre></td></tr></table></figure><h4 id="3-4-2-网络地址初始化"><a href="#3-4-2-网络地址初始化" class="headerlink" title="3.4.2 网络地址初始化"></a>3.4.2 网络地址初始化</h4><p>结合前面的内容，介绍套接字创建过程中，常见的网络信息初始化方法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">addr</span>;</span><br><span class="hljs-type">char</span> *serv_ip = <span class="hljs-string">&quot;211.217,168.13&quot;</span>;          <span class="hljs-comment">//声明IP地址族</span><br><span class="hljs-type">char</span> *serv_port = <span class="hljs-string">&quot;9190&quot;</span>;                  <span class="hljs-comment">//声明端口号字符串</span><br><span class="hljs-built_in">memset</span>(&amp;addr, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(addr));            <span class="hljs-comment">//结构体变量 addr 的所有成员初始化为0</span><br>addr.sin_family = AF_INET;                 <span class="hljs-comment">//制定地址族</span><br>addr.sin_addr.s_addr = inet_addr(serv_ip); <span class="hljs-comment">//基于字符串的IP地址初始化</span><br>addr.sin_port = htons(atoi(serv_port));    <span class="hljs-comment">//基于字符串的IP地址端口号初始化</span><br></code></pre></td></tr></table></figure><h3 id="3-5-基于-Windows-的实现"><a href="#3-5-基于-Windows-的实现" class="headerlink" title="3.5 基于 Windows 的实现"></a>3.5 基于 Windows 的实现</h3><p>略</p><h3 id="3-6-习题"><a href="#3-6-习题" class="headerlink" title="3.6 习题"></a>3.6 习题</h3><blockquote><p>答案仅代表本人个人观点，不一定正确</p></blockquote><ol><li><p><strong>IP地址族 IPV4 与 IPV6 有什么区别？在何种背景下诞生了 IPV6?</strong></p><p>答：主要差别是IP地址所用的字节数，目前通用的是IPV4，目前IPV4的资源已耗尽，所以诞生了IPV6，它具有更大的地址空间。</p></li><li><p><strong>通过 IPV4 网络 ID 、主机 ID 及路由器的关系说明公司局域网的计算机传输数据的过程</strong></p><p>答：网络ID是为了区分网络而设置的一部分IP地址，假设向<code>www.baidu.com</code>公司传输数据，该公司内部构建了局域网。因为首先要向<code>baidu.com</code>传输数据，也就是说并非一开始就浏览所有四字节IP地址，首先找到网络地址，进而由<code>baidu.com</code>（构成网络的路由器）接收到数据后，传输到主机地址。比如向 203.211.712.103 传输数据，那就先找到 203.211.172 然后由这个网络的网关找主机号为 172 的机器传输数据。</p></li><li><p><strong>套接字地址分为IP地址和端口号，为什么需要IP地址和端口号？或者说，通过IP地址可以区分哪些对象？通过端口号可以区分哪些对象？</strong></p><p>答：有了IP地址和端口号，才能把数据准确的传送到某个应用程序中。通过IP地址可以区分具体的主机，通过端口号可以区分主机上的应用程序。</p></li><li><p><strong>请说明IP地址的分类方法，并据此说出下面这些IP的分类。</strong></p><ul><li>214.121.212.102（C类）</li><li>120.101.122.89（A类）</li><li>129.78.102.211（B类）</li></ul><p>分类方法：A 类地址的首字节范围为：0<del>127、B 类地址的首字节范围为：128</del>191、C 类地址的首字节范围为：192~223</p></li><li><p><strong>计算机通过路由器和交换机连接到互联网，请说出路由器和交换机的作用。</strong></p><p>答：路由器和交换机完成外网和本网主机之间的数据交换。</p></li><li><p><strong>什么是知名端口？其范围是多少？知名端口中具有代表性的 HTTP 和 FTP 的端口号各是多少？</strong></p><p>答：知名端口是要把该端口分配给特定的应用程序，范围是 0~1023 ，HTTP 的端口号是 80 ，FTP 的端口号是20和21</p></li><li><p><strong>向套接字分配地址的 bind 函数原型如下：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">bind</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-keyword">struct</span> sockaddr *myaddr, <span class="hljs-type">socklen_t</span> addrlen)</span>;<br></code></pre></td></tr></table></figure><p><strong>而调用时则用：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">bind(serv_sock, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;serv_addr, <span class="hljs-keyword">sizeof</span>(serv_addr)<br></code></pre></td></tr></table></figure><p><strong>此处 serv_addr 为 sockaddr_in 结构体变量。与函数原型不同，传入的是 sockaddr_in 结构体变量，请说明原因。</strong></p><p>答：因为对于详细的地址信息使用 sockaddr 类型传递特别麻烦，进而有了 sockaddr_in 类型，其中基本与前面的类型保持一致，还有 sa_sata[4] 来保存地址信息，剩余全部填 0，所以强制转换后，不影响程序运行。</p></li><li><p><strong>请解释大端序，小端序、网络字节序，并说明为何需要网络字节序。</strong></p><p>答：CPU 向内存保存数据有两种方式，大端序是高位字节存放低位地址，小端序是高位字节存放高位地址，网络字节序是为了方便传输的信息统一性，统一成了大端序。</p></li><li><p><strong>大端序计算机希望把 4 字节整数型 12 传递到小端序计算机。请说出数据传输过程中发生的字节序变换过程。</strong></p><p>答：’0x12-&gt;0x21’<br>更正：0x0000000c-&gt;0x0000000c-&gt;0x0c000000</p></li><li><p><strong>怎样表示回送地址？其含义是什么？如果向会送地址处传输数据将会发生什么情况？</strong></p><p>答：127.0.0.1 表示回送地址，指的是计算机自身的IP地址，无论什么程序，一旦使用回送地址发送数据，协议软件立即返回，不进行任何网络传输。</p></li></ol><h2 id="第-4-章-基于-TCP-的服务端-客户端（1）"><a href="#第-4-章-基于-TCP-的服务端-客户端（1）" class="headerlink" title="第 4 章 基于 TCP 的服务端&#x2F;客户端（1）"></a>第 4 章 基于 TCP 的服务端&#x2F;客户端（1）</h2><p>本章代码，在<a href="https://github.com/riba2534/TCP-IP-NetworkNote">TCP-IP-NetworkNote</a>中可以找到。</p><h3 id="4-1-理解-TCP-和-UDP"><a href="#4-1-理解-TCP-和-UDP" class="headerlink" title="4.1 理解 TCP 和 UDP"></a>4.1 理解 TCP 和 UDP</h3><p>根据数据传输方式的不同，基于网络协议的套接字一般分为 TCP 套接字和 UDP 套接字。因为 TCP 套接字是面向连接的，因此又被称为基于流（stream）的套接字。</p><p>TCP 是 Transmission Control Protocol （传输控制协议）的简写，意为「对数据传输过程的控制」。因此，学习控制方法及范围有助于正确理解 TCP 套接字。</p><h4 id="4-1-1-TCP-IP-协议栈"><a href="#4-1-1-TCP-IP-协议栈" class="headerlink" title="4.1.1 TCP&#x2F;IP 协议栈"></a>4.1.1 TCP&#x2F;IP 协议栈</h4><p><img src="/.io//blog/blog/picture/5c3c21889db06.png"></p><p>TCP&#x2F;IP 协议栈共分为 4 层，可以理解为数据收发分成了 4 个层次化过程，通过层次化的方式来解决问题</p><h4 id="4-1-2-链路层"><a href="#4-1-2-链路层" class="headerlink" title="4.1.2 链路层"></a>4.1.2 链路层</h4><p>链路层是物理链接领域标准化的结果，也是最基本的领域，专门定义LAN、WAN、MAN等网络标准。若两台主机通过网络进行数据交换，则需要物理连接，链路层就负责这些标准。</p><h4 id="4-1-3-IP-层"><a href="#4-1-3-IP-层" class="headerlink" title="4.1.3 IP 层"></a>4.1.3 IP 层</h4><p>转备好物理连接候就要传输数据。为了再复杂网络中传输数据，首先要考虑路径的选择。向目标传输数据需要经过哪条路径？解决此问题的就是IP层，该层使用的协议就是IP。</p><p>IP 是面向消息的、不可靠的协议。每次传输数据时会帮我们选择路径，但并不一致。如果传输过程中发生错误，则选择其他路径，但是如果发生数据丢失或错误，则无法解决。换言之，IP协议无法应对数据错误。</p><h4 id="4-1-4-TCP-UDP-层"><a href="#4-1-4-TCP-UDP-层" class="headerlink" title="4.1.4 TCP&#x2F;UDP 层"></a>4.1.4 TCP&#x2F;UDP 层</h4><p>IP 层解决数据传输中的路径选择问题，只需照此路径传输数据即可。TCP 和 UDP 层以 IP 层提供的路径信息为基础完成实际的数据传输，故该层又称为传输层。UDP 比 TCP 简单，现在我们只解释 TCP 。 TCP 可以保证数据的可靠传输，但是它发送数据时以 IP 层为基础（这也是协议栈层次化的原因）</p><p>IP 层只关注一个数据包（数据传输基本单位）的传输过程。因此，即使传输多个数据包，每个数据包也是由 IP 层实际传输的，也就是说传输顺序及传输本身是不可靠的。若只利用IP层传输数据，则可能导致后传输的数据包B比先传输的数据包A提早到达。另外，传输的数据包A、B、C中可能只收到A和C，甚至收到的C可能已经损毁 。反之，若添加 TCP 协议则按照如下对话方式进行数据交换。</p><blockquote><p>主机A：正确接受第二个数据包</p><p>主机B：恩，知道了</p><p>主机A：正确收到第三个数据包</p><p>主机B：可我已经发送第四个数据包了啊！哦，您没收到吧，我给你重新发。</p></blockquote><p>这就是 TCP 的作用。如果交换数据的过程中可以确认对方已经收到数据，并重传丢失的数据，那么即便IP层不保证数据传输，这类通信也是可靠的。</p><p><img src="/.io//blog/blog/picture/5c3c268b40be6.png"></p><h4 id="4-1-5-应用层"><a href="#4-1-5-应用层" class="headerlink" title="4.1.5 应用层"></a>4.1.5 应用层</h4><p>上述内容是套接字通信过程中自动处理的。选择数据传输路径、数据确认过程都被隐藏到套接字内部。向程序员提供的工具就是套接字，只需要利用套接字编出程序即可。编写软件的过程中，需要根据程序的特点来决定服务器和客户端之间的数据传输规则，这便是应用层协议。</p><h3 id="4-2-实现基于-TCP-的服务器-客户端"><a href="#4-2-实现基于-TCP-的服务器-客户端" class="headerlink" title="4.2 实现基于 TCP 的服务器&#x2F;客户端"></a>4.2 实现基于 TCP 的服务器&#x2F;客户端</h3><h4 id="4-2-1-TCP-服务端的默认函数的调用程序"><a href="#4-2-1-TCP-服务端的默认函数的调用程序" class="headerlink" title="4.2.1 TCP 服务端的默认函数的调用程序"></a>4.2.1 TCP 服务端的默认函数的调用程序</h4><p><img src="/.io//blog/blog/picture/5c3c2782a7810.png"></p><p>调用 socket 函数创建套接字，声明并初始化地址信息的结构体变量，调用 bind 函数向套接字分配地址。</p><h4 id="4-2-2-进入等待连接请求状态"><a href="#4-2-2-进入等待连接请求状态" class="headerlink" title="4.2.2 进入等待连接请求状态"></a>4.2.2 进入等待连接请求状态</h4><p>已经调用了 bind 函数给套接字分配地址，接下来就是要通过调用 listen 函数进入等待连接请求状态。只有调用了 listen 函数，客户端才能进入可发出连接请求的状态。换言之，这时客户端才能调用 connect 函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">listen</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-type">int</span> backlog)</span>;<br><span class="hljs-comment">//成功时返回0，失败时返回-1</span><br><span class="hljs-comment">//sock: 希望进入等待连接请求状态的套接字文件描述符，传递的描述符套接字参数称为服务端套接字</span><br><span class="hljs-comment">//backlog: 连接请求等待队列的长度，若为5，则队列长度为5，表示最多使5个连接请求进入队列            </span><br></code></pre></td></tr></table></figure><h4 id="4-2-3-受理客户端连接请求"><a href="#4-2-3-受理客户端连接请求" class="headerlink" title="4.2.3 受理客户端连接请求"></a>4.2.3 受理客户端连接请求</h4><p>调用 listen 函数后，则应该按序受理。受理请求意味着可接受数据的状态。进入这种状态所需的部件是<strong>套接字</strong>，但是此时使用的不是服务端套接字，此时需要另一个套接字，但是没必要亲自创建，下面的函数将自动创建套接字。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-keyword">struct</span> sockaddr *addr, <span class="hljs-type">socklen_t</span> *addrlen)</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">成功时返回文件描述符，失败时返回-1</span><br><span class="hljs-comment">sock: 服务端套接字的文件描述符</span><br><span class="hljs-comment">addr: 保存发起连接请求的客户端地址信息的变量地址值</span><br><span class="hljs-comment">addrlen: 的第二个参数addr结构体的长度，但是存放有长度的变量地址。</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>sccept 函数受理连接请求队列中待处理的客户端连接请求。函数调用成功后，accept 内部将产生用于数据 I&#x2F;O 的套接字，并返回其文件描述符。需要强调的是套接字是自动创建的，并自动与发起连接请求的客户端建立连接。</p><h4 id="4-2-4-回顾-Hello-World-服务端"><a href="#4-2-4-回顾-Hello-World-服务端" class="headerlink" title="4.2.4 回顾 Hello World 服务端"></a>4.2.4 回顾 Hello World 服务端</h4><ul><li>代码：<a href="https://github.com/riba2534/TCP-IP-NetworkNote/blob/master/ch04/hello_server.c">hello_server.c</a></li></ul><p>重新整理一下代码的思路</p><ol><li>服务端实现过程中首先要创建套接字，此时的套接字并非是真正的服务端套接字</li><li>为了完成套接字地址的分配，初始化结构体变量并调用 bind 函数。</li><li>调用 listen 函数进入等待连接请求状态。连接请求状态队列的长度设置为5.此时的套接字才是服务端套接字。</li><li>调用 accept 函数从队头取 1 个连接请求与客户端建立连接，并返回创建的套接字文件描述符。另外，调用 accept 函数时若等待队列为空，则 accept 函数不会返回，直到队列中出现新的客户端连接。</li><li>调用 write 函数向客户端传送数据，调用 close 关闭连接</li></ol><h4 id="4-2-5-TCP-客户端的默认函数调用顺序"><a href="#4-2-5-TCP-客户端的默认函数调用顺序" class="headerlink" title="4.2.5 TCP 客户端的默认函数调用顺序"></a>4.2.5 TCP 客户端的默认函数调用顺序</h4><p><img src="/.io//blog/blog/picture/5c3c31d77e86c.png"></p><p>与服务端相比，区别就在于「请求连接」，他是创建客户端套接字后向服务端发起的连接请求。服务端调用 listen 函数后创建连接请求等待队列，之后客户端即可请求连接。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">connect</span><span class="hljs-params">(<span class="hljs-type">int</span> sock, <span class="hljs-keyword">struct</span> sockaddr *servaddr, <span class="hljs-type">socklen_t</span> addrlen)</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">成功时返回0，失败返回-1</span><br><span class="hljs-comment">sock:客户端套接字文件描述符</span><br><span class="hljs-comment">servaddr: 保存目标服务器端地址信息的变量地址值</span><br><span class="hljs-comment">addrlen: 以字节为单位传递给第二个结构体参数 servaddr 的变量地址长度</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>客户端调用 connect 函数候，发生以下函数之一才会返回（完成函数调用）:</p><ul><li>服务端接受连接请求</li><li>发生断网等一场状况而中断连接请求</li></ul><p>注意：<strong>接受连接</strong>不代表服务端调用 accept 函数，其实只是服务器端把连接请求信息记录到等待队列。因此 connect 函数返回后并不应该立即进行数据交换。</p><h4 id="4-2-6-回顾-Hello-World-客户端"><a href="#4-2-6-回顾-Hello-World-客户端" class="headerlink" title="4.2.6 回顾 Hello World 客户端"></a>4.2.6 回顾 Hello World 客户端</h4><ul><li>代码：<a href="https://github.com/riba2534/TCP-IP-NetworkNote/blob/master/ch04/hello_client.c">hello_client.c</a></li></ul><p>重新理解这个程序：</p><ol><li>创建准备连接服务器的套接字，此时创建的是 TCP 套接字</li><li>结构体变量 serv_addr 中初始化IP和端口信息。初始化值为目标服务器端套接字的IP和端口信息。</li><li>调用 connect 函数向服务端发起连接请求</li><li>完成连接后，接收服务端传输的数据</li><li>接收数据后调用 close 函数关闭套接字，结束与服务器端的连接。</li></ol><h4 id="4-2-7-基于-TCP-的服务端-客户端函数调用关系"><a href="#4-2-7-基于-TCP-的服务端-客户端函数调用关系" class="headerlink" title="4.2.7 基于 TCP 的服务端&#x2F;客户端函数调用关系"></a>4.2.7 基于 TCP 的服务端&#x2F;客户端函数调用关系</h4><p><img src="/.io//blog/blog/picture/5c3c35a773b8c.png"></p><p>关系如上图所示。</p><h3 id="4-3-实现迭代服务端-客户端"><a href="#4-3-实现迭代服务端-客户端" class="headerlink" title="4.3 实现迭代服务端&#x2F;客户端"></a>4.3 实现迭代服务端&#x2F;客户端</h3><p>编写一个回声（echo）服务器&#x2F;客户端。顾名思义，服务端将客户端传输的字符串数据原封不动的传回客户端，就像回声一样。在此之前，需要解释一下迭代服务器端。</p><h4 id="4-3-1-实现迭代服务器端"><a href="#4-3-1-实现迭代服务器端" class="headerlink" title="4.3.1 实现迭代服务器端"></a>4.3.1 实现迭代服务器端</h4><p>在 Hello World 的例子中，等待队列的作用没有太大意义。如果想继续处理好后面的客户端请求应该怎样扩展代码？最简单的方式就是插入循环反复调用 accept 函数，如图:</p><p><img src="/.io//blog/blog/picture/5c3d3c8a283ad.png"></p><p>可以看出，调用 accept 函数后，紧接着调用 I&#x2F;O 相关的 read write 函数，然后调用 close 函数。这并非针对服务器套接字，而是针对 accept 函数调用时创建的套接字。</p><h4 id="4-3-2-迭代回声服务器端-客户端"><a href="#4-3-2-迭代回声服务器端-客户端" class="headerlink" title="4.3.2 迭代回声服务器端&#x2F;客户端"></a>4.3.2 迭代回声服务器端&#x2F;客户端</h4><p>程序运行的基本方式：</p><ul><li>服务器端在同一时刻只与一个客户端相连，并提供回声服务。</li><li>服务器端依次向 5 个客户端提供服务并退出。</li><li>客户端接受用户输入的字符串并发送到服务器端。</li><li>服务器端将接受的字符串数据传回客户端，即「回声」</li><li>服务器端与客户端之间的字符串回声一直执行到客户端输入 Q 为止。</li></ul><p>以下是服务端与客户端的代码：</p><ul><li><a href="https://github.com/riba2534/TCP-IP-NetworkNote/blob/master/ch04/echo_server.c">echo_server.c</a></li><li><a href="https://github.com/riba2534/TCP-IP-NetworkNote/blob/master/ch04/echo_client.c">echo_client.c</a></li></ul><p>编译:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc echo_client.c -o eclient<br>gcc echo_server.c -o eserver<br></code></pre></td></tr></table></figure><p>分别运行:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">./eserver 9190<br>./eclient 127.0.0.1 9190<br></code></pre></td></tr></table></figure><p>过程和结果：</p><p>在一个服务端开启后，用另一个终端窗口开启客户端，然后程序会让你输入字符串，然后客户端输入什么字符串，客户端就会返回什么字符串，按 q 退出。这时服务端的运行并没有结束，服务端一共要处理 5 个客户端的连接，所以另外开多个终端窗口同时开启客户端，服务器按照顺序进行处理。</p><p>server:<br><img src="/.io//blog/blog/picture/5c3d523d0a675.png" alt="server.png"></p><p>client:<br><img src="/.io//blog/blog/picture/5c3d523d336e7.png" alt="client.png"></p><h4 id="4-3-3-回声客户端存在的问题"><a href="#4-3-3-回声客户端存在的问题" class="headerlink" title="4.3.3 回声客户端存在的问题"></a>4.3.3 回声客户端存在的问题</h4><p>以上代码有一个假设「每次调用 read、write函数时都会以字符串为单位执行实际 I&#x2F;O 操作」</p><p>但是「第二章」中说过「TCP 不存在数据边界」，上述客户端是基于 TCP 的，因此多次调用 write 函数传递的字符串有可能一次性传递到服务端。此时客户端有可能从服务端收到多个字符串，这不是我们想要的结果。还需要考虑服务器的如下情况：</p><p>「字符串太长，需要分 2 个包发送！」</p><p>服务端希望通过调用 1 次 write 函数传输数据，但是如果数据太大，操作系统就有可能把数据分成多个数据包发送到客户端。另外，在此过程中，客户端可能在尚未收到全部数据包时就调用 read 函数。</p><p>以上的问题都是源自 TCP 的传输特性，解决方法在第 5 章。</p><h3 id="4-4-基于-Windows-的实现"><a href="#4-4-基于-Windows-的实现" class="headerlink" title="4.4 基于 Windows 的实现"></a>4.4 基于 Windows 的实现</h3><p>暂略</p><h3 id="4-5-习题"><a href="#4-5-习题" class="headerlink" title="4.5 习题"></a>4.5 习题</h3><blockquote><p>答案仅代表本人个人观点，不一定是正确答案。</p></blockquote><ol><li><p><strong>请你说明 TCP&#x2F;IP 的 4 层协议栈，并说明 TCP 和 UDP 套接字经过的层级结构差异。</strong></p><p>答：TCP&#x2F;IP 的四层协议分为：应用层、TCP&#x2F;UDP 层、IP层、链路层。差异是一个经过 TCP 层，一个经过 UDP 层。</p></li><li><p><strong>请说出 TCP&#x2F;IP 协议栈中链路层和IP层的作用，并给出二者关系</strong></p><p>答：链路层是物理链接领域标准化的结果，专门定义网络标准。若两台主机通过网络进行数据交换，则首先要做到的就是进行物理链接。IP层：为了在复杂的网络中传输数据，首先需要考虑路径的选择。关系：链路层负责进行一系列物理连接，而IP层负责选择正确可行的物理路径。</p></li><li><p><strong>为何需要把 TCP&#x2F;IP 协议栈分成 4 层（或7层）？开放式回答。</strong></p><p>答：ARPANET 的研制经验表明，对于复杂的计算机网络协议，其结构应该是层次式的。分层的好处：①隔层之间是独立的②灵活性好③结构上可以分隔开④易于实现和维护⑤能促进标准化工作。</p></li><li><p><strong>客户端调用 connect 函数向服务器端发送请求。服务器端调用哪个函数后，客户端可以调用 connect 函数？</strong></p><p>答：服务端调用 listen 函数后，客户端可以调用 connect 函数。因为，服务端调用 listen 函数后，服务端套接字才有能力接受请求连接的信号。</p></li><li><p><strong>什么时候创建连接请求等待队列？它有何种作用？与 accept 有什么关系？</strong></p><p>答：服务端调用 listen 函数后，accept函数正在处理客户端请求时， 更多的客户端发来了请求连接的数据，此时，就需要创建连接请求等待队列。以便于在accept函数处理完手头的请求之后，按照正确的顺序处理后面正在排队的其他请求。与accept函数的关系：accept函数受理连接请求等待队列中待处理的客户端连接请求。</p></li><li><p><strong>客户端中为何不需要调用 bind 函数分配地址？如果不调用 bind 函数，那何时、如何向套接字分配IP地址和端口号？</strong></p><p>答：在调用 connect 函数时分配了地址，客户端IP地址和端口在调用 connect 函数时自动分配，无需调用标记的 bind 函数进行分配。</p></li></ol><h2 id="第-5-章-基于-TCP-的服务端-客户端（2）"><a href="#第-5-章-基于-TCP-的服务端-客户端（2）" class="headerlink" title="第 5 章 基于 TCP 的服务端&#x2F;客户端（2）"></a>第 5 章 基于 TCP 的服务端&#x2F;客户端（2）</h2><p>本章代码，在<a href="https://github.com/riba2534/TCP-IP-NetworkNote">TCP-IP-NetworkNote</a>中可以找到。</p><p>上一章仅仅是从编程角度学习实现方法，并未详细讨论 TCP 的工作原理。因此，本章将想次讲解 TCP 中必要的理论知识，还将给出第 4 章客户端问题的解决方案。</p><h3 id="5-1-回声客户端的完美实现"><a href="#5-1-回声客户端的完美实现" class="headerlink" title="5.1 回声客户端的完美实现"></a>5.1 回声客户端的完美实现</h3><h4 id="5-1-1-回声服务器没有问题，只有回声客户端有问题？"><a href="#5-1-1-回声服务器没有问题，只有回声客户端有问题？" class="headerlink" title="5.1.1 回声服务器没有问题，只有回声客户端有问题？"></a>5.1.1 回声服务器没有问题，只有回声客户端有问题？</h4><p>问题不在服务器端，而在客户端，只看代码可能不好理解，因为 I&#x2F;O 中使用了相同的函数。先回顾一下服务器端的 I&#x2F;O 相关代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">while</span> ((str_len = read(clnt_sock, message, BUF_SIZE)) != <span class="hljs-number">0</span>)<br>    write(clnt_sock, message, str_len);<br></code></pre></td></tr></table></figure><p>接着是客户端代码:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">write(sock, message, <span class="hljs-built_in">strlen</span>(message));<br>str_len = read(sock, message, BUF_SIZE - <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>二者都在村换调用 read 和 write 函数。实际上之前的回声客户端将 100% 接受自己传输的数据，只不过接受数据时的单位有些问题。扩展客户端代码回顾范围，下面是，客户端的代码:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>&#123;<br>    <span class="hljs-built_in">fputs</span>(<span class="hljs-string">&quot;Input message(Q to quit): &quot;</span>, <span class="hljs-built_in">stdout</span>);<br>    fgets(message, BUF_SIZE, <span class="hljs-built_in">stdin</span>);<br><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(message, <span class="hljs-string">&quot;q\n&quot;</span>) || !<span class="hljs-built_in">strcmp</span>(message, <span class="hljs-string">&quot;Q\n&quot;</span>))<br>        <span class="hljs-keyword">break</span>;<br><br>    write(sock, message, <span class="hljs-built_in">strlen</span>(message));<br>    str_len = read(sock, message, BUF_SIZE - <span class="hljs-number">1</span>);<br>    message[str_len] = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Message from server: %s&quot;</span>, message);<br>&#125;<br></code></pre></td></tr></table></figure><p>现在应该理解了问题，回声客户端传输的是字符串，而且是通过调用 write 函数一次性发送的。之后还调用一次 read 函数，期待着接受自己传输的字符串，这就是问题所在。</p><h4 id="5-1-2-回声客户端问题的解决办法"><a href="#5-1-2-回声客户端问题的解决办法" class="headerlink" title="5.1.2 回声客户端问题的解决办法"></a>5.1.2 回声客户端问题的解决办法</h4><p>这个问题其实很容易解决，因为可以提前接受数据的大小。若之前传输了20字节长的字符串，则再接收时循环调用 read 函数读取 20 个字节即可。既然有了解决办法，那么代码如下：</p><ul><li><a href="https://github.com/riba2534/TCP-IP-NetworkNote/blob/master/ch05/echo_client2.c">echo_client2.c</a></li></ul><p>这样修改为了接收所有传输数据而循环调用 read 函数。测试及运行结果可参考第四章。</p><h4 id="5-1-3-如果问题不在于回声客户端：定义应用层协议"><a href="#5-1-3-如果问题不在于回声客户端：定义应用层协议" class="headerlink" title="5.1.3 如果问题不在于回声客户端：定义应用层协议"></a>5.1.3 如果问题不在于回声客户端：定义应用层协议</h4><p>回声客户端可以提前知道接收数据的长度，这在大多数情况下是不可能的。那么此时无法预知接收数据长度时应该如何手法数据？这是需要的是<strong>应用层协议</strong>的定义。在收发过程中定好规则（协议）以表示数据边界，或者提前告知需要发送的数据的大小。服务端&#x2F;客户端实现过程中逐步定义的规则集合就是应用层协议。</p><p>现在写一个小程序来体验应用层协议的定义过程。要求：</p><ol><li>服务器从客户端获得多个数组和运算符信息。</li><li>服务器接收到数字后对其进行加减乘运算，然后把结果传回客户端。</li></ol><p>例：</p><ol><li>向服务器传递3,5,9的同时请求加法运算，服务器返回3+5+9的结果</li><li>请求做乘法运算，客户端会收到<code>3*5*9</code>的结果</li><li>如果向服务器传递4,3,2的同时要求做减法，则返回4-3-2的运算结果。</li></ol><p>请自己实现一个程序来实现功能。</p><p>我自己的实现：</p><ul><li><a href="https://github.com/riba2534/TCP-IP-NetworkNote/blob/master/ch05/My_op_server.c">My_op_server.c</a></li><li><a href="https://github.com/riba2534/TCP-IP-NetworkNote/blob/master/ch05/My_op_client.c">My_op_client.c</a></li></ul><p>编译：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc My_op_client.c -o myclient<br>gcc My_op_server.c -o myserver<br></code></pre></td></tr></table></figure><p>结果：</p><p><img src="/.io//blog/blog/picture/5c3d966b81c03.png"></p><p>其实主要是对程序的一点点小改动，只需要再客户端固定好发送的格式，服务端按照固定格式解析，然后返回结果即可。</p><p>书上的实现：</p><ul><li><a href="https://github.com/riba2534/TCP-IP-NetworkNote/blob/master/ch05/op_client.c">op_client.c</a></li><li><a href="https://github.com/riba2534/TCP-IP-NetworkNote/blob/master/ch05/op_server.c">op_server.c</a></li></ul><p>阅读代码要注意一下，<code>int*</code>与<code>char</code>之间的转换。TCP 中不存在数据边界。</p><p>编译：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc op_client.c -o opclient<br>gcc op_server.c -o opserver<br></code></pre></td></tr></table></figure><p>运行:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">./opserver 9190<br>./opclient 127.0.0.1 9190<br></code></pre></td></tr></table></figure><p>结果：</p><p><img src="/.io//blog/blog/picture/5c3ea297c7649.png"></p><h3 id="5-2-TCP-原理"><a href="#5-2-TCP-原理" class="headerlink" title="5.2 TCP 原理"></a>5.2 TCP 原理</h3><h4 id="5-2-1-TCP-套接字中的-I-O-缓冲"><a href="#5-2-1-TCP-套接字中的-I-O-缓冲" class="headerlink" title="5.2.1 TCP 套接字中的 I&#x2F;O 缓冲"></a>5.2.1 TCP 套接字中的 I&#x2F;O 缓冲</h4><p>TCP 套接字的数据收发无边界。服务器即使调用 1 次 write 函数传输 40 字节的数据，客户端也有可能通过 4 次 read 函数调用每次读取 10 字节。但此处也有一些一问，服务器一次性传输了 40 字节，而客户端竟然可以缓慢的分批接受。客户端接受 10 字节后，剩下的 30 字节在何处等候呢？</p><p>实际上，write 函数调用后并非立即传输数据， read 函数调用后也并非马上接收数据。如图所示，write 函数调用瞬间，数据将移至输出缓冲；read 函数调用瞬间，从输入缓冲读取数据。</p><p><img src="/.io//blog/blog/picture/5c3ea41cd93c6.png"></p><p>I&#x2F;O 缓冲特性可以整理如下：</p><ul><li>I&#x2F;O 缓冲在每个 TCP 套接字中单独存在</li><li>I&#x2F;O 缓冲在创建套接字时自动生成</li><li>即使关闭套接字也会继续传递输出缓冲中遗留的数据</li><li>关闭套接字将丢失输入缓冲中的数据</li></ul><p>假设发生以下情况，会发生什么事呢？</p><blockquote><p>客户端输入缓冲为 50 字节，而服务器端传输了 100 字节。</p></blockquote><p>因为 TCP 不会发生超过输入缓冲大小的数据传输。也就是说，根本不会发生这类问题，因为 TCP 会控制数据流。TCP 中有滑动窗口（Sliding Window）协议，用对话方式如下：</p><blockquote><ul><li>A：你好，最多可以向我传递 50 字节</li><li>B：好的</li><li>A：我腾出了 20 字节的空间，最多可以接受 70 字节</li><li>B：好的</li></ul></blockquote><p>数据收发也是如此，因此 TCP 中不会因为缓冲溢出而丢失数据。</p><p><strong>write 函数在数据传输完成时返回。</strong></p><h4 id="5-2-2-TCP-内部工作原理-1：与对方套接字的连接"><a href="#5-2-2-TCP-内部工作原理-1：与对方套接字的连接" class="headerlink" title="5.2.2 TCP 内部工作原理 1：与对方套接字的连接"></a>5.2.2 TCP 内部工作原理 1：与对方套接字的连接</h4><p>TCP 套接字从创建到消失所经过的过程分为如下三步：</p><ul><li>与对方套接字建立连接</li><li>与对方套接字进行数据交换</li><li>断开与对方套接字的连接</li></ul><p>首先讲解与对方套接字建立连接的过程。连接过程中，套接字的对话如下：</p><ul><li>套接字A：你好，套接字 B。我这里有数据给你，建立连接吧</li><li>套接字B：好的，我这边已就绪</li><li>套接字A：谢谢你受理我的请求</li></ul><p>TCP 在实际通信中也会经过三次对话过程，因此，该过程又被称为 <strong>Three-way handshaking（三次握手）</strong>。接下来给出连接过程中实际交换的信息方式：</p><p><img src="/.io//blog/blog/picture/5c3ecdec9fc04.png"></p><p>套接字是全双工方式工作的。也就是说，它可以双向传递数据。因此，收发数据前要做一些准备。首先请求连接的主机 A 要给主机 B 传递以下信息：</p><blockquote><p>[SYN] SEQ : 1000 , ACK:-</p></blockquote><p>该消息中的 SEQ 为 1000 ，ACK 为空，而 SEQ 为1000 的含义如下：</p><blockquote><p>现在传递的数据包的序号为 1000，如果接收无误，请通知我向您传递 1001 号数据包。</p></blockquote><p>这是首次请求连接时使用的消息，又称为 SYN。SYN 是 Synchronization 的简写，表示收发数据前传输的同步消息。接下来主机 B 向 A 传递以下信息：</p><blockquote><p>[SYN+ACK] SEQ: 2000, ACK: 1001</p></blockquote><p>此时 SEQ 为 2000，ACK 为 1001，而 SEQ 为 2000 的含义如下：</p><blockquote><p>现传递的数据包号为 2000 ，如果接受无误，请通知我向您传递 2001 号数据包。</p></blockquote><p>而 ACK 1001 的含义如下：</p><blockquote><p>刚才传输的 SEQ 为 1000 的数据包接受无误，现在请传递 SEQ 为 1001 的数据包。</p></blockquote><p>对于主机 A 首次传输的数据包的确认消息（ACK 1001）和为主机 B 传输数据做准备的同步消息（SEQ 2000）捆绑发送。因此，此种类消息又称为 SYN+ACK。</p><p>收发数据前向数据包分配序号，并向对方通报此序号，这都是为了防止数据丢失做的准备。通过项数据包分配序号并确认，可以在数据包丢失时马上查看并重传丢失的数据包。因此 TCP 可以保证可靠的数据传输。</p><p>通过这三个过程，这样主机 A 和主机 B 就确认了彼此已经准备就绪。</p><h4 id="5-2-3-TCP-内部工作原理-2：与对方主机的数据交换"><a href="#5-2-3-TCP-内部工作原理-2：与对方主机的数据交换" class="headerlink" title="5.2.3 TCP 内部工作原理 2：与对方主机的数据交换"></a>5.2.3 TCP 内部工作原理 2：与对方主机的数据交换</h4><p>通过第一步三次握手过程完成了数据交换准备，下面就开始正式收发数据，其默认方式如图所示：</p><p><img src="/.io//blog/blog/picture/5c3ed1a97ce2b.png"></p><p>图上给出了主机 A 分成 2 个数据包向主机 B 传输 200 字节的过程。首先，主机 A 通过 1 个数据包发送 100 个字节的数据，数据包的 SEQ 为 1200 。主机 B 为了确认这一点，向主机 A 发送 ACK 1301 消息。</p><p>此时的 ACK 号为 1301 而不是 1201，原因在于 ACK 号的增量为传输的数据字节数。假设每次 ACK 号不加传输的字节数，这样虽然可以确认数据包的传输，但无法明确 100 个字节全都正确传递还是丢失了一部分，比如只传递了 80 字节。因此按照如下公式传递 ACK 信息：</p><blockquote><p>ACK 号 &#x3D; SEQ 号 + 传递的字节数 + 1</p></blockquote><p>与三次握手协议相同，最后 + 1 是为了告知对方下次要传递的 SEQ 号。下面分析传输过程中数据包丢失的情况：</p><p><img src="/.io//blog/blog/picture/5c3ed371187a6.png">‘</p><p>上图表示了通过 SEQ 1301 数据包向主机 B 传递 100 字节数据。但中间发生了错误，主机 B 未收到，经过一段时间后，主机 A 仍然未收到对于 SEQ 1301 的 ACK 的确认，因此试着重传该数据包。为了完成该数据包的重传，TCP 套接字启动计时器以等待 ACK 应答。若相应计时器发生超时（Time-out!）则重传。</p><h4 id="5-2-4-TCP-内部工作原理-3：断开套接字的连接"><a href="#5-2-4-TCP-内部工作原理-3：断开套接字的连接" class="headerlink" title="5.2.4 TCP 内部工作原理 3：断开套接字的连接"></a>5.2.4 TCP 内部工作原理 3：断开套接字的连接</h4><p>TCP 套接字的结束过程也非常优雅。如果对方还有数据需要传输时直接断掉该连接会出问题，所以断开连接时需要双方协商，断开连接时双方的对话如下：</p><blockquote><ul><li>套接字A：我希望断开连接</li><li>套接字B：哦，是吗？请稍后。</li><li>套接字A：我也准备就绪，可以断开连接。</li><li>套接字B：好的，谢谢合作。</li></ul></blockquote><p>先由套接字 A 向套接字 B 传递断开连接的信息，套接字 B 发出确认收到的消息，然后向套接字 A 传递可以断开连接的消息，套接字 A 同样发出确认消息。</p><p><img src="/.io//blog/blog/picture/5c3ed7503c18c.png"></p><p>图中数据包内的 FIN 表示断开连接。也就是说，双方各发送 1 次 FIN 消息后断开连接。此过过程经历 4 个阶段，因此又称四次握手（Four-way handshaking）。SEQ 和 ACK 的含义与之前讲解的内容一致，省略。图中，主机 A 传递了两次 ACK 5001，也许这里会有困惑。其实，第二次 FIN 数据包中的 ACK 5001 只是因为接收了 ACK 消息后未接收到的数据重传的。</p><h3 id="5-3-基于-Windows-的实现"><a href="#5-3-基于-Windows-的实现" class="headerlink" title="5.3 基于 Windows 的实现"></a>5.3 基于 Windows 的实现</h3><p>暂略</p><h3 id="5-4-习题"><a href="#5-4-习题" class="headerlink" title="5.4 习题"></a>5.4 习题</h3><blockquote><p>答案仅代表本人个人观点，可能不是正确答案。</p></blockquote><ol><li><p><strong>请说明 TCP 套接字连接设置的三次握手过程。尤其是 3 次数据交换过程每次收发的数据内容。</strong></p><p>答：三次握手主要分为：①A通知B有数据，希望建立链接②B回复A可以建立连接③A回应了解，并开始建立连接。每次收发的数据内容主要有：①由主机1给主机2发送初始的SEQ:1000，ACK:- (为空)，首次连接请求也成为SYN，表示收发数据前同步传输的消息。②主机2收到报文以后，给主机 1 传递信息，用一个新的SEQ:2000表示自己的序号，然后ACK:1001代表已经接受到主机1的消息，希望接受下一个消息。这种类型的消息又称为SYN+ACK③主机1收到主机2的确认以后，还需要给主机2给出确认，此时再发送一次SEQ:1001和ACK:2001。</p></li><li><p><strong>TCP 是可靠的数据传输协议，但在通过网络通信的过程中可能丢失数据。请通过 ACK 和 SEQ 说明 TCP 通过和何种机制保证丢失数据的可靠传输。</strong></p><p>答：通过超时重传机制来保证，如果报文发出去的特定时间内，发送消息的主机没有收到另一个主机的回复，那么就继续发送这条消息，直到收到回复为止。</p></li><li><p><strong>TCP 套接字中调用 write 和 read 函数时数据如何移动？结合 I&#x2F;O 缓冲进行说明。</strong></p><p>答：TCP 套接字调用 write 函数时，数据将移至输出缓冲，在适当的时候，传到对方输入缓冲。这时对方将调用 read 函数从输入缓冲中读取数据。</p></li><li><p><strong>对方主机的输入缓冲剩余 50 字节空间时，若本主机通过 write 函数请求传输 70 字节，请问 TCP 如何处理这种情况？</strong></p><p>答：TCP 中有滑动窗口控制协议，所以传输的时候会保证传输的字节数小于等于自己能接受的字节数。</p></li></ol><h2 id="第-6-章-基于-UDP-的服务端-客户端"><a href="#第-6-章-基于-UDP-的服务端-客户端" class="headerlink" title="第 6 章 基于 UDP 的服务端&#x2F;客户端"></a>第 6 章 基于 UDP 的服务端&#x2F;客户端</h2><p>本章代码，在<a href="https://github.com/riba2534/TCP-IP-NetworkNote">TCP-IP-NetworkNote</a>中可以找到。</p><p>TCP 是内容较多的一个协议，而本章中的 UDP 内容较少，但是也很重要。</p><h3 id="6-1-理解-UDP"><a href="#6-1-理解-UDP" class="headerlink" title="6.1 理解 UDP"></a>6.1 理解 UDP</h3><h4 id="6-1-1-UDP-套接字的特点"><a href="#6-1-1-UDP-套接字的特点" class="headerlink" title="6.1.1 UDP 套接字的特点"></a>6.1.1 UDP 套接字的特点</h4><p>通过寄信来说明 UDP 的工作原理，这是讲解 UDP 时使用的传统示例，它与 UDP 的特点完全相同。寄信前应现在信封上填好寄信人和收信人的地址，之后贴上邮票放进邮筒即可。当然，信件的特点使我们无法确认信件是否被收到。邮寄过程中也可能发生信件丢失的情况。也就是说，信件是一种不可靠的传输方式，UDP 也是一种不可靠的数据传输方式。</p><p>因为 UDP 没有 TCP 那么复杂，所以编程难度比较小，性能也比 TCP 高。在更重视性能的情况下可以选择 UDP 的传输方式。</p><p>TCP 与 UDP 的区别很大一部分来源于流控制。也就是说 TCP 的生命在于流控制。</p><h4 id="6-1-2-UDP-的工作原理"><a href="#6-1-2-UDP-的工作原理" class="headerlink" title="6.1.2 UDP 的工作原理"></a>6.1.2 UDP 的工作原理</h4><p>如图所示：</p><p><img src="/.io//blog/blog/picture/5c3fd29c70bf2.png"></p><p>从图中可以看出，IP 的作用就是让离开主机 B 的 UDP 数据包准确传递到主机 A 。但是把 UDP 数据包最终交给主机 A 的某一 UDP 套接字的过程是由 UDP 完成的。UDP 的最重要的作用就是根据端口号将传到主机的数据包交付给最终的 UDP 套接字。</p><h4 id="6-1-3-UDP-的高效使用"><a href="#6-1-3-UDP-的高效使用" class="headerlink" title="6.1.3 UDP 的高效使用"></a>6.1.3 UDP 的高效使用</h4><p>UDP 也具有一定的可靠性。对于通过网络实时传递的视频或者音频时情况有所不同。对于多媒体数据而言，丢失一部分数据也没有太大问题，这只是会暂时引起画面抖动，或者出现细微的杂音。但是要提供实时服务，速度就成为了一个很重要的因素。因此流控制就显得有一点多余，这时就要考虑使用 UDP 。TCP 比 UDP 慢的原因主要有以下两点：</p><ul><li>收发数据前后进行的连接设置及清楚过程。</li><li>收发过程中为保证可靠性而添加的流控制。</li></ul><p>如果收发的数据量小但是需要频繁连接时，UDP 比 TCP 更高效。</p><h3 id="6-2-实现基于-UDP-的服务端-客户端"><a href="#6-2-实现基于-UDP-的服务端-客户端" class="headerlink" title="6.2 实现基于 UDP 的服务端&#x2F;客户端"></a>6.2 实现基于 UDP 的服务端&#x2F;客户端</h3><h4 id="6-2-1-UDP-中的服务端和客户端没有连接"><a href="#6-2-1-UDP-中的服务端和客户端没有连接" class="headerlink" title="6.2.1 UDP 中的服务端和客户端没有连接"></a>6.2.1 UDP 中的服务端和客户端没有连接</h4><p>UDP 中的服务端和客户端不像 TCP 那样在连接状态下交换数据，因此与 TCP 不同，无需经过连接过程。也就是说，不必调用 TCP 连接过程中调用的 listen 和 accept 函数。UDP 中只有创建套接字和数据交换的过程。</p><h4 id="6-2-2-UDP-服务器和客户端均只需一个套接字"><a href="#6-2-2-UDP-服务器和客户端均只需一个套接字" class="headerlink" title="6.2.2 UDP 服务器和客户端均只需一个套接字"></a>6.2.2 UDP 服务器和客户端均只需一个套接字</h4><p>TCP 中，套接字之间应该是一对一的关系。若要向 10 个客户端提供服务，除了守门的服务器套接字之外，还需要 10 个服务器套接字。但在 UDP 中，不管事服务器端还是客户端都只需要 1 个套接字。只需要一个 UDP 套接字就可以向任意主机传输数据，如图所示：</p><p><img src="/.io//blog/blog/picture/5c3fd703f3c40.png"></p><p>图中展示了 1 个 UDP 套接字与 2 个不同主机交换数据的过程。也就是说，只需 1 个 UDP 套接字就能和多台主机进行通信。</p><h4 id="6-2-3-基于-UDP-的数据-I-O-函数"><a href="#6-2-3-基于-UDP-的数据-I-O-函数" class="headerlink" title="6.2.3 基于 UDP 的数据 I&#x2F;O 函数"></a>6.2.3 基于 UDP 的数据 I&#x2F;O 函数</h4><p>创建好 TCP 套接字以后，传输数据时无需加上地址信息。因为 TCP 套接字将保持与对方套接字的连接。换言之，TCP 套接字知道目标地址信息。但 UDP 套接字不会保持连接状态（UDP 套接字只有简单的邮筒功能），因此每次传输数据时都需要添加目标的地址信息。这相当于寄信前在信件中填写地址。接下来是 UDP 的相关函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">sendto</span><span class="hljs-params">(<span class="hljs-type">int</span> sock, <span class="hljs-type">void</span> *buff, <span class="hljs-type">size_t</span> nbytes, <span class="hljs-type">int</span> flags,</span><br><span class="hljs-params">               <span class="hljs-keyword">struct</span> sockaddr *to, <span class="hljs-type">socklen_t</span> addrlen)</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">成功时返回传输的字节数，失败是返回 -1</span><br><span class="hljs-comment">sock: 用于传输数据的 UDP 套接字</span><br><span class="hljs-comment">buff: 保存待传输数据的缓冲地址值</span><br><span class="hljs-comment">nbytes: 待传输的数据长度，以字节为单位</span><br><span class="hljs-comment">flags: 可选项参数，若没有则传递 0</span><br><span class="hljs-comment">to: 存有目标地址的 sockaddr 结构体变量的地址值</span><br><span class="hljs-comment">addrlen: 传递给参数 to 的地址值结构体变量长度</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>上述函数与之前的 TCP 输出函数最大的区别在于，此函数需要向它传递目标地址信息。接下来介绍接收 UDP 数据的函数。UDP 数据的发送并不固定，因此该函数定义为可接受发送端信息的形式，也就是将同时返回 UDP 数据包中的发送端信息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">recvfrom</span><span class="hljs-params">(<span class="hljs-type">int</span> sock, <span class="hljs-type">void</span> *buff, <span class="hljs-type">size_t</span> nbytes, <span class="hljs-type">int</span> flags,</span><br><span class="hljs-params">                 <span class="hljs-keyword">struct</span> sockaddr *from, <span class="hljs-type">socklen_t</span> *addrlen)</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">成功时返回传输的字节数，失败是返回 -1</span><br><span class="hljs-comment">sock: 用于接收数据的UDP套接字文件描述符</span><br><span class="hljs-comment">buff: 保存接收数据的缓冲地址值</span><br><span class="hljs-comment">nbytes: 可接收的最大字节数，故无法超过参数buff所指的缓冲大小</span><br><span class="hljs-comment">flags: 可选项参数，若没有则传递 0</span><br><span class="hljs-comment">from: 存有发送端地址信息的 sockaddr 结构体变量的地址值</span><br><span class="hljs-comment">addrlen: 保存参数 from 的结构体变量长度的变量地址值。</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>编写 UDP 程序的最核心的部分就在于上述两个函数，这也说明二者在 UDP 数据传输中的地位。</p><h4 id="6-2-4-基于-UDP-的回声服务器端-客户端"><a href="#6-2-4-基于-UDP-的回声服务器端-客户端" class="headerlink" title="6.2.4 基于 UDP 的回声服务器端&#x2F;客户端"></a>6.2.4 基于 UDP 的回声服务器端&#x2F;客户端</h4><p>下面是实现的基于 UDP 的回声服务器的服务器端和客户端：</p><p>代码：</p><ul><li><a href="https://github.com/riba2534/TCP-IP-NetworkNote/blob/master/ch06/uecho_client.c">uecho_client.c</a></li><li><a href="https://github.com/riba2534/TCP-IP-NetworkNote/blob/master/ch06/uecho_server.c">uecho_server.c</a></li></ul><p>编译运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc uecho_client.c -o uclient<br>gcc uecho_server.c -o userver<br>./server 9190<br>./uclient 127.0.0.1 9190<br></code></pre></td></tr></table></figure><p>结果：</p><p><img src="/.io//blog/blog/picture/5c3feb85baa83.png"></p><p>TCP 客户端套接字在调用 connect 函数时自动分配IP地址和端口号，既然如此，UDP 客户端何时分配IP地址和端口号？</p><h4 id="6-2-5-UDP-客户端套接字的地址分配"><a href="#6-2-5-UDP-客户端套接字的地址分配" class="headerlink" title="6.2.5 UDP 客户端套接字的地址分配"></a>6.2.5 UDP 客户端套接字的地址分配</h4><p>仔细观察 UDP 客户端可以发现，UDP 客户端缺少了把IP和端口分配给套接字的过程。TCP 客户端调用 connect 函数自动完成此过程，而 UDP 中连接能承担相同功能的函数调用语句都没有。究竟在什么时候分配IP和端口号呢？</p><p>UDP 程序中，调用 sendto 函数传输数据前应该完成对套接字的地址分配工作，因此调用 bind 函数。当然，bind 函数在 TCP 程序中出现过，但 bind 函数不区分 TCP 和 UDP，也就是说，在 UDP 程序中同样可以调用。另外，如果调用 sendto 函数尚未分配地址信息，则在首次调用 sendto 函数时给相应套接字自动分配 IP 和端口。而且此时分配的地址一直保留到程序结束为止，因此也可以用来和其他 UDP 套接字进行数据交换。当然，IP 用主机IP，端口号用未选用的任意端口号。</p><p>综上所述，调用 sendto 函数时自动分配IP和端口号，因此，UDP 客户端中通常无需额外的地址分配过程。所以之前的示例中省略了该过程。这也是普遍的实现方式。</p><h3 id="6-3-UDP-的数据传输特性和调用-connect-函数"><a href="#6-3-UDP-的数据传输特性和调用-connect-函数" class="headerlink" title="6.3 UDP 的数据传输特性和调用 connect 函数"></a>6.3 UDP 的数据传输特性和调用 connect 函数</h3><h4 id="6-3-1-存在数据边界的-UDP-套接字"><a href="#6-3-1-存在数据边界的-UDP-套接字" class="headerlink" title="6.3.1 存在数据边界的 UDP 套接字"></a>6.3.1 存在数据边界的 UDP 套接字</h4><p>前面说得 TCP 数据传输中不存在数据边界，这表示「数据传输过程中调用 I&#x2F;O 函数的次数不具有任何意义」</p><p>相反，UDP 是具有数据边界的协议，传输中调用 I&#x2F;O 函数的次数非常重要。因此，输入函数的调用次数和输出函数的调用次数完全一致，这样才能保证接收全部已经发送的数据。例如，调用 3 次输出函数发送的数据必须通过调用 3 次输入函数才能接收完。通过一个例子来进行验证：</p><ul><li><a href="https://github.com/riba2534/TCP-IP-NetworkNote/blob/master/ch06/bound_host1.c">bound_host1.c</a></li><li><a href="https://github.com/riba2534/TCP-IP-NetworkNote/blob/master/ch06/bound_host2.c">bound_host2.c</a></li></ul><p>编译运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc bound_host1.c -o host1<br>gcc bound_host2.c -o host2<br>./host1 9190<br>./host2 127.0.0.1 9190<br></code></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/.io//blog/blog/picture/5c3ff966a8d34.png"></p><p>host1 是服务端，host2 是客户端，host2 一次性把数据发给服务端后，结束程序。此时数据已经在服务端了。UDP I&#x2F;O 调用次数必须一致，所以服务器端也需要调用三次。但是因为服务端每隔五秒才接收一次，所以服务端每隔五秒输出一条消息。</p><p><strong>从运行结果也可以证明 UDP 通信过程中 I&#x2F;O 的调用次数必须保持一致</strong></p><h4 id="6-3-2-已连接（connect）UDP-套接字与未连接（unconnected）UDP-套接字"><a href="#6-3-2-已连接（connect）UDP-套接字与未连接（unconnected）UDP-套接字" class="headerlink" title="6.3.2 已连接（connect）UDP 套接字与未连接（unconnected）UDP 套接字"></a>6.3.2 已连接（connect）UDP 套接字与未连接（unconnected）UDP 套接字</h4><p>TCP 套接字中需注册待传传输数据的目标IP和端口号，而在 UDP 中无需注册。因此通过 sendto 函数传输数据的过程大概可以分为以下 3 个阶段：</p><ul><li>第 1 阶段：向 UDP 套接字注册目标 IP 和端口号</li><li>第 2 阶段：传输数据</li><li>第 3 阶段：删除 UDP 套接字中注册的目标地址信息。</li></ul><p>每次调用 sendto 函数时重复上述过程。每次都变更目标地址，因此可以重复利用同一 UDP 套接字向不同目标传递数据。这种未注册目标地址信息的套接字称为未连接套接字，反之，注册了目标地址的套接字称为连接 connected 套接字。显然，UDP 套接字默认属于未连接套接字。当一台主机向另一台主机传输很多信息时，上述的三个阶段中，第一个阶段和第三个阶段占整个通信过程中近三分之一的时间，缩短这部分的时间将会大大提高整体性能。</p><h4 id="6-3-3-创建已连接-UDP-套接字"><a href="#6-3-3-创建已连接-UDP-套接字" class="headerlink" title="6.3.3 创建已连接 UDP 套接字"></a>6.3.3 创建已连接 UDP 套接字</h4><p>创建已连接 UDP 套接字过程格外简单，只需针对 UDP 套接字调用 connect 函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">sock = socket(PF_INET, SOCK_DGRAM, <span class="hljs-number">0</span>);<br><span class="hljs-built_in">memset</span>(&amp;adr, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(adr));<br>adr.sin_family = AF_INET;<br>adr.sin_addr.s_addr = inet_addr(argv[<span class="hljs-number">1</span>]);<br>adr.sin_port = htons(atoi(argv[<span class="hljs-number">2</span>]));<br>connect(sock, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;adr, <span class="hljs-keyword">sizeof</span>(adr));<br></code></pre></td></tr></table></figure><p>上述代码看似与 TCP 套接字创建过程一致，但 socket 函数的第二个参数分明是 SOCK_DGRAM 。也就是说，创建的的确是 UDP 套接字。当然针对 UDP 调用 connect 函数并不是意味着要与对方 UDP 套接字连接，这只是向 UDP 套接字注册目标IP和端口信息。</p><p>之后就与 TCP 套接字一致，每次调用 sendto 函数时只需传递信息数据。因为已经指定了收发对象，所以不仅可以使用 sendto、recvfrom 函数，还可以使用 write、read 函数进行通信。</p><p>下面的例子把之前的 <a href="https://github.com/riba2534/TCP-IP-NetworkNote/blob/master/ch06/uecho_client.c">uecho_client.c</a> 程序改成了基于已连接 UDP 的套接字的程序，因此可以结合 <a href="https://github.com/riba2534/TCP-IP-NetworkNote/blob/master/ch06/uecho_server.c">uecho_server.c</a> 程序运行。代码如下：</p><ul><li><a href="https://github.com/riba2534/TCP-IP-NetworkNote/blob/master/ch06/uecho_con_client.c">uecho_con_client.c</a></li></ul><p>编译运行过程与上面一样，故省略。</p><p>上面的代码中用 write、read 函数代替了 sendto、recvfrom 函数。</p><h3 id="6-4-基于-Windows-的实现"><a href="#6-4-基于-Windows-的实现" class="headerlink" title="6.4 基于 Windows 的实现"></a>6.4 基于 Windows 的实现</h3><p>暂略</p><h3 id="6-5-习题"><a href="#6-5-习题" class="headerlink" title="6.5 习题"></a>6.5 习题</h3><blockquote><p>以下答案仅代表本人个人观点，可能不是正确答案。</p></blockquote><ol><li><p><strong>UDP 为什么比 TCP 快？为什么 TCP 传输可靠而 TCP 传输不可靠？</strong></p><p>答：为了提供可靠的数据传输服务，TCP 在不可靠的IP层进行流控制，而 UDP 缺少这种流控制。所以 UDP 是不可靠的连接。</p></li><li><p><strong>下面不属于 UDP 特点的是？</strong></p><p>下面加粗的代表此句话正确</p><ol><li><strong>UDP 不同于 TCP ，不存在连接概念，所以不像 TCP 那样只能进行一对一的数据传输。</strong></li><li>利用 UDP 传输数据时，如果有 2 个目标，则需要 2 个套接字。</li><li>UDP 套接字中无法使用已分配给 TCP 的同一端口号</li><li><strong>UDP 套接字和 TCP 套接字可以共存。若需要，可以同时在同一主机进行 TCP 和 UDP 数据传输。</strong></li><li>针对 UDP 函数也可以调用 connect 函数，此时 UDP 套接字跟 TCP 套接字相同，也需要经过 3 次握手阶段。</li></ol></li><li><p><strong>UDP 数据报向对方主机的 UDP 套接字传递过程中，IP 和 UDP 分别负责哪些部分？</strong></p><p>答：IP的作用就是让离开主机的 UDP 数据包准确传递到另一个主机。但把 UDP 包最终交给主机的某一 UDP 套接字的过程则是由 UDP 完成的。UDP 的最重要的作用就是根据端口号将传到主机的数据包交付给最终的 UDP 套接字。</p></li><li><p><strong>UDP 一般比 TCP 快，但根据交换数据的特点，其差异可大可小。请你说明何种情况下 UDP 的性能优于 TCP？</strong></p><p>答：如果收发数据量小但需要频繁连接时，UDP 比 TCP 更高效。</p></li><li><p><strong>客户端 TCP 套接字调用 connect 函数时自动分配IP和端口号。UDP 中不调用 bind 函数，那何时分配IP和端口号？</strong></p><p>答：在首次调用 sendto 函数时自动给相应的套接字分配IP和端口号。而且此时分配的地址一直保留到程序结束为止。</p></li><li><p><strong>TCP 客户端必须调用 connect 函数，而 UDP 可以选择性调用。请问，在 UDP 中调用 connect 函数有哪些好处？</strong> </p><p>答：要与同一个主机进行长时间通信时，将 UDP 套接字变成已连接套接字会提高效率。因为三个阶段中，第一个阶段和第三个阶段占用了一大部分时间，调用 connect 函数可以节省这些时间。</p></li></ol><h2 id="第-7-章-优雅的断开套接字的连接"><a href="#第-7-章-优雅的断开套接字的连接" class="headerlink" title="第 7 章 优雅的断开套接字的连接"></a>第 7 章 优雅的断开套接字的连接</h2><p>本章代码，在<a href="https://github.com/riba2534/TCP-IP-NetworkNote">TCP-IP-NetworkNote</a>中可以找到。</p><p>本章讨论如何优雅的断开套接字的连接，之前用的方法不够优雅是因为，我们是调用 close 函数或 closesocket 函数单方面断开连接的。</p><h3 id="7-1-基于-TCP-的半关闭"><a href="#7-1-基于-TCP-的半关闭" class="headerlink" title="7.1 基于 TCP 的半关闭"></a>7.1 基于 TCP 的半关闭</h3><p>TCP 的断开连接过程比建立连接更重要，因为连接过程中一般不会出现大问题，但是断开过程可能发生预想不到的情况。因此应该准确掌控。所以要<strong>掌握半关闭（Half-close）</strong>，才能明确断开过程。</p><h4 id="7-1-1-单方面断开连接带来的问题"><a href="#7-1-1-单方面断开连接带来的问题" class="headerlink" title="7.1.1 单方面断开连接带来的问题"></a>7.1.1 单方面断开连接带来的问题</h4><p>Linux 和 Windows 的 closesocket 函数意味着完全断开连接。完全断开不仅指无法传输数据，而且也不能接收数据。因此在某些情况下，通信一方单方面的断开套接字连接，显得不太优雅。如图所示：</p><p><img src="/.io//blog/blog/picture/5c412a8baa2d8.png"></p><p>图中描述的是 2 台主机正在进行双向通信，主机 A 发送完最后的数据后，调用 close 函数断开了最后的连接，之后主机 A 无法再接受主机 B 传输的数据。实际上，是完全无法调用与接受数据相关的函数。最终，由主机 B 传输的、主机 A 必须要接受的数据也销毁了。</p><p>为了解决这类问题，「只关闭一部分数据交换中使用的流」的方法应运而生。断开一部分连接是指，可以传输数据但是无法接收，或可以接受数据但无法传输。顾名思义就是只关闭流的一半。</p><h4 id="7-1-2-套接字和流（Stream）"><a href="#7-1-2-套接字和流（Stream）" class="headerlink" title="7.1.2 套接字和流（Stream）"></a>7.1.2 套接字和流（Stream）</h4><p>两台主机通过套接字建立连接后进入可交换数据的状态，又称「流形成的状态」。也就是把建立套接字后可交换数据的状态看作一种流。</p><p>此处的流可以比作水流。水朝着一个方向流动，同样，在套接字的流中，数据也只能向一个方向流动。因此，为了进行双向通信，需要如图所示的两个流：</p><p><img src="/.io//blog/blog/picture/5c412c3ba25dd.png"></p><p>一旦两台主机之间建立了套接字连接，每个主机就会拥有单独的输入流和输出流。当然，其中一个主机的输入流与另一个主机的输出流相连，而输出流则与另一个主机的输入流相连。另外，本章讨论的「优雅的断开连接方式」只断开其中 1 个流，而非同时断开两个流。Linux 和 Windows 的 closesocket 函数将同时断开这两个流，因此与「优雅」二字还有一段距离。</p><h4 id="7-1-3-针对优雅断开的-shutdown-函数"><a href="#7-1-3-针对优雅断开的-shutdown-函数" class="headerlink" title="7.1.3 针对优雅断开的 shutdown 函数"></a>7.1.3 针对优雅断开的 shutdown 函数</h4><p>shutdown 用来关闭其中一个流：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">shutdown</span><span class="hljs-params">(<span class="hljs-type">int</span> sock, <span class="hljs-type">int</span> howto)</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">成功时返回 0 ，失败时返回 -1</span><br><span class="hljs-comment">sock: 需要断开套接字文件描述符</span><br><span class="hljs-comment">howto: 传递断开方式信息</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>调用上述函数时，第二个参数决定断开连接的方式，其值如下所示：</p><ul><li><code>SHUT_RD</code> : 断开输入流</li><li><code>SHUT_WR</code> : 断开输出流</li><li><code>SHUT_RDWR</code> : 同时断开 I&#x2F;O 流</li></ul><p>若向 shutdown 的第二个参数传递<code>SHUT_RD</code>，则断开输入流，套接字无法接收数据。即使输入缓冲收到数据也回抹去，而且无法调用相关函数。如果向  shutdown 的第二个参数传递<code>SHUT_WR</code>，则中断输出流，也就无法传输数据。若如果输出缓冲中还有未传输的数据，则将传递给目标主机。最后，若传递关键字<code>SHUT_RDWR</code>，则同时中断 I&#x2F;O 流。这相当于分 2 次调用 shutdown ，其中一次以<code>SHUT_RD</code>为参数，另一次以<code>SHUT_WR</code>为参数。</p><h4 id="7-1-4-为何要半关闭"><a href="#7-1-4-为何要半关闭" class="headerlink" title="7.1.4 为何要半关闭"></a>7.1.4 为何要半关闭</h4><p>考虑以下情况：</p><blockquote><p>一旦客户端连接到服务器，服务器将约定的文件传输给客户端，客户端收到后发送字符串「Thank you」给服务器端。</p></blockquote><p>此处「Thank you」的传递是多余的，这只是用来模拟客户端断开连接前还有数据要传输的情况。此时程序的实现难度并不小，因为传输文件的服务器端只需连续传输文件数据即可，而客户端无法知道需要接收数据到何时。客户端也没办法无休止的调用输入函数，因为这有可能导致程序<strong>阻塞</strong>。</p><blockquote><p>是否可以让服务器和客户端约定一个代表文件尾的字符？</p></blockquote><p>这种方式也有问题，因为这意味这文件中不能有与约定字符相同的内容。为了解决该问题，服务端应最后向客户端传递 EOF 表示文件传输结束。客户端通过函数返回值接受 EOF ，这样可以避免与文件内容冲突。那么问题来了，服务端如何传递 EOF ？</p><blockquote><p>断开输出流时向主机传输 EOF。</p></blockquote><p>当然，调用 close 函数的同时关闭 I&#x2F;O 流，这样也会向对方发送 EOF 。但此时无法再接受对方传输的数据。换言之，若调用 close 函数关闭流，就无法接受客户端最后发送的字符串「Thank you」。这时需要调用 shutdown 函数，只关闭服务器的输出流。这样既可以发送 EOF ，同时又保留了输入流。下面实现收发文件的服务器端&#x2F;客户端。</p><h4 id="7-1-5-基于半关闭的文件传输程序"><a href="#7-1-5-基于半关闭的文件传输程序" class="headerlink" title="7.1.5 基于半关闭的文件传输程序"></a>7.1.5 基于半关闭的文件传输程序</h4><p>上述文件传输服务器端和客户端的数据流可以整理如图：</p><p><img src="/.io//blog/blog/picture/5c41326280ab5.png"></p><p>下面的代码为编程简便，省略了大量错误处理代码。</p><ul><li><a href="https://github.com/riba2534/TCP-IP-NetworkNote/blob/master/ch07/file_client.c">file_client.c</a></li><li><a href="https://github.com/riba2534/TCP-IP-NetworkNote/blob/master/ch07/file_server.c">file_server.c</a></li></ul><p>编译运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc file_client.c -o fclient<br>gcc file_server.c -o fserver<br>./fserver 9190<br>./fclient 127.0.0.1 9190<br></code></pre></td></tr></table></figure><p>结果：</p><p><img src="/.io//blog/blog/picture/5c4140bc8db2f.png"></p><p>客户端接受完成后，服务器会接收到来自客户端的感谢信息。</p><h3 id="7-2-基于-Windows-的实现"><a href="#7-2-基于-Windows-的实现" class="headerlink" title="7.2 基于 Windows 的实现"></a>7.2 基于 Windows 的实现</h3><p>暂略</p><h3 id="7-3-习题"><a href="#7-3-习题" class="headerlink" title="7.3 习题"></a>7.3 习题</h3><blockquote><p>以下答案仅代表本人个人观点，可能不是正确答案</p></blockquote><ol><li><p><strong>解释 TCP 中「流」的概念。UDP 中能否形成流？请说明原因。</strong></p><p>答：两台主机中通过套接字建立连接后进入可交换数据的状态，又称「流形成的状态」。也就是把建立套接字后可交换数据的状态看做一种流。UDP 没有建立连接的过程，所以不能形成流。</p></li><li><p><strong>Linux 中的 close 函数或 Windows 中的 closesocket 函数属于单方面断开连接的方法，有可能带来一些问题。什么是单方面断开连接？什么情形下会出现问题？</strong></p><p>答：单方面断开连接就是两台主机正在通信，其中一台主机关闭了所有连接，那么一台主机向另一台主机传输的数据可能会没有接收到而损毁。传输文件的服务器只需连续传输文件数据即可，而客户端不知道需要接收数据到何时。客户端也没有办法无休止的调用输入函数。现在需要一个 EOF 代表数据已经传输完毕，那么这时就需要半关闭，服务端把自己的输出流关了，这时客户端就知数据已经传输完毕，因为服务端的输入流还没关，客户端可以给服务器汇报，接收完毕。</p></li><li><p><strong>什么是半关闭？针对输出流执行半关闭的主机处于何种状态？半关闭会导致对方主机接收什么消息？</strong></p><p>答：半关闭就是把输入流或者输出流关了。针对输出流执行半关闭的主机处于可以接收数据而不能发送数据。半关闭会导致对方主机接收一个 EOF 文件结束符。对方就知道你的数据已经传输完毕。</p></li></ol><h2 id="第-8-章-域名及网络地址"><a href="#第-8-章-域名及网络地址" class="headerlink" title="第 8 章 域名及网络地址"></a>第 8 章 域名及网络地址</h2><p>本章代码，在<a href="https://github.com/riba2534/TCP-IP-NetworkNote">TCP-IP-NetworkNote</a>中可以找到。</p><h3 id="8-1-域名系统"><a href="#8-1-域名系统" class="headerlink" title="8.1 域名系统"></a>8.1 域名系统</h3><p>DNS 是对IP地址和域名进行相互转换的系统，其核心是 DNS 服务器</p><h4 id="8-1-1-什么是域名"><a href="#8-1-1-什么是域名" class="headerlink" title="8.1.1 什么是域名"></a>8.1.1 什么是域名</h4><p>域名就是我们常常在地址栏里面输入的地址，将比较难记忆的IP地址变成人类容易理解的信息。</p><h4 id="8-1-2-DNS-服务器"><a href="#8-1-2-DNS-服务器" class="headerlink" title="8.1.2 DNS 服务器"></a>8.1.2 DNS 服务器</h4><p>相当于一个字典，可以查询出某一个域名对应的IP地址</p><p><img src="/.io//blog/blog/picture/5c41854859ae3.png"></p><p>如图所示，显示了 DNS 服务器的查询路径。</p><h3 id="8-2-IP地址和域名之间的转换"><a href="#8-2-IP地址和域名之间的转换" class="headerlink" title="8.2 IP地址和域名之间的转换"></a>8.2 IP地址和域名之间的转换</h3><h4 id="8-2-1-程序中有必要使用域名吗？"><a href="#8-2-1-程序中有必要使用域名吗？" class="headerlink" title="8.2.1 程序中有必要使用域名吗？"></a>8.2.1 程序中有必要使用域名吗？</h4><p>一句话，需要，因为IP地址可能经常改变，而且也不容易记忆，通过域名可以随时更改解析，达到更换IP的目的</p><h4 id="8-2-2-利用域名获取IP地址"><a href="#8-2-2-利用域名获取IP地址" class="headerlink" title="8.2.2 利用域名获取IP地址"></a>8.2.2 利用域名获取IP地址</h4><p>使用以下函数可以通过传递字符串格式的域名获取IP地址</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netdb.h&gt;</span></span><br><span class="hljs-keyword">struct</span> hostent *<span class="hljs-title function_">gethostbyname</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *hostname)</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">成功时返回 hostent 结构体地址，失败时返回 NULL 指针</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>这个函数使用方便，只要传递字符串，就可以返回域名对应的IP地址。只是返回时，地址信息装入 hostent 结构体。此结构体的定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hostent</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">char</span> *h_name;       <span class="hljs-comment">/* Official name of host.  */</span><br>    <span class="hljs-type">char</span> **h_aliases;   <span class="hljs-comment">/* Alias list.  */</span><br>    <span class="hljs-type">int</span> h_addrtype;     <span class="hljs-comment">/* Host address type.  */</span><br>    <span class="hljs-type">int</span> h_length;       <span class="hljs-comment">/* Length of address.  */</span><br>    <span class="hljs-type">char</span> **h_addr_list; <span class="hljs-comment">/* List of addresses from name server.  */</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>从上述结构体可以看出，不止返回IP信息，同时还带着其他信息一起返回。域名转换成IP时只需要关注 h_addr_list 。下面简要说明上述结构体的成员：</p><ul><li>h_name：该变量中存有官方域名（Official domain name）。官方域名代表某一主页，但实际上，一些著名公司的域名并没有用官方域名注册。</li><li>h_aliases：可以通过多个域名访问同一主页。同一IP可以绑定多个域名，因此，除官方域名外还可以指定其他域名。这些信息可以通过 h_aliases 获得。</li><li>h_addrtype：gethostbyname 函数不仅支持 IPV4 还支持 IPV6 。因此可以通过此变量获取保存在 h_addr_list 的IP地址族信息。若是 IPV4 ，则此变量中存有 AF_INET。</li><li>h_length：保存IP地址长度。若是 IPV4 地址，因为是 4 个字节，则保存4；IPV6 时，因为是 16 个字节，故保存 16</li><li>h_addr_list：这个是最重要的的成员。通过此变量以整数形式保存域名相对应的IP地址。另外，用户比较多的网站有可能分配多个IP地址给同一个域名，利用多个服务器做负载均衡，。此时可以通过此变量获取IP地址信息。</li></ul><p>调用 gethostbyname 函数后，返回的结构体变量如图所示：</p><p><img src="/.io//blog/blog/picture/5c41898ae45e8.png"></p><p>下面的代码通过一个例子来演示 gethostbyname 的应用，并说明 hostent 结构体变量特性。</p><ul><li><a href="https://github.com/riba2534/TCP-IP-NetworkNote/blob/master/ch08/gethostbyname.c">gethostbyname.c</a></li></ul><p>编译运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc gethostbyname.c -o hostname<br>./hostname www.baidu.com<br></code></pre></td></tr></table></figure><p>结果：</p><p><img src="/.io//blog/blog/picture/5c418faf20495.png"></p><p>如图所示，显示出了对百度的域名解析</p><p>可以看出，百度有一个域名解析是 CNAME 解析的，指向了<code>shifen.com</code>，关于百度具体的解析过程。</p><blockquote><p>这一部分牵扯到了很多关于DNS解析的过程，还有 Linux 下关于域名解析的一些命令，我找了一部分资料，可以点下面的链接查看比较详细的：</p><ul><li><a href="http://zhan.renren.com/starshen?gid=3602888498023142484&checked=true">关于百度DNS的解析过程</a></li><li><a href="https://www.zhihu.com/question/23042131/answer/66571369">DNS解析的过程是什么，求详细的？</a></li><li><a href="https://zhuanlan.zhihu.com/p/45535596">Linux DNS 查询剖析</a></li><li><a href="http://www.live-in.org/archives/1938.html">Linux DNS查询命令</a></li><li><a href="https://blog.csdn.net/shangdi1988/article/details/65713077">Linux中DNS服务器地址查询命令nslookup使用教程</a></li><li><a href="http://www.ruanyifeng.com/blog/2016/06/dns.html">DNS 原理入门</a></li></ul></blockquote><p>仔细阅读这一段代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">inet_ntoa(*(<span class="hljs-keyword">struct</span> in_addr *)host-&gt;h_addr_list[i])<br></code></pre></td></tr></table></figure><p>若只看 hostent 的定义，结构体成员 h_addr_list 指向字符串指针数组（由多个字符串地址构成的数组）。但是字符串指针数组保存的元素实际指向的是 in_addr 结构体变量的地址值而非字符串，也就是说<code>(struct in_addr *)host-&gt;h_addr_list[i]</code>其实是一个指针，然后用<code>*</code>符号取具体的值。如图所示：</p><p><img src="/.io//blog/blog/picture/5c419658a73b8.png"></p><blockquote><p><strong>为什么是「cha*」而不是「in_addr*」</strong><br>「hostent」结构体的成员「h_addr_st」指向的数组类型并不是「in_addr」结构体的指针数组,而是用了「char」指针。「hostent」结构体并非只为IPV4准备。「h_addr_list」指向的数组中也可以保存Pv6地址信息。考虑到通用性,声明为「char」指针类型的数组<br><strong>声明为「void」指针类型是否更合理?</strong><br>当然如此。指针对象不明确时,更适合使用vod指针类型。此处不用是版本问题</p></blockquote><h4 id="8-2-3-利用IP地址获取域名"><a href="#8-2-3-利用IP地址获取域名" class="headerlink" title="8.2.3 利用IP地址获取域名"></a>8.2.3 利用IP地址获取域名</h4><p>请看下面的函数定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netdb.h&gt;</span></span><br><span class="hljs-keyword">struct</span> hostent *<span class="hljs-title function_">gethostbyaddr</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *addr, <span class="hljs-type">socklen_t</span> len, <span class="hljs-type">int</span> family)</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">成功时返回 hostent 结构体变量地址值，失败时返回 NULL 指针</span><br><span class="hljs-comment">addr: 含有IP地址信息的 in_addr 结构体指针。为了同时传递 IPV4 地址之外的全部信息，该变量的类型声明为 char 指针</span><br><span class="hljs-comment">len: 向第一个参数传递的地址信息的字节数，IPV4时为 4 ，IPV6 时为16.</span><br><span class="hljs-comment">family: 传递地址族信息，ipv4 是 AF_INET ，IPV6是 AF_INET6</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>下面的代码演示使用方法：</p><ul><li><a href="https://github.com/riba2534/TCP-IP-NetworkNote/blob/master/ch08/gethostbyaddr.c">gethostbyaddr.c</a></li></ul><p>编译运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc gethostbyaddr.c -o hostaddr<br>./hostaddr 8.8.8.8<br></code></pre></td></tr></table></figure><p>结果：</p><p><img src="/.io//blog/blog/picture/5c41a019085d4.png"></p><p>从图上可以看出，<code>8.8.8.8</code>这个IP地址是谷歌的。</p><h3 id="8-3-基于-Windows-的实现"><a href="#8-3-基于-Windows-的实现" class="headerlink" title="8.3 基于 Windows 的实现"></a>8.3 基于 Windows 的实现</h3><p>暂略</p><h3 id="8-4-习题"><a href="#8-4-习题" class="headerlink" title="8.4 习题"></a>8.4 习题</h3><blockquote><p>以下答案仅代表本人个人观点，可能不是正确答案。</p></blockquote><ol><li><p><strong>下列关于DNS的说法错误的是？</strong></p><p>答：字体加粗的表示正确答案。</p><ol><li><strong>因为DNS存在，故可以使用域名代替IP</strong></li><li>DNS服务器实际上是路由器，因为路由器根据域名决定数据的路径</li><li><strong>所有域名信息并非集中与 1 台 DNS 服务器，但可以获取某一 DNS 服务器中未注册的所有地址</strong></li><li>DNS 服务器根据操作系统进行区分，Windows 下的 DNS 服务器和 Linux 下的 DNS 服务器是不同的。</li></ol></li><li><p><strong>阅读如下对话，并说明东秀的方案是否可行。（因为对话的字太多，用图代替）</strong></p><p><img src="/.io//blog/blog/picture/5c41a22f35390.png"></p><p>答：答案就是可行，DNS 服务器是分布式的，一台坏了可以找其他的。</p></li><li><p><strong>再浏览器地址输入 <a href="http://www.orentec.co.kr/">www.orentec.co.kr</a> ，并整理出主页显示过程。假设浏览器访问默认 DNS 服务器中并没有关于 <a href="http://www.orentec.co.kr/">www.orentec.co.kr</a> 的地址信息.</strong></p><p>答：可以参考一下知乎回答，<a href="https://www.zhihu.com/question/34873227/answer/518086565">在浏览器地址栏输入一个URL后回车，背后会进行哪些技术步骤？</a>,我用我自己的理解，简单说一下，首先会去向上一级的 DNS 服务器去查询，通过这种方式逐级向上传递信息，一直到达根服务器时，它知道应该向哪个 DNS 服务器发起询问。向下传递解析请求，得到IP地址候原路返回，最后会将解析的IP地址传递到发起请求的主机。</p></li></ol><h2 id="第-9-章-套接字的多种可选项"><a href="#第-9-章-套接字的多种可选项" class="headerlink" title="第 9 章 套接字的多种可选项"></a>第 9 章 套接字的多种可选项</h2><p>本章代码，在<a href="https://github.com/riba2534/TCP-IP-NetworkNote">TCP-IP-NetworkNote</a>中可以找到。</p><h3 id="9-1-套接字可选项和-I-O-缓冲大小"><a href="#9-1-套接字可选项和-I-O-缓冲大小" class="headerlink" title="9.1 套接字可选项和 I&#x2F;O 缓冲大小"></a>9.1 套接字可选项和 I&#x2F;O 缓冲大小</h3><p>我们进行套接字编程时往往只关注数据通信，而忽略了套接字具有的不同特性。但是，理解这些特性并根据实际需要进行更改也很重要</p><h4 id="9-1-1-套接字多种可选项"><a href="#9-1-1-套接字多种可选项" class="headerlink" title="9.1.1 套接字多种可选项"></a>9.1.1 套接字多种可选项</h4><p>我们之前写得程序都是创建好套接字之后直接使用的，此时通过默认的套接字特性进行数据通信，这里列出了一些套接字可选项。</p><table><thead><tr><th align="center">协议层</th><th align="center">选项名</th><th align="center">读取</th><th align="center">设置</th></tr></thead><tbody><tr><td align="center">SOL_SOCKET</td><td align="center">SO_SNDBUF</td><td align="center">O</td><td align="center">O</td></tr><tr><td align="center">SOL_SOCKET</td><td align="center">SO_RCVBUF</td><td align="center">O</td><td align="center">O</td></tr><tr><td align="center">SOL_SOCKET</td><td align="center">SO_REUSEADDR</td><td align="center">O</td><td align="center">O</td></tr><tr><td align="center">SOL_SOCKET</td><td align="center">SO_KEEPALIVE</td><td align="center">O</td><td align="center">O</td></tr><tr><td align="center">SOL_SOCKET</td><td align="center">SO_BROADCAST</td><td align="center">O</td><td align="center">O</td></tr><tr><td align="center">SOL_SOCKET</td><td align="center">SO_DONTROUTE</td><td align="center">O</td><td align="center">O</td></tr><tr><td align="center">SOL_SOCKET</td><td align="center">SO_OOBINLINE</td><td align="center">O</td><td align="center">O</td></tr><tr><td align="center">SOL_SOCKET</td><td align="center">SO_ERROR</td><td align="center">O</td><td align="center">X</td></tr><tr><td align="center">SOL_SOCKET</td><td align="center">SO_TYPE</td><td align="center">O</td><td align="center">X</td></tr><tr><td align="center">IPPROTO_IP</td><td align="center">IP_TOS</td><td align="center">O</td><td align="center">O</td></tr><tr><td align="center">IPPROTO_IP</td><td align="center">IP_TTL</td><td align="center">O</td><td align="center">O</td></tr><tr><td align="center">IPPROTO_IP</td><td align="center">IP_MULTICAST_TTL</td><td align="center">O</td><td align="center">O</td></tr><tr><td align="center">IPPROTO_IP</td><td align="center">IP_MULTICAST_LOOP</td><td align="center">O</td><td align="center">O</td></tr><tr><td align="center">IPPROTO_IP</td><td align="center">IP_MULTICAST_IF</td><td align="center">O</td><td align="center">O</td></tr><tr><td align="center">IPPROTO_TCP</td><td align="center">TCP_KEEPALIVE</td><td align="center">O</td><td align="center">O</td></tr><tr><td align="center">IPPROTO_TCP</td><td align="center">TCP_NODELAY</td><td align="center">O</td><td align="center">O</td></tr><tr><td align="center">IPPROTO_TCP</td><td align="center">TCP_MAXSEG</td><td align="center">O</td><td align="center">O</td></tr></tbody></table><p>从表中可以看出，套接字可选项是分层的。</p><ul><li><p>IPPROTO_IP 可选项是IP协议相关事项</p></li><li><p>IPPROTO_TCP 层可选项是 TCP 协议的相关事项</p></li><li><p>SOL_SOCKET 层是套接字的通用可选项。</p></li></ul><h4 id="9-1-2-getsockopt-setsockopt"><a href="#9-1-2-getsockopt-setsockopt" class="headerlink" title="9.1.2 getsockopt &amp; setsockopt"></a>9.1.2 <code>getsockopt</code> &amp; <code>setsockopt</code></h4><p>可选项的读取和设置通过以下两个函数来完成</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">getsockopt</span><span class="hljs-params">(<span class="hljs-type">int</span> sock, <span class="hljs-type">int</span> level, <span class="hljs-type">int</span> optname, <span class="hljs-type">void</span> *optval, <span class="hljs-type">socklen_t</span> *optlen)</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">成功时返回 0 ，失败时返回 -1</span><br><span class="hljs-comment">sock: 用于查看选项套接字文件描述符</span><br><span class="hljs-comment">level: 要查看的可选项协议层</span><br><span class="hljs-comment">optname: 要查看的可选项名</span><br><span class="hljs-comment">optval: 保存查看结果的缓冲地址值</span><br><span class="hljs-comment">optlen: 向第四个参数传递的缓冲大小。调用函数候，该变量中保存通过第四个参数返回的可选项信息的字节数。</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>上述函数可以用来读取套接字可选项，下面的函数可以更改可选项：d</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">setsockopt</span><span class="hljs-params">(<span class="hljs-type">int</span> sock, <span class="hljs-type">int</span> level, <span class="hljs-type">int</span> optname, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *optval, <span class="hljs-type">socklen_t</span> optlen)</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">成功时返回 0 ，失败时返回 -1</span><br><span class="hljs-comment">sock: 用于更改选项套接字文件描述符</span><br><span class="hljs-comment">level: 要更改的可选项协议层</span><br><span class="hljs-comment">optname: 要更改的可选项名</span><br><span class="hljs-comment">optval: 保存要更改的选项信息的缓冲地址值</span><br><span class="hljs-comment">optlen: 向第四个参数传递的可选信息的字节数。</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>下面的代码可以看出 getsockopt 的使用方法。下面示例用协议层为 SOL_SOCKET 、名为 SO_TYPE 的可选项查看套接字类型（TCP 和 UDP ）。</p><ul><li><a href="https://github.com/riba2534/TCP-IP-NetworkNote/blob/master/ch09/sock_type.c">sock_type.c</a></li></ul><p>编译运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc sock_type.c -o sock_type<br>./sock_type<br></code></pre></td></tr></table></figure><p>结果：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ada">SOCK_STREAM: <span class="hljs-number">1</span><br>SOCK_DGRAM: <span class="hljs-number">2</span><br>Socket <span class="hljs-keyword">type</span> <span class="hljs-type">one: </span><span class="hljs-number">1</span><br>Socket <span class="hljs-keyword">type</span> <span class="hljs-type">two: </span><span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>首先创建了一个 TCP 套接字和一个 UDP 套接字。然后通过调用 getsockopt 函数来获得当前套接字的状态。</p><p>验证套接类型的 SO_TYPE 是只读可选项，因为<strong>套接字类型只能在创建时决定，以后不能再更改</strong>。</p><h4 id="9-1-3-SO-SNDBUF-SO-RCVBUF"><a href="#9-1-3-SO-SNDBUF-SO-RCVBUF" class="headerlink" title="9.1.3 SO_SNDBUF &amp; SO_RCVBUF"></a>9.1.3 <code>SO_SNDBUF</code> &amp; <code>SO_RCVBUF</code></h4><p>创建套接字的同时会生成 I&#x2F;O 缓冲。关于 I&#x2F;O 缓冲，可以去看第五章。</p><p>SO_RCVBUF 是输入缓冲大小相关可选项，SO_SNDBUF 是输出缓冲大小相关可选项。用这 2 个可选项既可以读取当前 I&#x2F;O 大小，也可以进行更改。通过下列示例读取创建套接字时默认的 I&#x2F;O 缓冲大小。</p><ul><li><a href="https://github.com/riba2534/TCP-IP-NetworkNote/blob/master/ch09/get_buf.c">get_buf.c</a></li></ul><p>编译运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc get_buf.c -o getbuf<br>./getbuf<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino">Input buffer size: <span class="hljs-number">87380</span><br>Output buffer size: <span class="hljs-number">16384</span><br></code></pre></td></tr></table></figure><p>可以看出本机的输入缓冲和输出缓冲大小。</p><p>下面的代码演示了，通过程序设置 I&#x2F;O 缓冲区的大小</p><ul><li><a href="https://github.com/riba2534/TCP-IP-NetworkNote/blob/master/ch09/set_buf.c">set_buf.c</a></li></ul><p>编译运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc get_buf.c -o setbuf<br>./setbuf<br></code></pre></td></tr></table></figure><p>结果:</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino">Input buffer size: <span class="hljs-number">6144</span><br>Output buffer size: <span class="hljs-number">6144</span><br></code></pre></td></tr></table></figure><p>输出结果和我们预想的不是很相同，缓冲大小的设置需谨慎处理，因此不会完全按照我们的要求进行。</p><h3 id="9-2-SO-REUSEADDR"><a href="#9-2-SO-REUSEADDR" class="headerlink" title="9.2 SO_REUSEADDR"></a>9.2 <code>SO_REUSEADDR</code></h3><h4 id="9-2-1-发生地址分配错误（Binding-Error）"><a href="#9-2-1-发生地址分配错误（Binding-Error）" class="headerlink" title="9.2.1 发生地址分配错误（Binding Error）"></a>9.2.1 发生地址分配错误（Binding Error）</h4><p>在学习 SO_REUSEADDR 可选项之前，应该好好理解 Time-wait 状态。看以下代码的示例：</p><ul><li><a href="https://github.com/riba2534/TCP-IP-NetworkNote/blob/master/ch09/reuseadr_eserver.c">reuseadr_eserver.c</a></li></ul><p>这是一个回声服务器的服务端代码，可以配合第四章的 <a href="https://github.com/riba2534/TCP-IP-NetworkNote/blob/master/ch04/echo_client.c">echo_client.c</a> 使用，在这个代码中，客户端通知服务器终止程序。在客户端控制台输入 Q 可以结束程序，向服务器发送 FIN 消息并经过四次握手过程。当然，输入 CTRL+C 也会向服务器传递 FIN 信息。强制终止程序时，由操作系统关闭文件套接字，此过程相当于调用 close 函数，也会向服务器发送 FIN 消息。</p><p>这样看不到是什么特殊现象，考虑以下情况：</p><blockquote><p>服务器端和客户端都已经建立连接的状态下，向服务器控制台输入 CTRL+C ，强制关闭服务端</p></blockquote><p>如果用这种方式终止程序，如果用同一端口号再次运行服务端，就会输出「bind() error」消息，并且无法再次运行。但是在这种情况下，再过大约 3 分钟就可以重新运行服务端。</p><h4 id="9-2-2-Time-wait-状态"><a href="#9-2-2-Time-wait-状态" class="headerlink" title="9.2.2 Time-wait 状态"></a>9.2.2 <code>Time-wait</code> 状态</h4><p>观察以下过程：</p><p><img src="/.io//blog/blog/picture/5c42db182cade.png"></p><p>假设图中主机 A 是服务器，因为是主机 A 向 B 发送 FIN 消息，故可想象成服务器端在控制台中输入 CTRL+C 。但是问题是，套接字经过四次握手后并没有立即消除，而是要经过一段时间的 Time-wait 状态。当然，只有先断开连接的（先发送 FIN 消息的）主机才经过 Time-wait 状态。因此，若服务器端先断开连接，则无法立即重新运行。套接字处在 Time-wait 过程时，相应端口是正在使用的状态。因此，就像之前验证过的，bind 函数调用过程中会发生错误。</p><p><strong>实际上，不论是服务端还是客户端，都要经过一段时间的 Time-wait 过程。先断开连接的套接字必然会经过 Time-wait 过程，但是由于客户端套接字的端口是任意制定的，所以无需过多关注 Time-wait 状态。</strong></p><p>那到底为什么会有 Time-wait 状态呢，在图中假设，主机 A 向主机 B 传输 ACK 消息（SEQ 5001 , ACK 7502 ）后立刻消除套接字。但是最后这条 ACK 消息在传递过程中丢失，没有传递主机 B ，这时主机 B 就会试图重传。但是此时主机 A 已经是完全终止状态，因为主机 B 永远无法收到从主机 A 最后传来的 ACK 消息。基于这些问题的考虑，所以要设计 Time-wait 状态。</p><h4 id="9-2-3-地址再分配"><a href="#9-2-3-地址再分配" class="headerlink" title="9.2.3 地址再分配"></a>9.2.3 地址再分配</h4><p>Time-wait 状态看似重要，但是不一定讨人喜欢。如果系统发生故障紧急停止，这时需要尽快重启服务起以提供服务，但因处于 Time-wait 状态而必须等待几分钟。因此，Time-wait 并非只有优点，这些情况下容易引发大问题。下图中展示了四次握手时不得不延长 Time-wait 过程的情况。</p><p><img src="/.io//blog/blog/picture/5c42dec2ba42b.png"></p><p>从图上可以看出，在主机 A 四次握手的过程中，如果最后的数据丢失，则主机 B 会认为主机 A 未能收到自己发送的 FIN 信息，因此重传。这时，收到的 FIN 消息的主机 A 将重启  Time-wait 计时器。因此，如果网络状况不理想， Time-wait 将持续。</p><p>解决方案就是在套接字的可选项中更改 SO_REUSEADDR 的状态。适当调整该参数，可将 Time-wait 状态下的套接字端口号重新分配给新的套接字。SO_REUSEADDR 的默认值为 0.这就意味着无法分配 Time-wait 状态下的套接字端口号。因此需要将这个值改成 1 。具体作法已在示例 <a href="https://github.com/riba2534/TCP-IP-NetworkNote/blob/master/ch09/reuseadr_eserver.c">reuseadr_eserver.c</a> 给出，只需要把注释掉的东西接解除注释即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">optlen = <span class="hljs-keyword">sizeof</span>(option);<br>option = TRUE;<br>setsockopt(serv_sock, SOL_SOCKET, SO_REUSEADDR, (<span class="hljs-type">void</span> *)&amp;option, optlen);<br></code></pre></td></tr></table></figure><p>此时，已经解决了上述问题。</p><h3 id="9-3-TCP-NODELAY"><a href="#9-3-TCP-NODELAY" class="headerlink" title="9.3 TCP_NODELAY"></a>9.3 <code>TCP_NODELAY</code></h3><h4 id="9-3-1-Nagle-算法"><a href="#9-3-1-Nagle-算法" class="headerlink" title="9.3.1 Nagle 算法"></a>9.3.1 <code>Nagle</code> 算法</h4><p>为了防止因数据包过多而发生网络过载，<code>Nagle</code> 算法诞生了。它应用于 TCP 层。它是否使用会导致如图所示的差异：</p><p><img src="/.io//blog/blog/picture/5c42e12abc5b8.png"></p><p>图中展示了通过 <code>Nagle</code> 算法发送字符串 <code>Nagle</code> 和未使用 <code>Nagle</code> 算法的差别。可以得到一个结论。</p><p><strong>只有接收到前一数据的 ACK 消息， <code>Nagle</code> 算法才发送下一数据。</strong></p><p>TCP 套接字默认使用 <code>Nagle</code> 算法交换数据，因此最大限度的进行缓冲，直到收到 ACK 。左图也就是说一共传递 4 个数据包以传输一个字符串。从右图可以看出，发送数据包一共使用了 10 个数据包。由此可知，不使用 <code>Nagle</code> 算法将对网络流量产生负面影响。即使只传输一个字节的数据，其头信息都可能是几十个字节。因此，为了提高网络传输效率，必须使用 <code>Nagle</code> 算法。</p><p> <code>Nagle</code> 算法并不是什么情况下都适用，网络流量未受太大影响时，不使用 <code>Nagle</code> 算法要比使用它时传输速度快。最典型的就是「传输大文件数据」。将文件数据传入输出缓冲不会花太多时间，因此，不使用 <code>Nagle</code> 算法，也会在装满输出缓冲时传输数据包。这不仅不会增加数据包的数量，反而在无需等待 ACK 的前提下连续传输，因此可以大大提高传输速度。</p><p>所以，未准确判断数据性质时不应禁用 <code>Nagle</code> 算法。</p><h4 id="9-3-2-禁用-Nagle-算法"><a href="#9-3-2-禁用-Nagle-算法" class="headerlink" title="9.3.2 禁用 Nagle 算法"></a>9.3.2 禁用 <code>Nagle</code> 算法</h4><p>禁用 <code>Nagle</code> 算法应该使用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> opt_val = <span class="hljs-number">1</span>;<br>setsockopt(sock, IPPROTO_TCP, TCP_NODELAY, (<span class="hljs-type">void</span> *)&amp;opt_val, <span class="hljs-keyword">sizeof</span>(opt_val));<br></code></pre></td></tr></table></figure><p>通过 TCP_NODELAY 的值来查看<code>Nagle</code> 算法的设置状态。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">opt_len = <span class="hljs-keyword">sizeof</span>(opt_val);<br>getsockopt(sock, IPPROTO_TCP, TCP_NODELAY, (<span class="hljs-type">void</span> *)&amp;opt_val, opt_len);<br></code></pre></td></tr></table></figure><p>如果正在使用<code>Nagle</code> 算法，那么 opt_val 值为 0，如果禁用则为 1.</p><p>关于这个算法，可以参考这个回答：<a href="https://www.zhihu.com/question/42308970/answer/246334766">TCP连接中启用和禁用TCP_NODELAY有什么影响？</a></p><h3 id="9-4-基于-Windows-的实现"><a href="#9-4-基于-Windows-的实现" class="headerlink" title="9.4 基于 Windows 的实现"></a>9.4 基于 Windows 的实现</h3><p>暂略</p><h3 id="9-5-习题"><a href="#9-5-习题" class="headerlink" title="9.5 习题"></a>9.5 习题</h3><blockquote><p>以下答案仅代表本人个人观点，可能不是正确答案。</p></blockquote><ol><li><p><strong>下列关于 Time-wait 状态的说法错误的是？</strong></p><p>答：以下字体加粗的代表正确。</p><ol><li>Time-wait 状态只在服务器的套接字中发生</li><li><strong>断开连接的四次握手过程中，先传输 FIN 消息的套接字将进入 Time-wait 状态。</strong></li><li>Time-wait 状态与断开连接的过程无关，而与请求连接过程中 SYN 消息的传输顺序有关</li><li>Time-wait 状态通常并非必要，应尽可能通过更改套接字可选项来防止其发生</li></ol></li><li><p><strong>TCP_NODELAY 可选项与 Nagle 算法有关，可通过它禁用 Nagle 算法。请问何时应考虑禁用 Nagle 算法？结合收发数据的特性给出说明。</strong></p><p>答：当网络流量未受太大影响时，不使用 Nagle 算法要比使用它时传输速度快，比如说在传输大文件时。</p></li></ol><h2 id="第-10-章-多进程服务器端"><a href="#第-10-章-多进程服务器端" class="headerlink" title="第 10 章 多进程服务器端"></a>第 10 章 多进程服务器端</h2><p>本章代码，在<a href="https://github.com/riba2534/TCP-IP-NetworkNote">TCP-IP-NetworkNote</a>中可以找到。</p><h3 id="10-1-进程概念及应用"><a href="#10-1-进程概念及应用" class="headerlink" title="10.1 进程概念及应用"></a>10.1 进程概念及应用</h3><h4 id="10-1-1-并发服务端的实现方法"><a href="#10-1-1-并发服务端的实现方法" class="headerlink" title="10.1.1 并发服务端的实现方法"></a>10.1.1 并发服务端的实现方法</h4><p>通过改进服务端，使其同时向所有发起请求的客户端提供服务，以提高平均满意度。而且，网络程序中数据通信时间比 CPU 运算时间占比更大，因此，向多个客户端提供服务是一种有效的利用 CPU 的方式。接下来讨论同时向多个客户端提供服务的并发服务器端。下面列出的是具有代表性的并发服务端的实现模型和方法：</p><ul><li>多进程服务器：通过创建多个进程提供服务</li><li>多路复用服务器：通过捆绑并统一管理 I&#x2F;O 对象提供服务</li><li>多线程服务器：通过生成与客户端等量的线程提供服务</li></ul><p>先是第一种方法：多进程服务器</p><h4 id="10-1-2-理解进程"><a href="#10-1-2-理解进程" class="headerlink" title="10.1.2 理解进程"></a>10.1.2 理解进程</h4><p>进程的定义如下：</p><blockquote><p>占用内存空间的正在运行的程序</p></blockquote><p>假如你下载了一个游戏到电脑上，此时的游戏不是进程，而是程序。只有当游戏被加载到主内存并进入运行状态，这是才可称为进程。</p><h4 id="10-1-3-进程-ID"><a href="#10-1-3-进程-ID" class="headerlink" title="10.1.3 进程 ID"></a>10.1.3 进程 ID</h4><p>在说进程创建方法之前，先要简要说明进程 ID。无论进程是如何创建的，所有的进程都会被操作系统分配一个 ID。此 ID 被称为「进程ID」，其值为大于 2 的证书。1 要分配给操作系统启动后的（用于协助操作系统）首个进程，因此用户无法得到 ID 值为 1 。接下来观察在 Linux 中运行的进程。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ps au<br></code></pre></td></tr></table></figure><p>通过上面的命令可查看当前运行的所有进程。需要注意的是，该命令同时列出了 PID（进程ID）。参数 a 和 u列出了所有进程的详细信息。</p><p><img src="/.io//blog/blog/picture/5c43d7c1f2a8b.png"></p><h4 id="10-1-4-通过调用-fork-函数创建进程"><a href="#10-1-4-通过调用-fork-函数创建进程" class="headerlink" title="10.1.4 通过调用 fork 函数创建进程"></a>10.1.4 通过调用 fork 函数创建进程</h4><p>创建进程的方式很多，此处只介绍用于创建多进程服务端的 fork 函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-type">pid_t</span> <span class="hljs-title function_">fork</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-comment">// 成功时返回进程ID,失败时返回 -1</span><br></code></pre></td></tr></table></figure><p>fork 函数将创建调用的进程副本。也就是说，并非根据完全不同的程序创建进程，而是复制正在运行的、调用 fork 函数的进程。另外，两个进程都执行 fork 函数调用后的语句（准确的说是在 fork 函数返回后）。但因为是通过同一个进程、复制相同的内存空间，之后的程序流要根据 fork 函数的返回值加以区分。即利用 fork 函数的如下特点区分程序执行流程。</p><ul><li>父进程：fork 函数返回子进程 ID</li><li>子进程：fork 函数返回 0</li></ul><p>此处，「父进程」（Parent Process）指原进程，即调用 fork 函数的主体，而「子进程」（Child Process）是通过父进程调用 fork 函数复制出的进程。接下来是调用 fork 函数后的程序运行流程。如图所示：</p><p><img src="/.io//blog/blog/picture/5c43da5412b90.png"></p><p>从图中可以看出，父进程调用 fork 函数的同时复制出子进程，并分别得到 fork 函数的返回值。但复制前，父进程将全局变量 gval 增加到 11,将局部变量 lval 的值增加到 25，因此在这种状态下完成进程复制。复制完成后根据 fork 函数的返回类型区分父子进程。父进程的 lval 的值增加 1 ，但这不会影响子进程的 lval 值。同样子进程将 gval 的值增加 1 也不会影响到父进程的 gval 。因为 fork 函数调用后分成了完全不同的进程，只是二者共享同一段代码而已。接下来给出一个例子：</p><ul><li><a href="https://github.com/riba2534/TCP-IP-NetworkNote/blob/master/ch10/fork.c">fork.c</a></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-type">int</span> gval = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br>    <span class="hljs-type">pid_t</span> pid;<br>    <span class="hljs-type">int</span> lval = <span class="hljs-number">20</span>;<br>    gval++, lval += <span class="hljs-number">5</span>;<br>    pid = fork();<br>    <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>)<br>        gval += <span class="hljs-number">2</span>, lval += <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">else</span><br>        gval -= <span class="hljs-number">2</span>, lval -= <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Child Proc: [%d,%d] \n&quot;</span>, gval, lval);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Parent Proc: [%d,%d] \n&quot;</span>, gval, lval);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc fork.c -o fork<br>./fork<br></code></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/.io//blog/blog/picture/5c43e054e7f6f.png"></p><p>可以看出，当执行了 fork 函数之后，此后就相当于有了两个程序在执行代码，对于父进程来说，fork 函数返回的是子进程的ID，对于子进程来说，fork 函数返回 0。所以这两个变量，父进程进行了 +2 操作 ，而子进程进行了 -2 操作，所以结果是这样。</p><h3 id="10-2-进程和僵尸进程"><a href="#10-2-进程和僵尸进程" class="headerlink" title="10.2 进程和僵尸进程"></a>10.2 进程和僵尸进程</h3><p>文件操作中，关闭文件和打开文件同等重要。同样，进程销毁和进程创建也同等重要。如果未认真对待进程销毁，他们将变成僵尸进程。</p><h4 id="10-2-1-僵尸（Zombie）进程"><a href="#10-2-1-僵尸（Zombie）进程" class="headerlink" title="10.2.1 僵尸（Zombie）进程"></a>10.2.1 僵尸（Zombie）进程</h4><p>进程的工作完成后（执行完 main 函数中的程序后）应被销毁，但有时这些进程将变成僵尸进程，占用系统中的重要资源。这种状态下的进程称作「僵尸进程」，这也是给系统带来负担的原因之一。</p><blockquote><p>僵尸进程是当子进程比父进程先结束，而父进程又没有回收子进程，释放子进程占用的资源，此时子进程将成为一个僵尸进程。如果父进程先退出 ，子进程被init接管，子进程退出后init会回收其占用的相关资源</p></blockquote><p><strong>维基百科</strong>：</p><blockquote><p>在类UNIX系统中，僵尸进程是指完成执行（通过exit系统调用，或运行时发生致命错误或收到终止信号所致）但在操作系统的进程表中仍然有一个表项（进程控制块PCB），处于”终止状态”的进程。这发生于子进程需要保留表项以允许其父进程读取子进程的exit status：一旦退出态通过wait系统调用读取，僵尸进程条目就从进程表中删除，称之为”回收（reaped）”。正常情况下，进程直接被其父进程wait并由系统回收。进程长时间保持僵尸状态一般是错误的并导致资源泄漏。</p><p>英文术语zombie process源自丧尸 — 不死之人，隐喻子进程已死但仍然没有被收割。与正常进程不同，kill命令对僵尸进程无效。孤儿进程不同于僵尸进程，其父进程已经死掉，但孤儿进程仍能正常执行，但并不会变为僵尸进程，因为被init（进程ID号为1）收养并wait其退出。</p><p>子进程死后，系统会发送SIGCHLD 信号给父进程，父进程对其默认处理是忽略。如果想响应这个消息，父进程通常在SIGCHLD 信号事件处理程序中，使用wait系统调用来响应子进程的终止。</p><p>僵尸进程被收割后，其进程号(PID)与在进程表中的表项都可以被系统重用。但如果父进程没有调用wait，僵尸进程将保留进程表中的表项，导致了资源泄漏。某些情况下这反倒是期望的：父进程创建了另外一个子进程，并希望具有不同的进程号。如果父进程通过设置事件处理函数为SIG_IGN显式忽略SIGCHLD信号，而不是隐式默认忽略该信号，或者具有SA_NOCLDWAIT标志，所有子进程的退出状态信息将被抛弃并且直接被系统回收。</p><p>UNIX命令ps列出的进程的状态（”STAT”）栏标示为 “Z”则为僵尸进程。[1]</p><p>收割僵尸进程的方法是通过kill命令手工向其父进程发送SIGCHLD信号。如果其父进程仍然拒绝收割僵尸进程，则终止父进程，使得init进程收养僵尸进程。init进程周期执行wait系统调用收割其收养的所有僵尸进程。</p></blockquote><h4 id="10-2-2-产生僵尸进程的原因"><a href="#10-2-2-产生僵尸进程的原因" class="headerlink" title="10.2.2 产生僵尸进程的原因"></a>10.2.2 产生僵尸进程的原因</h4><p>为了防止僵尸进程产生，先解释产生僵尸进程的原因。利用如下两个示例展示调用 fork 函数产生子进程的终止方式。</p><ul><li>传递参数并调用 exit() 函数</li><li>main 函数中执行 return 语句并返回值</li></ul><p><strong>向 exit 函数传递的参数值和 main 函数的 return 语句返回的值都回传递给操作系统。而操作系统不会销毁子进程，直到把这些值传递给产生该子进程的父进程。处在这种状态下的进程就是僵尸进程。</strong>也就是说将子进程变成僵尸进程的正是操作系统。既然如此，僵尸进程何时被销毁呢？</p><blockquote><p>应该向创建子进程册父进程传递子进程的 exit 参数值或 return 语句的返回值。</p></blockquote><p>如何向父进程传递这些值呢？操作系统不会主动把这些值传递给父进程。只有父进程主动发起请求（函数调用）的时候，操作系统才会传递该值。换言之，如果父进程未主动要求获得子进程结束状态值，操作系统将一直保存，并让子进程长时间处于僵尸进程状态。也就是说，父母要负责收回自己生的孩子。接下来的示例是创建僵尸进程：</p><ul><li><a href="https://github.com/riba2534/TCP-IP-NetworkNote/blob/master/ch10/zombie.c">zombie.c</a></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br>    <span class="hljs-type">pid_t</span> pid = fork();<br>    <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Hi, I am a child Process&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Child Process ID: %d \n&quot;</span>, pid);<br>        sleep(<span class="hljs-number">30</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>)<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;End child proess&quot;</span>);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;End parent process&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc zombie.c -o zombie<br>./zombie<br></code></pre></td></tr></table></figure><p>结果：</p><p><img src="/.io//blog/blog/picture/5c443890f1781.png"></p><p>因为暂停了 30 秒，所以在这个时间内可以验证一下子进程是否为僵尸进程。</p><p><img src="/.io//blog/blog/picture/5c4439a751b11.png"></p><p>通过 <code>ps au</code> 命令可以看出，子进程仍然存在，并没有被销毁，僵尸进程在这里显示为 <code>Z+</code>.30秒后，红框里面的两个进程会同时被销毁。</p><blockquote><p>利用 <code>./zombie &amp;</code>可以使程序在后台运行，不用打开新的命令行窗口。</p></blockquote><h4 id="10-2-3-销毁僵尸进程-1：利用-wait-函数"><a href="#10-2-3-销毁僵尸进程-1：利用-wait-函数" class="headerlink" title="10.2.3 销毁僵尸进程 1：利用 wait 函数"></a>10.2.3 销毁僵尸进程 1：利用 wait 函数</h4><p>如前所述，为了销毁子进程，父进程应该主动请求获取子进程的返回值。下面是发起请求的具体方法。有两种，下面的函数是其中一种。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><span class="hljs-type">pid_t</span> <span class="hljs-title function_">wait</span><span class="hljs-params">(<span class="hljs-type">int</span> *statloc)</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">成功时返回终止的子进程 ID ,失败时返回 -1</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>调用此函数时如果已有子进程终止，那么子进程终止时传递的返回值（exit 函数的参数返回值，main 函数的 return 返回值）将保存到该函数的参数所指的内存空间。但函数参数指向的单元中还包含其他信息，因此需要用下列宏进行分离：</p><ul><li>WIFEXITED 子进程正常终止时返回「真」</li><li>WEXITSTATUS 返回子进程时的返回值</li></ul><p>也就是说，向 wait 函数传递变量 status 的地址时，调用 wait 函数后应编写如下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (WIFEXITED(status))<br>&#123;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Normal termination&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Child pass num: %d&quot;</span>, WEXITSTATUS(status));<br>&#125;<br></code></pre></td></tr></table></figure><p>根据以上内容，有如下示例：</p><ul><li><a href="https://github.com/riba2534/TCP-IP-NetworkNote/blob/master/ch10/wait.c">wait.c</a></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br>    <span class="hljs-type">int</span> status;<br>    <span class="hljs-type">pid_t</span> pid = fork(); <span class="hljs-comment">//这里的子进程将在第13行通过 return 语句终止</span><br><br>    <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Child PID: %d \n&quot;</span>, pid);<br>        pid = fork(); <span class="hljs-comment">//这里的子进程将在 21 行通过 exit() 函数终止</span><br>        <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">7</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Child PID: %d \n&quot;</span>, pid);<br>            wait(&amp;status);         <span class="hljs-comment">//之间终止的子进程相关信息将被保存到 status 中，同时相关子进程被完全销毁</span><br>            <span class="hljs-keyword">if</span> (WIFEXITED(status)) <span class="hljs-comment">//通过 WIFEXITED 来验证子进程是否正常终止。如果正常终止，则调用 WEXITSTATUS 宏输出子进程返回值</span><br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Child send one: %d \n&quot;</span>, WEXITSTATUS(status));<br><br>            wait(&amp;status); <span class="hljs-comment">//因为之前创建了两个进程，所以再次调用 wait 函数和宏</span><br>            <span class="hljs-keyword">if</span> (WIFEXITED(status))<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Child send two: %d \n&quot;</span>, WEXITSTATUS(status));<br>            sleep(<span class="hljs-number">30</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc wait.c -o wait<br>./wait<br></code></pre></td></tr></table></figure><p>结果：</p><p><img src="/.io//blog/blog/picture/5c4441951df43.png"></p><p>此时，系统中并没有上述 PID 对应的进程，这是因为调用了 wait 函数，完全销毁了该子进程。另外两个子进程返回时返回的 3 和 7 传递到了父进程。</p><p>这就是通过 wait 函数消灭僵尸进程的方法，调用 wait 函数时，如果没有已经终止的子进程，那么程序将阻塞（Blocking）直到有子进程终止，因此要谨慎调用该函数。</p><h4 id="10-2-4-销毁僵尸进程-2：使用-waitpid-函数"><a href="#10-2-4-销毁僵尸进程-2：使用-waitpid-函数" class="headerlink" title="10.2.4 销毁僵尸进程 2：使用 waitpid 函数"></a>10.2.4 销毁僵尸进程 2：使用 waitpid 函数</h4><p>wait 函数会引起程序阻塞，还可以考虑调用 waitpid 函数。这是防止僵尸进程的第二种方法，也是防止阻塞的方法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><span class="hljs-type">pid_t</span> <span class="hljs-title function_">waitpid</span><span class="hljs-params">(<span class="hljs-type">pid_t</span> pid, <span class="hljs-type">int</span> *statloc, <span class="hljs-type">int</span> options)</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">成功时返回终止的子进程ID 或 0 ，失败时返回 -1</span><br><span class="hljs-comment">pid: 等待终止的目标子进程的ID,若传 -1，则与 wait 函数相同，可以等待任意子进程终止</span><br><span class="hljs-comment">statloc: 与 wait 函数的 statloc 参数具有相同含义</span><br><span class="hljs-comment">options: 传递头文件 sys/wait.h 声明的常量 WNOHANG ,即使没有终止的子进程也不会进入阻塞状态，而是返回 0 退出函数。</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>以下是 waitpid 的使用示例：</p><ul><li><a href="https://github.com/riba2534/TCP-IP-NetworkNote/blob/master/ch10/waitpid.c">waitpid.c</a></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br>    <span class="hljs-type">int</span> status;<br>    <span class="hljs-type">pid_t</span> pid = fork();<br>    <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>)<br>    &#123;<br>        sleep(<span class="hljs-number">15</span>); <span class="hljs-comment">//用 sleep 推迟子进程的执行</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">24</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-comment">//调用waitpid 传递参数 WNOHANG ，这样之前存在没有终止的子进程则返回0</span><br>        <span class="hljs-keyword">while</span> (!waitpid(<span class="hljs-number">-1</span>, &amp;status, WNOHANG))<br>        &#123;<br>            sleep(<span class="hljs-number">3</span>);<br>            <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;sleep 3 sec.&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (WIFEXITED(status))<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Child send %d \n&quot;</span>, WEXITSTATUS(status));<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc waitpid.c -o waitpid<br>./waitpid<br></code></pre></td></tr></table></figure><p>结果:</p><p><img src="/.io//blog/blog/picture/5c444785a16ae.png"></p><p>可以看出来，在 while 循环中正好执行了 5 次。这也证明了 waitpid 函数并没有阻塞</p><h3 id="10-3-信号处理"><a href="#10-3-信号处理" class="headerlink" title="10.3 信号处理"></a>10.3 信号处理</h3><p>我们已经知道了进程的创建及销毁的办法，但是还有一个问题没有解决。</p><blockquote><p>子进程究竟何时终止？调用 waitpid 函数后要无休止的等待吗？</p></blockquote><h4 id="10-3-1-向操作系统求助"><a href="#10-3-1-向操作系统求助" class="headerlink" title="10.3.1 向操作系统求助"></a>10.3.1 向操作系统求助</h4><p>子进程终止的识别主体是操作系统，因此，若操作系统能把如下信息告诉正忙于工作的父进程，将有助于构建更高效的程序</p><p>为了实现上述的功能，引入信号处理机制（Signal Handing）。此处「信号」是在特定事件发生时由操作系统向进程发送的消息。另外，为了响应该消息，执行与消息相关的自定义操作的过程被称为「处理」或「信号处理」。</p><h4 id="10-3-2-信号与-signal-函数"><a href="#10-3-2-信号与-signal-函数" class="headerlink" title="10.3.2 信号与 signal 函数"></a>10.3.2 信号与 signal 函数</h4><p>下面进程和操作系统的对话可以帮助理解信号处理。</p><blockquote><p>进程：操作系统，如果我之前创建的子进程终止，就帮我调用 zombie_handler 函数。</p><p>操作系统：好的，如果你的子进程终止，我舅帮你调用 zombie_handler 函数，你先把要函数要执行的语句写好。</p></blockquote><p>上述的对话，相当于「注册信号」的过程。即进程发现自己的子进程结束时，请求操作系统调用的特定函数。该请求可以通过如下函数调用完成：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><span class="hljs-type">void</span> (*signal(<span class="hljs-type">int</span> signo, <span class="hljs-type">void</span> (*func)(<span class="hljs-type">int</span>)))(<span class="hljs-type">int</span>);<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">为了在产生信号时调用，返回之前注册的函数指针</span><br><span class="hljs-comment">函数名: signal</span><br><span class="hljs-comment">参数：int signo,void(*func)(int)</span><br><span class="hljs-comment">返回类型：参数类型为int型，返回 void 型函数指针</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>调用上述函数时，第一个参数为特殊情况信息，第二个参数为特殊情况下将要调用的函数的地址值（指针）。发生第一个参数代表的情况时，调用第二个参数所指的函数。下面给出可以在 signal 函数中注册的部分特殊情况和对应的函数。</p><ul><li>SIGALRM：已到通过调用 alarm 函数注册时间</li><li>SIGINT：输入 ctrl+c</li><li>SIGCHLD：子进程终止</li></ul><p>接下来编写调用 signal 函数的语句完成如下请求：</p><blockquote><p>「子进程终止则调用 mychild 函数」</p></blockquote><p>此时 mychild 函数的参数应为 int ，返回值类型应为 void 。只有这样才能称为 signal 函数的第二个参数。另外，常数 SIGCHLD 定义了子进程终止的情况，应成为 signal 函数的第一个参数。也就是说，signal 函数调用语句如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">signal(SIGCHLD , mychild);<br></code></pre></td></tr></table></figure><p>接下来编写 signal 函数的调用语句，分别完成如下两个请求：</p><ol><li>已到通过 alarm 函数注册时间，请调用 timeout 函数</li><li>输入 ctrl+c 时调用 keycontrol 函数</li></ol><p>代表这 2 种情况的常数分别为 SIGALRM 和 SIGINT ，因此按如下方式调用 signal 函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">signal(SIGALRM , timeout);<br>signal(SIGINT , keycontrol);<br></code></pre></td></tr></table></figure><p>以上就是信号注册过程。注册好信号之后，发生注册信号时（注册的情况发生时），操作系统将调用该信号对应的函数。先介绍 alarm 函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-title function_">alarm</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> seconds)</span>;<br><span class="hljs-comment">// 返回0或以秒为单位的距 SIGALRM 信号发生所剩时间</span><br></code></pre></td></tr></table></figure><p>如果调用该函数的同时向它传递一个正整型参数，相应时间后（以秒为单位）将产生 SIGALRM 信号。若向该函数传递为 0 ，则之前对 SIGALRM 信号的预约将取消。如果通过改函数预约信号后未指定该信号对应的处理函数，则（通过调用 signal 函数）终止进程，不做任何处理。</p><ul><li><a href="https://github.com/riba2534/TCP-IP-NetworkNote/blob/master/ch10/signal.c">signal.c</a></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><span class="hljs-type">void</span> <span class="hljs-title function_">timeout</span><span class="hljs-params">(<span class="hljs-type">int</span> sig)</span> <span class="hljs-comment">//信号处理器</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (sig == SIGALRM)<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Time out!&quot;</span>);<br>    alarm(<span class="hljs-number">2</span>); <span class="hljs-comment">//为了每隔 2 秒重复产生 SIGALRM 信号，在信号处理器中调用 alarm 函数</span><br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">keycontrol</span><span class="hljs-params">(<span class="hljs-type">int</span> sig)</span> <span class="hljs-comment">//信号处理器</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (sig == SIGINT)<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;CTRL+C pressed&quot;</span>);<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br>    <span class="hljs-type">int</span> i;<br>    signal(SIGALRM, timeout); <span class="hljs-comment">//注册信号及相应处理器</span><br>    signal(SIGINT, keycontrol);<br>    alarm(<span class="hljs-number">2</span>); <span class="hljs-comment">//预约 2 秒候发生 SIGALRM 信号</span><br><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)<br>    &#123;<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;wait...&quot;</span>);<br>        sleep(<span class="hljs-number">100</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc signal.c -o signal<br>./signal<br></code></pre></td></tr></table></figure><p>结果：</p><p><img src="/.io//blog/blog/picture/5c446c877acb7.png"></p><p>上述结果是没有任何输入的运行结果。当输入 ctrl+c 时:</p><p><img src="/.io//blog/blog/picture/5c446ce0b1143.png"></p><p>就可以看到 <code>CTRL+C pressed</code> 的字符串。</p><blockquote><p>发生信号时将唤醒由于调用 sleep 函数而进入阻塞状态的进程。</p></blockquote><p>调用函数的主题的确是操作系统，但是进程处于睡眠状态时无法调用函数，因此，产生信号时，为了调用信号处理器，将唤醒由于调用 sleep 函数而进入阻塞状态的进程。而且，进程一旦被唤醒，就不会再进入睡眠状态。即使还未到 sleep 中规定的时间也是如此。所以上述示例运行不到 10 秒后就会结束，连续输入 CTRL+C 可能连一秒都不到。</p><p><strong>简言之，就是本来系统要睡眠100秒，但是到了 alarm(2) 规定的两秒之后，就会唤醒睡眠的进程，进程被唤醒了就不会再进入睡眠状态了，所以就不用等待100秒。如果把 timeout() 函数中的 alarm(2) 注释掉，就会先输出<code>wait...</code>，然后再输出<code>Time out!</code> (这时已经跳过了第一次的 sleep(100) 秒),然后就真的会睡眠100秒，因为没有再发出 alarm(2)  的信号。</strong></p><h4 id="10-3-3-利用-sigaction-函数进行信号处理"><a href="#10-3-3-利用-sigaction-函数进行信号处理" class="headerlink" title="10.3.3 利用 sigaction 函数进行信号处理"></a>10.3.3 利用 sigaction 函数进行信号处理</h4><p>前面所学的内容可以防止僵尸进程，还有一个函数，叫做 sigaction 函数，他类似于 signal 函数，而且可以完全代替后者，也更稳定。之所以稳定，是因为：</p><blockquote><p>signal 函数在 Unix 系列的不同操作系统可能存在区别，但 sigaction 函数完全相同</p></blockquote><p>实际上现在很少用 signal 函数编写程序，他只是为了保持对旧程序的兼容，下面介绍 sigaction 函数，只讲解可以替换 signal 函数的功能。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">sigaction</span><span class="hljs-params">(<span class="hljs-type">int</span> signo, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sigaction *act, <span class="hljs-keyword">struct</span> sigaction *oldact)</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">成功时返回 0 ，失败时返回 -1</span><br><span class="hljs-comment">act: 对于第一个参数的信号处理函数（信号处理器）信息。</span><br><span class="hljs-comment">oldact: 通过此参数获取之前注册的信号处理函数指针，若不需要则传递 0</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>声明并初始化 sigaction 结构体变量以调用上述函数，该结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sigaction</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">void</span> (*sa_handler)(<span class="hljs-type">int</span>);<br>    <span class="hljs-type">sigset_t</span> sa_mask;<br>    <span class="hljs-type">int</span> sa_flags;<br>&#125;;<br></code></pre></td></tr></table></figure><p>此结构体的成员 sa_handler 保存信号处理的函数指针值（地址值）。sa_mask 和 sa_flags 的所有位初始化 0 即可。这 2 个成员用于指定信号相关的选项和特性，而我们的目的主要是防止产生僵尸进程，故省略。</p><p>下面的示例是关于 sigaction 函数的使用方法。</p><ul><li><a href="https://github.com/riba2534/TCP-IP-NetworkNote/blob/master/ch10/sigaction.c">sigaction.c</a></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">timeout</span><span class="hljs-params">(<span class="hljs-type">int</span> sig)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (sig == SIGALRM)<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Time out!&quot;</span>);<br>    alarm(<span class="hljs-number">2</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sigaction</span> <span class="hljs-title">act</span>;</span><br>    act.sa_handler = timeout;    <span class="hljs-comment">//保存函数指针</span><br>    sigemptyset(&amp;act.sa_mask);   <span class="hljs-comment">//将 sa_mask 函数的所有位初始化成0</span><br>    act.sa_flags = <span class="hljs-number">0</span>;            <span class="hljs-comment">//sa_flags 同样初始化成 0</span><br>    sigaction(SIGALRM, &amp;act, <span class="hljs-number">0</span>); <span class="hljs-comment">//注册 SIGALRM 信号的处理器。</span><br><br>    alarm(<span class="hljs-number">2</span>); <span class="hljs-comment">//2 秒后发生 SIGALRM 信号</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)<br>    &#123;<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;wait...&quot;</span>);<br>        sleep(<span class="hljs-number">100</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>编译运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc sigaction.c -o sigaction<br>./sigaction<br></code></pre></td></tr></table></figure><p>结果：</p><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs vhdl"><span class="hljs-keyword">wait</span>...<br><span class="hljs-built_in">Time</span> <span class="hljs-keyword">out</span>!<br><span class="hljs-keyword">wait</span>...<br><span class="hljs-built_in">Time</span> <span class="hljs-keyword">out</span>!<br><span class="hljs-keyword">wait</span>...<br><span class="hljs-built_in">Time</span> <span class="hljs-keyword">out</span>!<br></code></pre></td></tr></table></figure><p>可以发现，结果和之前用 signal 函数的结果没有什么区别。以上就是信号处理的相关理论。</p><h4 id="10-3-4-利用信号处理技术消灭僵尸进程"><a href="#10-3-4-利用信号处理技术消灭僵尸进程" class="headerlink" title="10.3.4 利用信号处理技术消灭僵尸进程"></a>10.3.4 利用信号处理技术消灭僵尸进程</h4><p>下面利用子进程终止时产生 SIGCHLD 信号这一点，来用信号处理来消灭僵尸进程。看以下代码：</p><ul><li><a href="https://github.com/riba2534/TCP-IP-NetworkNote/blob/master/ch10/remove_zomebie.c">remove_zomebie.c</a></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">read_childproc</span><span class="hljs-params">(<span class="hljs-type">int</span> sig)</span><br>&#123;<br>    <span class="hljs-type">int</span> status;<br>    <span class="hljs-type">pid_t</span> id = waitpid(<span class="hljs-number">-1</span>, &amp;status, WNOHANG);<br>    <span class="hljs-keyword">if</span> (WIFEXITED(status))<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Removed proc id: %d \n&quot;</span>, id);             <span class="hljs-comment">//子进程的 pid</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Child send: %d \n&quot;</span>, WEXITSTATUS(status)); <span class="hljs-comment">//子进程的返回值</span><br>    &#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br>    <span class="hljs-type">pid_t</span> pid;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sigaction</span> <span class="hljs-title">act</span>;</span><br>    act.sa_handler = read_childproc;<br>    sigemptyset(&amp;act.sa_mask);<br>    act.sa_flags = <span class="hljs-number">0</span>;<br>    sigaction(SIGCHLD, &amp;act, <span class="hljs-number">0</span>);<br><br>    pid = fork();<br>    <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>) <span class="hljs-comment">//子进程执行阶段</span><br>    &#123;<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Hi I&#x27;m child process&quot;</span>);<br>        sleep(<span class="hljs-number">10</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">12</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-comment">//父进程执行阶段</span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Child proc id: %d\n&quot;</span>, pid);<br>        pid = fork();<br>        <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Hi! I&#x27;m child process&quot;</span>);<br>            sleep(<span class="hljs-number">10</span>);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">24</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-type">int</span> i;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Child proc id: %d \n&quot;</span>, pid);<br>            <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)<br>            &#123;<br>                <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;wait&quot;</span>);<br>                sleep(<span class="hljs-number">5</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc remove_zomebie.c -o zombie<br>./zombie<br></code></pre></td></tr></table></figure><p>结果：</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs tcl">Child <span class="hljs-keyword">proc</span><span class="hljs-title"> id:</span> 11211<span class="hljs-title"></span><br><span class="hljs-title">Hi</span> I&#x27;m<span class="hljs-title"> child</span> process<span class="hljs-title"></span><br><span class="hljs-title">Child</span> <span class="hljs-keyword">proc</span><span class="hljs-title"> id:</span> 11212<span class="hljs-title"> </span><br><span class="hljs-title">wait</span><br>Hi!<span class="hljs-title"> I&#x27;m</span> child<span class="hljs-title"> process</span><br><span class="hljs-title"></span><br><span class="hljs-title">wait</span><br><span class="hljs-title"></span><br><span class="hljs-title">wait</span><br>Removed<span class="hljs-title"> proc</span> id: 11211<span class="hljs-title"> </span><br><span class="hljs-title">Child</span> send: 12<span class="hljs-title"> </span><br><span class="hljs-title">wait</span><br>Removed<span class="hljs-title"> proc</span> id: 11212<span class="hljs-title"> </span><br><span class="hljs-title">Child</span> send: 24<span class="hljs-title"> </span><br><span class="hljs-title">wait</span><br></code></pre></td></tr></table></figure><p>请自习观察结果，结果中的每一个空行代表间隔了5 秒，程序是先创建了两个子进程，然后子进程 10  秒之后会返回值，第一个 wait 由于子进程在执行，所以直接被唤醒，然后这两个子进程正在睡 10 秒，所以 5 秒之后第二个 wait 开始执行，又过了 5 秒，两个子进程同时被唤醒。所以剩下的 wait 也被唤醒。</p><p>所以在本程序的过程中，当子进程终止时候，会向系统发送一个信号，然后调用我们提前写好的处理函数，在处理函数中使用 waitpid 来处理僵尸进程，获取子进程返回值。</p><h3 id="10-4-基于多任务的并发服务器"><a href="#10-4-基于多任务的并发服务器" class="headerlink" title="10.4 基于多任务的并发服务器"></a>10.4 基于多任务的并发服务器</h3><h4 id="10-4-1-基于进程的并发服务器模型"><a href="#10-4-1-基于进程的并发服务器模型" class="headerlink" title="10.4.1 基于进程的并发服务器模型"></a>10.4.1 基于进程的并发服务器模型</h4><p>之前的回声服务器每次只能同时向 1 个客户端提供服务。因此，需要扩展回声服务器，使其可以同时向多个客户端提供服务。下图是基于多进程的回声服务器的模型。</p><p><img src="/.io//blog/blog/picture/5c453664cde26.png"></p><p>从图中可以看出，每当有客户端请求时（连接请求），回声服务器都创建子进程以提供服务。如果请求的客户端有 5 个，则将创建 5 个子进程来提供服务，为了完成这些任务，需要经过如下过程：</p><ul><li>第一阶段：回声服务器端（父进程）通过调用 accept 函数受理连接请求</li><li>第二阶段：此时获取的套接字文件描述符创建并传递给子进程</li><li>第三阶段：进程利用传递来的文件描述符提供服务</li></ul><h4 id="10-4-2-实现并发服务器"><a href="#10-4-2-实现并发服务器" class="headerlink" title="10.4.2 实现并发服务器"></a>10.4.2 实现并发服务器</h4><p>下面是基于多进程实现的并发的回声服务器的服务端，可以结合第四章的 <a href="https://github.com/riba2534/TCP-IP-NetworkNote/blob/master/ch04/echo_client.c">echo_client.c</a> 回声客户端来运行。</p><ul><li><a href="https://github.com/riba2534/TCP-IP-NetworkNote/blob/master/ch10/echo_mpserv.c">echo_mpserv.c</a></li></ul><p>编译运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc echo_mpserv.c -o eserver<br>./eserver<br></code></pre></td></tr></table></figure><p>结果：</p><p>和第四章的几乎一样，可以自己测试，此时的服务端支持同时给多个客户端进行服务，每有一个客户端连接服务端，就会多开一个子进程，所以可以同时提供服务。</p><h4 id="10-4-3-通过-fork-函数复制文件描述符"><a href="#10-4-3-通过-fork-函数复制文件描述符" class="headerlink" title="10.4.3 通过 fork 函数复制文件描述符"></a>10.4.3 通过 fork 函数复制文件描述符</h4><p>示例中给出了通过 fork 函数复制文件描述符的过程。父进程将 2 个套接字（一个是服务端套接字另一个是客户端套接字）文件描述符复制给了子进程。</p><p>调用 fork 函数时复制父进程的所有资源，但是套接字不是归进程所有的，而是归操作系统所有，只是进程拥有代表相应套接字的文件描述符。</p><p><img src="https://s2.ax1x.com/2019/01/21/kP7Rjx.png"></p><p>如图所示，1 个套接字存在 2 个文件描述符时，只有 2 个文件描述符都终止（销毁）后，才能销毁套接字。如果维持图中的状态，即使子进程销毁了与客户端连接的套接字文件描述符，也无法销毁套接字（服务器套接字同样如此）。因此调用 fork 函数候，要将无关紧要的套接字文件描述符关掉，如图所示：</p><p><img src="https://s2.ax1x.com/2019/01/21/kPH7ZT.png"></p><h3 id="10-5-分割-TCP-的-I-O-程序"><a href="#10-5-分割-TCP-的-I-O-程序" class="headerlink" title="10.5 分割 TCP 的 I&#x2F;O 程序"></a>10.5 分割 TCP 的 I&#x2F;O 程序</h3><h4 id="10-5-1-分割-I-O-的优点"><a href="#10-5-1-分割-I-O-的优点" class="headerlink" title="10.5.1 分割 I&#x2F;O 的优点"></a>10.5.1 分割 I&#x2F;O 的优点</h4><p>我们已经实现的回声客户端的数据回声方式如下：</p><blockquote><p>向服务器传输数据，并等待服务器端回复。无条件等待，直到接收完服务器端的回声数据后，才能传输下一批数据。</p></blockquote><p>传输数据后要等待服务器端返回的数据，因为程序代码中重复调用了 read 和 write 函数。只能这么写的原因之一是，程序在 1 个进程中运行，现在可以创建多个进程，因此可以分割数据收发过程。默认分割过程如下图所示：</p><p><img src="https://s2.ax1x.com/2019/01/21/kPbhkD.png"></p><p>从图中可以看出，客户端的父进程负责接收数据，额外创建的子进程负责发送数据，分割后，不同进程分别负责输入输出，这样，无论客户端是否从服务器端接收完数据都可以进程传输。</p><p>分割 I&#x2F;O 程序的另外一个好处是，可以提高频繁交换数据的程序性能，图下图所示：</p><p><img src="https://s2.ax1x.com/2019/01/21/kPbvtg.png"></p><p>根据上图显示可以看出，再网络不好的情况下，明显提升速度。</p><h4 id="10-5-2-回声客户端的-I-O-程序分割"><a href="#10-5-2-回声客户端的-I-O-程序分割" class="headerlink" title="10.5.2 回声客户端的 I&#x2F;O 程序分割"></a>10.5.2 回声客户端的 I&#x2F;O 程序分割</h4><p>下面是回声客户端的 I&#x2F;O 分割的代码实现：</p><ul><li><a href="https://github.com/riba2534/TCP-IP-NetworkNote/blob/master/ch10/echo_mpclient.c">echo_mpclient.c</a></li></ul><p>可以配合刚才的并发服务器进行执行。</p><p>编译运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc echo_mpclient.c -o eclient<br>./eclient 127.0.0.1 9190<br></code></pre></td></tr></table></figure><p>结果：</p><p><img src="https://s2.ax1x.com/2019/01/21/kPOcXn.png"></p><p>可以看出，基本和以前的一样，但是里面的内部结构却发生了很大的变化</p><h3 id="10-6-习题"><a href="#10-6-习题" class="headerlink" title="10.6 习题"></a>10.6 习题</h3><blockquote><p>以下答案仅代表本人个人观点，可能不是正确答案。</p></blockquote><ol><li><p><strong>下列关于进程的说法错误的是？</strong></p><p>答：以下加粗的内容为正确的</p><ol><li><strong>从操作系统的角度上说，进程是程序运行的单位</strong></li><li>进程根据创建方式建立父子关系</li><li><strong>进程可以包含其他进程，即一个进程的内存空间可以包含其他进程</strong></li><li><strong>子进程可以创建其他子进程，而创建出来的子进程还可以创建其他子进程，但所有这些进程只与一个父进程建立父子关系。</strong></li></ol></li><li><p><strong>调用 fork 函数将创建子进程，一下关于子进程错误的是？</strong></p><p>答：以下加粗的内容为正确的</p><ol><li><strong>父进程销毁时也会同时销毁子进程</strong></li><li><strong>子进程是复制父进程所有资源创建出的进程</strong></li><li>父子进程共享全局变量</li><li>通过 fork 函数创建的子进程将执行从开始到 fork 函数调用为止的代码。</li></ol></li><li><p><strong>创建子进程时复制父进程所有内容，此时复制对象也包含套接字文件描述符。编写程序验证复制的文件描述符整数值是否与原文件描述符数值相同。</strong></p><p>答：代码为多进程服务器修改而来，代码：<a href="https://github.com/riba2534/TCP-IP-NetworkNote/blob/master/ch10/test_server.c">test_server.c</a></p><p>运行截图：</p><p><img src="https://s2.ax1x.com/2019/01/21/kPj3Md.png"></p><p>从图上可以看出，数值相同。</p></li><li><p><strong>请说明进程变为僵尸进程的过程以及预防措施。</strong></p><p>答：当一个父进程以fork()系统调用建立一个新的子进程后，核心进程就会在进程表中给这个子进程分配一个进入点，然后将相关信息存储在该进入点所对应的进程表内。这些信息中有一项是其父进程的识别码。而当这个子进程结束的时候（比如调用exit命令结束），其实他并没有真正的被销毁，而是留下一个称为僵尸进程（Zombie）的数据结构（系统调用exit的作用是使进程退出，但是也仅仅限于一个正常的进程变成了一个僵尸进程，并不能完全将其销毁）。<strong>预防措施</strong>：通过 wait 和 waitpid 函数加上信号函数写代码来预防。</p></li></ol><h2 id="第-11-章-进程间通信"><a href="#第-11-章-进程间通信" class="headerlink" title="第 11 章 进程间通信"></a>第 11 章 进程间通信</h2><p>本章代码，在<a href="https://github.com/riba2534/TCP-IP-NetworkNote">TCP-IP-NetworkNote</a>中可以找到。</p><p>进程间通信，意味着两个不同的进程中可以交换数据</p><h3 id="11-1-进程间通信的基本概念"><a href="#11-1-进程间通信的基本概念" class="headerlink" title="11.1 进程间通信的基本概念"></a>11.1 进程间通信的基本概念</h3><h4 id="11-1-1-通过管道实现进程间通信"><a href="#11-1-1-通过管道实现进程间通信" class="headerlink" title="11.1.1 通过管道实现进程间通信"></a>11.1.1 通过管道实现进程间通信</h4><p>下图是基于管道（PIPE）的进程间通信的模型：</p><p><img src="https://s2.ax1x.com/2019/01/22/kFlk0s.png"></p><p>可以看出，为了完成进程间通信，需要创建进程。管道并非属于进程的资源，而是和套接字一样，属于操作系统（也就不是 fork 函数的复制对象）。所以，两个进程通过操作系统提供的内存空间进行通信。下面是创建管道的函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">pipe</span><span class="hljs-params">(<span class="hljs-type">int</span> filedes[<span class="hljs-number">2</span>])</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">成功时返回 0 ，失败时返回 -1</span><br><span class="hljs-comment">filedes[0]: 通过管道接收数据时使用的文件描述符，即管道出口</span><br><span class="hljs-comment">filedes[1]: 通过管道传输数据时使用的文件描述符，即管道入口</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>父进程创建函数时将创建管道，同时获取对应于出入口的文件描述符，此时父进程可以读写同一管道。但父进程的目的是与子进程进行数据交换，因此需要将入口或出口中的 1 个文件描述符传递给子进程。下面的例子是关于该函数的使用方法：</p><ul><li><a href="https://github.com/riba2534/TCP-IP-NetworkNote/blob/master/ch11/pipe1.c">pipe1.c</a></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BUF_SIZE 30</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br>    <span class="hljs-type">int</span> fds[<span class="hljs-number">2</span>];<br>    <span class="hljs-type">char</span> str[] = <span class="hljs-string">&quot;Who are you?&quot;</span>;<br>    <span class="hljs-type">char</span> buf[BUF_SIZE];<br>    <span class="hljs-type">pid_t</span> pid;<br>    <span class="hljs-comment">// 调用  pipe 函数创建管道，fds 数组中保存用于 I/O 的文件描述符</span><br>    pipe(fds);<br>    pid = fork(); <span class="hljs-comment">//子进程将同时拥有创建管道获取的2个文件描述符，复制的并非管道，而是文件描述符</span><br>    <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>)<br>    &#123;<br>        write(fds[<span class="hljs-number">1</span>], str, <span class="hljs-keyword">sizeof</span>(str));<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        read(fds[<span class="hljs-number">0</span>], buf, BUF_SIZE);<br>        <span class="hljs-built_in">puts</span>(buf);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc pipe1.c -o pipe1<br>./pipe1<br></code></pre></td></tr></table></figure><p>结果：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">Who <span class="hljs-keyword">are</span> you?<br></code></pre></td></tr></table></figure><p>可以从程序中看出，首先创建了一个管道，子进程通过 fds[1] 把数据写入管道，父进程从 fds[0] 再把数据读出来。可以从下图看出：</p><p><img src="https://s2.ax1x.com/2019/01/22/kF8A7d.png"></p><h4 id="11-1-2-通过管道进行进程间双向通信"><a href="#11-1-2-通过管道进行进程间双向通信" class="headerlink" title="11.1.2 通过管道进行进程间双向通信"></a>11.1.2 通过管道进行进程间双向通信</h4><p>下图可以看出双向通信模型：</p><p><img src="https://s2.ax1x.com/2019/01/22/kF84De.png"></p><p>下面是双向通信的示例：</p><ul><li><a href="https://github.com/riba2534/TCP-IP-NetworkNote/blob/master/ch11/pipe2.c">pipe2.c</a></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BUF_SIZE 30</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br>    <span class="hljs-type">int</span> fds[<span class="hljs-number">2</span>];<br>    <span class="hljs-type">char</span> str1[] = <span class="hljs-string">&quot;Who are you?&quot;</span>;<br>    <span class="hljs-type">char</span> str2[] = <span class="hljs-string">&quot;Thank you for your message&quot;</span>;<br>    <span class="hljs-type">char</span> buf[BUF_SIZE];<br>    <span class="hljs-type">pid_t</span> pid;<br><br>    pipe(fds);<br>    pid = fork();<br>    <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>)<br>    &#123;<br>        write(fds[<span class="hljs-number">1</span>], str1, <span class="hljs-keyword">sizeof</span>(str1));<br>        sleep(<span class="hljs-number">2</span>);<br>        read(fds[<span class="hljs-number">0</span>], buf, BUF_SIZE);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Child proc output: %s \n&quot;</span>, buf);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        read(fds[<span class="hljs-number">0</span>], buf, BUF_SIZE);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Parent proc output: %s \n&quot;</span>, buf);<br>        write(fds[<span class="hljs-number">1</span>], str2, <span class="hljs-keyword">sizeof</span>(str2));<br>        sleep(<span class="hljs-number">3</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>编译运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc pipe2.c -o pipe2<br>./pipe2<br></code></pre></td></tr></table></figure><p>结果：</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tcl">Parent <span class="hljs-keyword">proc</span><span class="hljs-title"> output:</span> Who<span class="hljs-title"> are</span> you?<span class="hljs-title"></span><br><span class="hljs-title">Child</span> <span class="hljs-keyword">proc</span><span class="hljs-title"> output:</span> Thank<span class="hljs-title"> you</span> for<span class="hljs-title"> your</span> message<br></code></pre></td></tr></table></figure><p>运行结果是正确的，但是如果注释掉第18行的代码，就会出现问题，导致一直等待下去。因为数据进入管道后变成了无主数据。也就是通过 read 函数先读取数据的进程将得到数据，即使该进程将数据传到了管道。因为，注释第18行会产生问题。第19行，自己成将读回自己在第 17 行向管道发送的数据。结果父进程调用 read 函数后，无限期等待数据进入管道。</p><p>当一个管道不满足需求时，就需要创建两个管道，各自负责不同的数据流动，过程如下图所示：</p><p><img src="https://s2.ax1x.com/2019/01/22/kFJW0e.png"></p><p>下面采用上述模型改进 <code>pipe2.c</code> 。</p><ul><li><a href="https://github.com/riba2534/TCP-IP-NetworkNote/blob/master/ch11/pipe3.c">pipe3.c</a></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BUF_SIZE 30</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br>    <span class="hljs-type">int</span> fds1[<span class="hljs-number">2</span>], fds2[<span class="hljs-number">2</span>];<br>    <span class="hljs-type">char</span> str1[] = <span class="hljs-string">&quot;Who are you?&quot;</span>;<br>    <span class="hljs-type">char</span> str2[] = <span class="hljs-string">&quot;Thank you for your message&quot;</span>;<br>    <span class="hljs-type">char</span> buf[BUF_SIZE];<br>    <span class="hljs-type">pid_t</span> pid;<br><br>    pipe(fds1), pipe(fds2);<br>    pid = fork();<br>    <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>)<br>    &#123;<br>        write(fds1[<span class="hljs-number">1</span>], str1, <span class="hljs-keyword">sizeof</span>(str1));<br>        read(fds2[<span class="hljs-number">0</span>], buf, BUF_SIZE);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Child proc output: %s \n&quot;</span>, buf);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        read(fds1[<span class="hljs-number">0</span>], buf, BUF_SIZE);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Parent proc output: %s \n&quot;</span>, buf);<br>        write(fds2[<span class="hljs-number">1</span>], str2, <span class="hljs-keyword">sizeof</span>(str2));<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面通过创建两个管道实现了功能，此时，不需要额外再使用 sleep 函数。运行结果和上面一样。</p><h3 id="11-2-运用进程间通信"><a href="#11-2-运用进程间通信" class="headerlink" title="11.2 运用进程间通信"></a>11.2 运用进程间通信</h3><h4 id="11-2-1-保存消息的回声服务器"><a href="#11-2-1-保存消息的回声服务器" class="headerlink" title="11.2.1 保存消息的回声服务器"></a>11.2.1 保存消息的回声服务器</h4><p>下面对第 10 章的 <a href="https://github.com/riba2534/TCP-IP-NetworkNote/blob/master/ch10/echo_mpserv.c">echo_mpserv.c</a> 进行改进，添加一个功能：</p><blockquote><p>将回声客户端传输的字符串按序保存到文件中</p></blockquote><p>实现该任务将创建一个新进程，从向客户端提供服务的进程读取字符串信息，下面是代码：</p><ul><li><a href="https://github.com/riba2534/TCP-IP-NetworkNote/blob/master/ch11/echo_storeserv.c">echo_storeserv.c</a></li></ul><p>编译运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc echo_storeserv.c -o serv<br>./serv 9190<br></code></pre></td></tr></table></figure><p>此服务端配合第 10 章的客户端 <a href="https://github.com/riba2534/TCP-IP-NetworkNote/blob/master/ch10/echo_mpclient.c">echo_mpclient.c</a> 使用，运行结果如下图:</p><p><img src="https://s2.ax1x.com/2019/01/22/kFUCct.png"></p><p><img src="https://s2.ax1x.com/2019/01/22/kFUAHS.png"></p><p>从图上可以看出，服务端已经生成了文件，把客户端的消息保存可下来，只保存了10次消息。</p><h3 id="11-3-习题"><a href="#11-3-习题" class="headerlink" title="11.3 习题"></a>11.3 习题</h3><blockquote><p>以下答案仅代表本人个人观点，可能不是正确答案。</p></blockquote><ol><li><p><strong>什么是进程间通信？分别从概念和内存的角度进行说明。</strong></p><p>答：进程间通信意味着两个不同的进程间可以交换数据。从内存上来说，就是两个进程可以访问同一个内存区域，然后通过这个内存区域数据的变化来进行通信。</p></li><li><p><strong>进程间通信需要特殊的 IPC 机制，这是由于操作系统提供的。进程间通信时为何需要操作系统的帮助？</strong></p><p>答：为了进行进程间通信，需要管道的帮助，但是管道不是进程的资源，它属于从操作系统，所以，两个进程通过操作系统提供的内存空间进行通信。</p></li><li><p><strong>「管道」是典型的 IPC 技法。关于管道，请回答以下问题：</strong></p><ol><li><p><strong>管道是进程间交换数据的路径。如何创建此路径？由谁创建？</strong></p><p>答：使用 pipe 函数进行创建，由操作系统创建。父进程调用该函数时将创建管道。</p></li><li><p><strong>为了完成进程间通信。2 个进程要同时连接管道。那2 个进程如何连接到同一管道？</strong></p><p>答：数组中有两个文件描述符，父子进程调用相关函数时，通过 fork 函数，把 1 个文件描述符传递给子进程。</p></li><li><p><strong>管道允许 2 个进程间的双向通信。双向通信中需要注意哪些内容？</strong></p><p>答：向管道传输数据时，先读的进程会把数据取走。简言之，就是数据进入管道候会变成无主数据，所以有时候为了防止错误，需要多个管道来进程通信。</p></li></ol></li></ol><h2 id="第-12-章-I-O-复用"><a href="#第-12-章-I-O-复用" class="headerlink" title="第 12 章 I&#x2F;O 复用"></a>第 12 章 I&#x2F;O 复用</h2><p>本章代码，在<a href="https://github.com/riba2534/TCP-IP-NetworkNote">TCP-IP-NetworkNote</a>中可以找到。</p><h3 id="12-1-基于-I-O-复用的服务器端"><a href="#12-1-基于-I-O-复用的服务器端" class="headerlink" title="12.1 基于 I&#x2F;O 复用的服务器端"></a>12.1 基于 I&#x2F;O 复用的服务器端</h3><h4 id="12-1-1-多进程服务端的缺点和解决方法"><a href="#12-1-1-多进程服务端的缺点和解决方法" class="headerlink" title="12.1.1 多进程服务端的缺点和解决方法"></a>12.1.1 多进程服务端的缺点和解决方法</h4><p>为了构建并发服务器，只要有客户端连接请求就会创建新进程。这的确是实际操作中采用的一种方案，但并非十全十美，因为创建进程要付出很大的代价。这需要大量的运算和内存空间，由于每个进程都具有独立的内存空间，所以相互间的数据交换也要采用相对复杂的方法（IPC 属于相对复杂的通信方法）</p><p>I&#x2F;O 复用技术可以解决这个问题。</p><h4 id="12-1-2-理解复用"><a href="#12-1-2-理解复用" class="headerlink" title="12.1.2 理解复用"></a>12.1.2 理解复用</h4><p>「复用」在电子及通信工程领域很常见，向这些领域的专家询问其概念，可能会得到如下答复：</p><blockquote><p>在 1 个通信频道中传递多个数据（信号）的技术</p></blockquote><p>「复用」的含义：</p><blockquote><p>为了提高物理设备的效率，只用最少的物理要素传递最多数据时使用的技术</p></blockquote><p>上述两种方法的内容完全一致。可以用纸电话模型做一个类比：</p><p><img src="https://s2.ax1x.com/2019/01/23/kA8H81.png"></p><p>上图是一个纸杯电话系统，为了使得三人同时通话，说话时要同时对着两个纸杯，接听时也需要耳朵同时对准两个纸杯。为了完成 3 人通话，可以进行如下图的改进：</p><p><img src="https://s2.ax1x.com/2019/01/23/kA8bgx.png"></p><p>如图做出改进，就是引入了复用技术。</p><p>复用技术的优点：</p><ul><li>减少连线长度</li><li>减少纸杯个数</li></ul><p>即使减少了连线和纸杯的量仍然可以进行三人同时说话，但是如果碰到以下情况：</p><blockquote><p>「好像不能同时说话？」</p></blockquote><p>实际上，因为是在进行对话，所以很少发生同时说话的情况。也就是说，上述系统采用的是<strong>「时分复用」</strong>技术。因为说话人声频率不同，即使在同时说话也能进行一定程度上的区分（杂音也随之增多）。因此，也可以说是「频分复用技术」。</p><h4 id="12-1-3-复用技术在服务器端的应用"><a href="#12-1-3-复用技术在服务器端的应用" class="headerlink" title="12.1.3 复用技术在服务器端的应用"></a>12.1.3 复用技术在服务器端的应用</h4><p>纸杯电话系统引入复用技术之后可以减少纸杯数量和连线长度。服务器端引入复用技术可以减少所需进程数。下图是多进程服务端的模型：</p><p><img src="https://s2.ax1x.com/2019/01/23/kAGBM6.png"></p><p>下图是引入复用技术之后的模型：</p><p><img src="https://s2.ax1x.com/2019/01/23/kAGrqO.png"></p><p>从图上可以看出，引入复用技术之后，可以减少进程数。重要的是，无论连接多少客户端，提供服务的进程只有一个。</p><p><strong>知识补给站</strong>「关于复用服务器端的另一种理解」</p><blockquote><p>某教室中有10名学生和1位教师,这些孩子并非等闲之辈,上课时不停地提问。学校没办法,只能给毎个学生都配1位教师,也就是说教室中现有10位教师。此后,只要有新的转校生,就会增加1位教师,因为转校生也喜欢提问。这个故事中,如果把学生当作客户端,把教师当作与客户端进行数据交换的服务器端进程,则该教室的运营方式为多进程服务器端方式。<br>有一天,该校来了位具有超能力的教师。这位教师可以应对所有学生的提问,而且回答速度很快,不会让学生等待。因此,学校为了提高教师效率,将其他老师转移到了别的班。现在,学生提问前必须举手,教师确认举手学生的提问后再回答问题。也就是说,现在的教室以I&#x2F;O复用方式运行。<br>虽然例子有些奇怪,但可以通过它理解I&#x2F;O复用技法:教师必须确认有无举手学生<br>同样,I&#x2F;O复用服务器端的进程需要确认举手(收到数据)的套接字,并通过举手的套接字接收数据。</p></blockquote><h3 id="12-2-理解-select-函数并实现服务端"><a href="#12-2-理解-select-函数并实现服务端" class="headerlink" title="12.2 理解 select 函数并实现服务端"></a>12.2 理解 select 函数并实现服务端</h3><p>select 函数是最具代表性的实现复用服务器的方法。在 Windows 平台下也有同名函数，所以具有很好的移植性。</p><h4 id="12-2-1-select-函数的功能和调用顺序"><a href="#12-2-1-select-函数的功能和调用顺序" class="headerlink" title="12.2.1 select 函数的功能和调用顺序"></a>12.2.1 select 函数的功能和调用顺序</h4><p>使用 select 函数时可以将多个文件描述符集中到一起统一监视，项目如下：</p><ul><li>是否存在套接字接收数据？</li><li>无需阻塞传输数据的套接字有哪些？</li><li>哪些套接字发生了异常？</li></ul><blockquote><p>术语：「事件」。当发生监视项对应情况时，称「发生了事件」。</p></blockquote><p>select 函数的使用方法与一般函数的区别并不大，更准确的说，他很难使用。但是为了实现 I&#x2F;O 复用服务器端，我们应该掌握 select 函数，并运用于套接字编程当中。认为「select 函数是 I&#x2F;O 复用的全部内容」也并不为过。select 函数的调用过程如下图所示：</p><p><img src="https://s2.ax1x.com/2019/01/23/kAtdRs.png"></p><h4 id="12-2-2-设置文件描述符"><a href="#12-2-2-设置文件描述符" class="headerlink" title="12.2.2 设置文件描述符"></a>12.2.2 设置文件描述符</h4><p>利用 select 函数可以同时监视多个文件描述符。当然，监视文件描述符可以视为监视套接字。此时首先需要将要监视的文件描述符集中在一起。集中时也要按照监视项（接收、传输、异常）进行区分，即按照上述 3 种监视项分成 3 类。</p><p>利用 fd_set 数组变量执行此操作，如图所示，该数组是存有0和1的位数组。</p><p><img src="https://s2.ax1x.com/2019/01/23/kAt2i4.png"></p><p>图中最左端的位表示文件描述符 0（所在位置）。如果该位设置为 1，则表示该文件描述符是监视对象。那么图中哪些文件描述符是监视对象呢？很明显，是描述符 1 和 3。在 fd_set 变量中注册或更改值的操作都由下列宏完成。</p><ul><li><code>FD_ZERO(fd_set *fdset)</code>：将 fd_set 变量所指的位全部初始化成0</li><li><code>FD_SET(int fd,fd_set *fdset)</code>：在参数 fdset 指向的变量中注册文件描述符 fd 的信息</li><li><code>FD_SLR(int fd,fd_set *fdset)</code>：从参数 fdset 指向的变量中清除文件描述符 fd 的信息</li><li><code>FD_ISSET(int fd,fd_set *fdset)</code>：若参数 fdset 指向的变量中包含文件描述符 fd 的信息，则返回「真」</li></ul><p>上述函数中，FD_ISSET 用于验证 select 函数的调用结果，通过下图解释这些函数的功能：</p><p><img src="https://s2.ax1x.com/2019/01/23/kANR78.png"></p><h4 id="12-2-3-设置检查（监视）范围及超时"><a href="#12-2-3-设置检查（监视）范围及超时" class="headerlink" title="12.2.3 设置检查（监视）范围及超时"></a>12.2.3 设置检查（监视）范围及超时</h4><p>下面是 select 函数的定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/select.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/time.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">select</span><span class="hljs-params">(<span class="hljs-type">int</span> maxfd, fd_set *readset, fd_set *writeset,</span><br><span class="hljs-params">           fd_set *exceptset, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> timeval *timeout)</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">成功时返回大于 0 的值，失败时返回 -1</span><br><span class="hljs-comment">maxfd: 监视对象文件描述符数量</span><br><span class="hljs-comment">readset: 将所有关注「是否存在待读取数据」的文件描述符注册到 fd_set 型变量，并传递其地址值。</span><br><span class="hljs-comment">writeset: 将所有关注「是否可传输无阻塞数据」的文件描述符注册到 fd_set 型变量，并传递其地址值。</span><br><span class="hljs-comment">exceptset: 将所有关注「是否发生异常」的文件描述符注册到 fd_set 型变量，并传递其地址值。</span><br><span class="hljs-comment">timeout: 调用 select 函数后，为防止陷入无限阻塞的状态，传递超时(time-out)信息</span><br><span class="hljs-comment">返回值: 发生错误时返回 -1,超时时返回0,。因发生关注的事件返回时，返回大于0的值，该值是发生事件的文件描述符数。</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>如上所述，select 函数用来验证 3 种监视的变化情况，根据监视项声明 3 个 fd_set 型变量，分别向其注册文件描述符信息，并把变量的地址值传递到上述函数的第二到第四个参数。但在此之前（调用 select 函数之前）需要决定下面两件事：</p><ol><li>文件描述符的监视（检查）范围是？</li><li>如何设定 select 函数的超时时间？</li></ol><p>第一，文件描述符的监视范围和 select 的第一个参数有关。实际上，select 函数要求通过第一个参数传递监视对象文件描述符的数量。因此，需要得到注册在 fd_set 变量中的文件描述符数。但每次新建文件描述符时，其值就会增加 1 ，故只需将最大的文件描述符值加 1 再传递给 select 函数即可。加 1 是因为文件描述符的值是从 0 开始的。</p><p>第二，select 函数的超时时间与 select 函数的最后一个参数有关，其中 timeval 结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timeval</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">long</span> tv_sec;<br>    <span class="hljs-type">long</span> tv_usec;<br>&#125;;<br></code></pre></td></tr></table></figure><p>本来 select 函数只有在监视文件描述符发生变化时才返回。如果未发生变化，就会进入阻塞状态。指定超时时间就是为了防止这种情况的发生。通过上述结构体变量，将秒数填入 tv_sec 的成员，将微妙数填入 tv_usec 的成员，然后将结构体的地址值传递到 select 函数的最后一个参数。此时，即使文件描述符未发生变化，只要过了指定时间，也可以从函数中返回。不过这种情况下， select 函数返回 0 。因此，可以通过返回值了解原因。如果不向设置超时，则传递 NULL 参数。</p><h4 id="12-2-4-调用-select-函数查看结果"><a href="#12-2-4-调用-select-函数查看结果" class="headerlink" title="12.2.4 调用 select 函数查看结果"></a>12.2.4 调用 select 函数查看结果</h4><p>select 返回正整数时，怎样获知哪些文件描述符发生了变化？向 select 函数的第二到第四个参数传递的 fd_set 变量中将产生如图所示的变化：</p><p><img src="https://s2.ax1x.com/2019/01/23/kA06dx.png"></p><p>由图可知，select 函数调用完成候，向其传递的 fd_set 变量将发生变化。原来为 1 的所有位将变成 0，但是发生了变化的文件描述符除外。因此，可以认为值仍为 1 的位置上的文件描述符发生了变化。</p><h4 id="12-2-5-select-函数调用示例"><a href="#12-2-5-select-函数调用示例" class="headerlink" title="12.2.5 select 函数调用示例"></a>12.2.5 select 函数调用示例</h4><p>下面是一个 select 函数的例子：</p><ul><li><a href="https://github.com/riba2534/TCP-IP-NetworkNote/blob/master/ch12/select.c">select.c</a></li></ul><p>编译运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc select.c -o select<br>./select<br></code></pre></td></tr></table></figure><p>结果：</p><p><img src="https://s2.ax1x.com/2019/01/23/kAjgW6.png"></p><p>可以看出，如果运行后在标准输入流输入数据，就会在标准输出流输出数据，但是如果 5 秒没有输入数据，就提示超时。</p><h4 id="12-2-6-实现-I-O-复用服务器端"><a href="#12-2-6-实现-I-O-复用服务器端" class="headerlink" title="12.2.6 实现 I&#x2F;O 复用服务器端"></a>12.2.6 实现 I&#x2F;O 复用服务器端</h4><p>下面通过 select 函数实现 I&#x2F;O 复用服务器端。下面是基于 I&#x2F;O 复用的回声服务器端。</p><ul><li><a href="https://github.com/riba2534/TCP-IP-NetworkNote/blob/master/ch12/echo_selectserv.c">echo_selectserv.c</a></li></ul><p>编译运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc echo_selectserv.c -o selserv<br>./selserv 9190<br></code></pre></td></tr></table></figure><p>结果：</p><p><img src="https://s2.ax1x.com/2019/01/23/kEkV8H.png"></p><p>从图上可以看出，虽然只用了一个进程，但是却实现了可以和多个客户端进行通信，这都是利用了 select 的特点。</p><h3 id="12-3-基于-Windows-的实现"><a href="#12-3-基于-Windows-的实现" class="headerlink" title="12.3 基于 Windows 的实现"></a>12.3 基于 Windows 的实现</h3><p>暂略</p><h3 id="12-4-习题"><a href="#12-4-习题" class="headerlink" title="12.4 习题"></a>12.4 习题</h3><blockquote><p>以下答案仅代表本人个人观点，可能不是正确答案。</p></blockquote><ol><li><p><strong>请解释复用技术的通用含义，并说明何为 I&#x2F;O 复用。</strong></p><p>答：通用含义：在 1 个通信频道中传递多个数据（信号）的技术。IO复用就是进程预先告诉内核需要监视的IO条件，使得内核一旦发现进程指定的一个或多个IO条件就绪，就通过进程进程处理，从而不会在单个IO上阻塞了。</p><p>参考文章：<a href="https://www.cnblogs.com/luoxn28/p/6220372.html">Linux网络编程-IO复用技术</a></p></li><li><p><strong>多进程并发服务器的缺点有哪些？如何在 I&#x2F;O 复用服务器中弥补？</strong></p><p>答：多进程需要进行大量的运算和大量的内存空间。在 I&#x2F;O 复用服务器中通过 select 函数监视文件描述符，通过判断变化的文件描述符，来得知变化的套接字是哪个，从而实时应答来自多个客户端的请求。</p></li><li><p><strong>复用服务器端需要 select 函数。下列关于 select  函数使用方法的描述错误的是？</strong></p><p>答：以下加粗的为正确的描述。</p><ol><li>调用 select 函数前需要集中 I&#x2F;O 监视对象的文件描述符</li><li><strong>若已通过 select 函数注册为监视对象，则后续调用 select 函数时无需重复注册</strong></li><li>复用服务器端同一时间只能服务于 1 个客户端，因此，需要服务的客户端接入服务器端后只能等待</li><li><strong>与多进程服务端不同，基于 select 的复用服务器只需要 1 个进程。因此，可以减少因创建多进程产生的服务器端的负担</strong>。</li></ol></li><li><p><strong>select 函数的观察对象中应包含服务端套接字（监听套接字），那么应将其包含到哪一类监听对象集合？请说明原因</strong>。</p><p>答：应该包含到「是否存在待读取数据」，因为服务器端需要查看套接字中有没有可以读取的数据。</p></li></ol><h2 id="第-13-章-多种-I-O-函数"><a href="#第-13-章-多种-I-O-函数" class="headerlink" title="第 13 章 多种 I&#x2F;O 函数"></a>第 13 章 多种 I&#x2F;O 函数</h2><p>本章代码，在<a href="https://github.com/riba2534/TCP-IP-NetworkNote">TCP-IP-NetworkNote</a>中可以找到。</p><h3 id="13-1-send-recv-函数"><a href="#13-1-send-recv-函数" class="headerlink" title="13.1 send &amp; recv 函数"></a>13.1 send &amp; recv 函数</h3><h4 id="13-1-1-Linux-中的-send-recv"><a href="#13-1-1-Linux-中的-send-recv" class="headerlink" title="13.1.1 Linux 中的 send &amp; recv"></a>13.1.1 Linux 中的 send &amp; recv</h4><p>首先看 send 函数定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">send</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> nbytes, <span class="hljs-type">int</span> flags)</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">成功时返回发送的字节数，失败时返回 -1</span><br><span class="hljs-comment">sockfd: 表示与数据传输对象的连接的套接字和文件描述符</span><br><span class="hljs-comment">buf: 保存带传输数据的缓冲地址值</span><br><span class="hljs-comment">nbytes: 待传输字节数</span><br><span class="hljs-comment">flags: 传输数据时指定的可选项信息</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>下面是 recv 函数的定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">recv</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> nbytes, <span class="hljs-type">int</span> flags)</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">成功时返回接收的字节数（收到 EOF 返回 0），失败时返回 -1</span><br><span class="hljs-comment">sockfd: 表示数据接受对象的连接的套接字文件描述符</span><br><span class="hljs-comment">buf: 保存接受数据的缓冲地址值</span><br><span class="hljs-comment">nbytes: 可接收的最大字节数</span><br><span class="hljs-comment">flags: 接收数据时指定的可选项参数</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>send 和 recv 函数都是最后一个参数是收发数据的可选项，该选项可以用位或（bit OR）运算符（| 运算符）同时传递多个信息。</p><p>send &amp; recv 函数的可选项意义：</p><table><thead><tr><th>可选项（Option）</th><th>含义</th><th>send</th><th>recv</th></tr></thead><tbody><tr><td>MSG_OOB</td><td>用于传输带外数据（Out-of-band data）</td><td>O</td><td>O</td></tr><tr><td>MSG_PEEK</td><td>验证输入缓冲中是否存在接受的数据</td><td>X</td><td>O</td></tr><tr><td>MSG_DONTROUTE</td><td>数据传输过程中不参照本地路由（Routing）表，在本地（Local）网络中寻找目的地</td><td>O</td><td>X</td></tr><tr><td>MSG_DONTWAIT</td><td>调用 I&#x2F;O 函数时不阻塞，用于使用非阻塞（Non-blocking）I&#x2F;O</td><td>O</td><td>O</td></tr><tr><td>MSG_WAITALL</td><td>防止函数返回，直到接收到全部请求的字节数</td><td>X</td><td>O</td></tr></tbody></table><h4 id="13-1-2-MSG-OOB：发送紧急消息"><a href="#13-1-2-MSG-OOB：发送紧急消息" class="headerlink" title="13.1.2 MSG_OOB：发送紧急消息"></a>13.1.2 MSG_OOB：发送紧急消息</h4><p>MSG_OOB 可选项用于创建特殊发送方法和通道以发送紧急消息。下面为 MSG_OOB 的示例代码：</p><ul><li><a href="https://github.com/riba2534/TCP-IP-NetworkNote/blob/master/ch13/oob_recv.c">oob_recv.c</a></li><li><a href="https://github.com/riba2534/TCP-IP-NetworkNote/blob/master/ch13/oob_send.c">oob_send.c</a></li></ul><p>编译运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc oob_send.c -o send<br>gcc oob_recv.c -o recv<br></code></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/.io//blog/blog/picture/5c4bda167ae08.png"></p><p><img src="/.io//blog/blog/picture/5c4bdb4d99823.png"></p><p>从运行结果可以看出，send 是客户端，recv 是服务端，客户端给服务端发送消息，服务端接收完消息之后显示出来。可以从图中看出，每次运行的效果，并不是一样的。</p><p>代码中关于:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">fcntl(recv_sock, F_SETOWN, getpid());<br></code></pre></td></tr></table></figure><p>的意思是：</p><blockquote><p>文件描述符 recv_sock 指向的套接字引发的 SIGURG 信号处理进程变为 getpid 函数返回值用作 ID 进程.</p></blockquote><p>上述描述中的「处理 SIGURG 信号」指的是「调用 SIGURG 信号处理函数」。但是之前讲过，多个进程可以拥有 1 个套接字的文件描述符。例如，通过调用 fork 函数创建子进程并同时复制文件描述符。此时如果发生 SIGURG 信号，应该调用哪个进程的信号处理函数呢？可以肯定的是，不会调用所有进程的信号处理函数。因此，处理 SIGURG 信号时必须指定处理信号所用的进程，而 getpid 返回的是调用此函数的进程 ID 。上述调用语句指当前为处理 SIGURG 信号的主体。</p><p>输出结果，可能出乎意料：</p><blockquote><p>通过 MSG_OOB 可选项传递数据时只返回 1 个字节，而且也不快</p></blockquote><p>的确，通过 MSG_OOB 并不会加快传输速度，而通过信号处理函数 urg_handler 也只能读取一个字节。剩余数据只能通过未设置 MSG_OOB 可选项的普通输入函数读取。因为 TCP 不存在真正意义上的「外带数据」。实际上，MSG_OOB 中的 OOB 指的是 Out-of-band ，而「外带数据」的含义是：</p><blockquote><p>通过去完全不同的通信路径传输的数据</p></blockquote><p>即真正意义上的 Out-of-band 需要通过单独的通信路径高速传输数据，但是 TCP 不另外提供，只利用 TCP 的紧急模式（Urgent mode）进行传输。</p><h4 id="13-1-3-紧急模式工作原理"><a href="#13-1-3-紧急模式工作原理" class="headerlink" title="13.1.3 紧急模式工作原理"></a>13.1.3 紧急模式工作原理</h4><p>MSG_OOB 的真正意义在于督促数据接收对象尽快处理数据。这是紧急模式的全部内容，而 TCP 「保持传输顺序」的传输特性依然成立。TCP 的紧急消息无法保证及时到达，但是可以要求急救。下面是 MSG_OOB 可选项状态下的数据传输过程，如图：</p><p><img src="/.io//blog/blog/picture/5c4be222845cc.png"></p><p>上面是:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">send(sock, <span class="hljs-string">&quot;890&quot;</span>, <span class="hljs-built_in">strlen</span>(<span class="hljs-string">&quot;890&quot;</span>), MSG_OOB);<br></code></pre></td></tr></table></figure><p>图上是调用这个函数的缓冲状态。如果缓冲最左端的位置视作偏移量 0 。字符 0 保存于偏移量 2 的位置。另外，字符 0 右侧偏移量为 3 的位置存有紧急指针（Urgent Pointer）。紧急指针指向紧急消息的下一个位置（偏移量加一），同时向对方主机传递一下信息：</p><blockquote><p>紧急指针指向的偏移量为 3 之前的部分就是紧急消息。</p></blockquote><p>也就是说，实际上只用了一个字节表示紧急消息。这一点可以通过图中用于传输数据的 TCP 数据包（段）的结构看得更清楚，如图：</p><p><img src="/.io//blog/blog/picture/5c4beeae46b4e.png"></p><p>TCP 数据包实际包含更多信息。TCP 头部包含如下两种信息：</p><ul><li>URG&#x3D;1：载有紧急消息的数据包</li><li>URG指针：紧急指针位于偏移量为 3 的位置。</li></ul><p>指定 MSG_OOB 选项的数据包本身就是紧急数据包，并通过紧急指针表示紧急消息所在的位置。</p><p>如前所述,除紧急指针的前面1个字节外,数据接收方将通过调用常用输入函数读取剩余部分。<br>换言之,<strong>紧急消息的意义在于督促消息处理,而非紧急传输形式受限的消息</strong>。</p><h4 id="13-1-4-检查输入缓冲"><a href="#13-1-4-检查输入缓冲" class="headerlink" title="13.1.4 检查输入缓冲"></a>13.1.4 检查输入缓冲</h4><p>同时设置 MSG_PEEK 选项和 MSG_DONTWAIT 选项，以验证输入缓冲是否存在接收的数据。设置 MSG_PEEK 选项并调用 recv 函数时，即使读取了输入缓冲的数据也不会删除。因此，该选项通常与 MSG_DONTWAIT 合作，用于调用以非阻塞方式验证待读数据存与否的函数。下面的示例是二者的含义：</p><ul><li><a href="https://github.com/riba2534/TCP-IP-NetworkNote/blob/master/ch13/peek_recv.c">peek_recv.c</a></li><li><a href="https://github.com/riba2534/TCP-IP-NetworkNote/blob/master/ch13/peek_send.c">peek_send.c</a></li></ul><p>编译运行：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs perl">gcc peek_recv.c -o <span class="hljs-keyword">recv</span><br>gcc peek_send.c -o <span class="hljs-keyword">send</span><br>./<span class="hljs-keyword">recv</span> <span class="hljs-number">9190</span><br>./<span class="hljs-keyword">send</span> <span class="hljs-number">127.0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span> <span class="hljs-number">9190</span><br></code></pre></td></tr></table></figure><p>结果：</p><p><img src="/.io//blog/blog/picture/5c4c0d1dc83af.png"></p><p>可以通过结果验证，仅发送了一次的数据被读取了 2 次，因为第一次调用 recv 函数时设置了 MSG_PEEK 可选项。</p><h3 id="13-2-readv-writev-函数"><a href="#13-2-readv-writev-函数" class="headerlink" title="13.2 readv &amp; writev 函数"></a>13.2 readv &amp; writev 函数</h3><h4 id="13-2-1-使用-readv-writev-函数"><a href="#13-2-1-使用-readv-writev-函数" class="headerlink" title="13.2.1 使用 readv &amp; writev 函数"></a>13.2.1 使用 readv &amp; writev 函数</h4><p>readv &amp; writev 函数的功能可概括如下：</p><blockquote><p>对数据进行整合传输及发送的函数</p></blockquote><p>也就是说，通过 writev 函数可以将分散保存在多个缓冲中的数据一并发送，通过 readv 函数可以由多个缓冲分别接收。因此，适用这 2 个函数可以减少 I&#x2F;O 函数的调用次数。下面先介绍 writev 函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/uio.h&gt;</span></span><br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">writev</span><span class="hljs-params">(<span class="hljs-type">int</span> filedes, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> iovec *iov, <span class="hljs-type">int</span> iovcnt)</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">成功时返回发送的字节数，失败时返回 -1</span><br><span class="hljs-comment">filedes: 表示数据传输对象的套接字文件描述符。但该函数并不仅限于套接字，因此，可以像 read 一样向向其传递文件或标准输出描述符.</span><br><span class="hljs-comment">iov: iovec 结构体数组的地址值，结构体 iovec 中包含待发送数据的位置和大小信息</span><br><span class="hljs-comment">iovcnt: 向第二个参数传递数组长度</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>上述第二个参数中出现的数组 iovec 结构体的声明如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">iovec</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">void</span> *iov_base; <span class="hljs-comment">//缓冲地址</span><br>    <span class="hljs-type">size_t</span> iov_len; <span class="hljs-comment">//缓冲大小</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>下图是该函数的使用方法：</p><p><img src="/.io//blog/blog/picture/5c4c61b07d207.png"></p><p>writev 的第一个参数，是文件描述符，因此向控制台输出数据，ptr 是存有待发送数据信息的 iovec 数组指针。第三个参数为 2，因此，从 ptr 指向的地址开始，共浏览 2 个 iovec 结构体变量，发送这些指针指向的缓冲数据。<br><code>例如</code>ptr<a href="%E6%95%B0%E7%BB%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0">0</a>的 iov_base指向以A开头的字符串,同时 iov_len为3,故发送ABC。<br>而ptr<a href="%E6%95%B0%E7%BB%84%E7%9A%84%E7%AC%AC%E4%BA%8C%E4%B8%AA%E5%85%83%E7%B4%A0">1</a>的iov_base指向数字1,同时 iov_len为4,故发送1234。</p><p>下面是 writev 函数的使用方法：</p><ul><li><a href="https://github.com/riba2534/TCP-IP-NetworkNote/blob/master/ch13/writev.c">writev.c</a></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/uio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">iovec</span> <span class="hljs-title">vec</span>[2];</span><br>    <span class="hljs-type">char</span> buf1[] = <span class="hljs-string">&quot;ABCDEFG&quot;</span>;<br>    <span class="hljs-type">char</span> buf2[] = <span class="hljs-string">&quot;1234567&quot;</span>;<br>    <span class="hljs-type">int</span> str_len;<br><br>    vec[<span class="hljs-number">0</span>].iov_base = buf1;<br>    vec[<span class="hljs-number">0</span>].iov_len = <span class="hljs-number">3</span>;<br>    vec[<span class="hljs-number">1</span>].iov_base = buf2;<br>    vec[<span class="hljs-number">1</span>].iov_len = <span class="hljs-number">4</span>;<br><br>    str_len = writev(<span class="hljs-number">1</span>, vec, <span class="hljs-number">2</span>);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Write bytes: %d \n&quot;</span>, str_len);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc writev.c -o writev<br>./writevi<br></code></pre></td></tr></table></figure><p>结果：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">ABC1234</span><br><span class="hljs-attribute">Write</span> bytes: <span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><p>下面介绍 readv 函数，功能和 writev 函数正好相反.函数为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/uio.h&gt;</span></span><br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">readv</span><span class="hljs-params">(<span class="hljs-type">int</span> filedes, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> iovc *iov, <span class="hljs-type">int</span> iovcnt)</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">成功时返回接收的字节数，失败时返回 -1</span><br><span class="hljs-comment">filedes: 表示数据传输对象的套接字文件描述符。但该函数并不仅限于套接字，因此，可以像 read 一样向向其传递文件或标准输出描述符.</span><br><span class="hljs-comment">iov: iovec 结构体数组的地址值，结构体 iovec 中包含待发送数据的位置和大小信息</span><br><span class="hljs-comment">iovcnt: 向第二个参数传递数组长度</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>下面是示例代码：</p><ul><li><a href="https://github.com/riba2534/TCP-IP-NetworkNote/blob/master/ch13/readv.c">readv.c</a></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/uio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BUF_SIZE 100</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">iovec</span> <span class="hljs-title">vec</span>[2];</span><br>    <span class="hljs-type">char</span> buf1[BUF_SIZE] = &#123;<br>        <span class="hljs-number">0</span>,<br>    &#125;;<br>    <span class="hljs-type">char</span> buf2[BUF_SIZE] = &#123;<br>        <span class="hljs-number">0</span>,<br>    &#125;;<br>    <span class="hljs-type">int</span> str_len;<br><br>    vec[<span class="hljs-number">0</span>].iov_base = buf1;<br>    vec[<span class="hljs-number">0</span>].iov_len = <span class="hljs-number">5</span>;<br>    vec[<span class="hljs-number">1</span>].iov_base = buf2;<br>    vec[<span class="hljs-number">1</span>].iov_len = BUF_SIZE;<br><br>    str_len = readv(<span class="hljs-number">0</span>, vec, <span class="hljs-number">2</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Read bytes: %d \n&quot;</span>, str_len);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;First message: %s \n&quot;</span>, buf1);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Second message: %s \n&quot;</span>, buf2);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>编译运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc readv.c -o rv<br>./rv<br></code></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/.io//blog/blog/picture/5c4c718555398.png"></p><p>从图上可以看出，首先截取了长度为 5 的数据输出，然后再输出剩下的。</p><h4 id="13-2-2-合理使用-readv-writev-函数"><a href="#13-2-2-合理使用-readv-writev-函数" class="headerlink" title="13.2.2 合理使用 readv &amp; writev 函数"></a>13.2.2 合理使用 readv &amp; writev 函数</h4><p>实际上，能使用该函数的所有情况都适用。例如，需要传输的数据分别位于不同缓冲（数组）时，需要多次调用 write 函数。此时可通过 1 次 writev 函数调用替代操作，当然会提高效率。同样，需要将输入缓冲中的数据读入不同位置时，可以不必多次调用 read 函数，而是利用 1 次 readv 函数就能大大提高效率。</p><p>其意义在于减少数据包个数。假设为了提高效率在服务器端明确禁用了 Nagle 算法。其实 writev 函数在不采用 Nagle 算法时更有价值，如图：</p><p><img src="/.io//blog/blog/picture/5c4c731323e19.png"></p><h3 id="13-3-基于-Windows-的实现"><a href="#13-3-基于-Windows-的实现" class="headerlink" title="13.3 基于 Windows 的实现"></a>13.3 基于 Windows 的实现</h3><p>暂略</p><h3 id="13-4-习题"><a href="#13-4-习题" class="headerlink" title="13.4 习题"></a>13.4 习题</h3><blockquote><p>以下答案仅代表本人个人观点，可能不是正确答案。</p></blockquote><ol><li><p><strong>下列关于 MSG_OOB 可选项的说法错误的是</strong>？</p><p>答：以下加粗的字体代表说法正确。</p><ol><li>MSG_OOB 指传输 Out-of-band 数据，是通过其他路径高速传输数据</li><li>MSG_OOB 指通过其他路径高速传输数据，因此 TCP 中设置该选项的数据先到达对方主机</li><li><strong>设置 MSG_OOB 是数据先到达对方主机后，以普通数据的形式和顺序读取。也就是说，只是提高了传输速度，接收方无法识别这一点</strong>。</li><li><strong>MSG_OOB 无法脱离 TCP 的默认数据传输方式，即使脱离了 MSG_OOB ，也会保持原有的传输顺序。该选项只用于要求接收方紧急处理</strong>。</li></ol></li><li><p><strong>利用 readv &amp; writev 函数收发数据有何优点？分别从函数调用次数和 I&#x2F;O 缓冲的角度给出说明</strong>。</p><p>答：需要传输的数据分别位于不同缓冲（数组）时，需要多次调用 write 函数。此时可通过 1 次 writev 函数调用替代操作，当然会提高效率。同样，需要将输入缓冲中的数据读入不同位置时，可以不必多次调用 read 函数，而是利用 1 次 readv 函数就能大大提高效率。</p></li><li><p><strong>通过 recv 函数验证输入缓冲中是否存在数据时（确认后立即返回时），如何设置 recv 函数最后一个参数中的可选项？分别说明各可选项的含义</strong>。</p><p>答：使用 MSG_PEEK 来验证输入缓冲中是否存在待接收的数据。各个可选项的意义参见上面对应章节的表格。</p></li></ol><h2 id="第-14-章-多播与广播"><a href="#第-14-章-多播与广播" class="headerlink" title="第 14 章 多播与广播"></a>第 14 章 多播与广播</h2><p>本章代码，在<a href="https://github.com/riba2534/TCP-IP-NetworkNote">TCP-IP-NetworkNote</a>中可以找到。</p><h3 id="14-1-多播"><a href="#14-1-多播" class="headerlink" title="14.1 多播"></a>14.1 多播</h3><p>多播（Multicast）方式的数据传输是基于 UDP 完成的。因此 ，与 UDP 服务器端&#x2F;客户端的实现方式非常接近。区别在于，UDP 数据传输以单一目标进行，而多播数据同时传递到加入（注册）特定组的大量主机。换言之，采用多播方式时，可以同时向多个主机传递数据。</p><h4 id="14-1-1-多播的数据传输方式以及流量方面的优点"><a href="#14-1-1-多播的数据传输方式以及流量方面的优点" class="headerlink" title="14.1.1 多播的数据传输方式以及流量方面的优点"></a>14.1.1 多播的数据传输方式以及流量方面的优点</h4><p>多播的数据传输特点可整理如下：</p><ul><li>多播服务器端针对特定多播组，只发送 1 次数据。</li><li>即使只发送 1 次数据，但该组内的所有客户端都会接收数据</li><li>多播组数可以在 IP 地址范围内任意增加</li></ul><p>多播组是 D 类IP地址（224.0.0.0~239.255.255.255），「加入多播组」可以理解为通过程序完成如下声明：</p><blockquote><p>在 D 类IP地址中，我希望接收发往目标 239.234.218.234 的多播数据</p></blockquote><p>多播是基于 UDP 完成的，也就是说，多播数据包的格式与 UDP 数据包相同。只是与一般的 UDP 数据包不同。向网络传递 1 个多播数据包时，路由器将复制该数据包并传递到多个主机。像这样，多播需要借助路由器完成。如图所示：</p><p><img src="/.io//blog/blog/picture/5c4d310daa6be.png"></p><p>若通过 TCP 或 UDP 向 1000 个主机发送文件，则共需要传递 1000 次。但是此时如果用多播网络传输文件，则只需要发送一次。这时由 1000 台主机构成的网络中的路由器负责复制文件并传递到主机。就因为这种特性，多播主要用于「多媒体数据实时传输」。</p><p>另外，理论上可以完成多播通信，但是不少路由器并不支持多播，或即便支持也因网络拥堵问题故意阻断多播。因此，为了在不支持多播的路由器中完成多播通信，也会使用隧道（Tunneling）技术。</p><h4 id="14-1-2-路由（Routing）和-TTL（Time-to-Live-生存时间），以及加入组的办法"><a href="#14-1-2-路由（Routing）和-TTL（Time-to-Live-生存时间），以及加入组的办法" class="headerlink" title="14.1.2 路由（Routing）和 TTL（Time to Live,生存时间），以及加入组的办法"></a>14.1.2 路由（Routing）和 TTL（Time to Live,生存时间），以及加入组的办法</h4><p>为了传递多播数据包，必须设置 TTL 。TTL 是 Time to Live的简写，是决定「数据包传递距离」的主要因素。TTL 用整数表示，并且每经过一个路由器就减一。TTL 变为 0 时，该数据包就无法再被传递，只能销毁。因此，TTL 的值设置过大将影响网络流量。当然，设置过小，也无法传递到目标。</p><p><img src="/.io//blog/blog/picture/5c4d3960001eb.png"></p><p>接下来是 TTL 的设置方法。TTL 是可以通过第九章的套接字可选项完成的。与设置 TTL 相关的协议层为 IPPROTO_IP ，选项名为 IP_MULTICAST_TTL。因此，可以用如下代码把 TTL 设置为 64</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> send_sock;<br><span class="hljs-type">int</span> time_live = <span class="hljs-number">64</span>;<br>...<br>send_sock=socket(PF_INET,SOCK_DGRAM,<span class="hljs-number">0</span>);<br>setsockopt(send_sock,IPPROTO_IP,IP_MULTICAST_TTL,(<span class="hljs-type">void</span>*)&amp;time_live,<span class="hljs-keyword">sizeof</span>(time_live);<br>...<br></code></pre></td></tr></table></figure><p>加入多播组也通过设置设置套接字可选项来完成。加入多播组相关的协议层为 IPPROTO_IP，选项名为 IP_ADD_MEMBERSHIP 。可通过如下代码加入多播组：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> recv_sock;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ip_mreq</span> <span class="hljs-title">join_adr</span>;</span><br>...<br>recv_sock=socket(PF_INET,SOCK_DGRAM,<span class="hljs-number">0</span>);<br>...<br>join_adr.imr_multiaddr.s_addr=<span class="hljs-string">&quot;多播组地址信息&quot;</span>;<br>join_adr.imr_interface.s_addr=<span class="hljs-string">&quot;加入多播组的主机地址信息&quot;</span>;<br>setsockopt(recv_sock,IPPROTO_IP,IP_ADD_MEMBERSHIP,(<span class="hljs-type">void</span>*)&amp;join_adr,<span class="hljs-keyword">sizeof</span>(time_live);<br>...<br></code></pre></td></tr></table></figure><p>下面是 ip_mreq 结构体的定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ip_mreq</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">in_addr</span> <span class="hljs-title">imr_multiaddr</span>;</span> <span class="hljs-comment">//写入加入组的IP地址</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">in_addr</span> <span class="hljs-title">imr_interface</span>;</span> <span class="hljs-comment">//加入该组的套接字所属主机的IP地址</span><br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="14-1-3-实现多播-Sender-和-Receiver"><a href="#14-1-3-实现多播-Sender-和-Receiver" class="headerlink" title="14.1.3 实现多播 Sender 和 Receiver"></a>14.1.3 实现多播 Sender 和 Receiver</h4><p>多播中用「发送者」（以下称为 Sender） 和「接收者」（以下称为 Receiver）替代服务器端和客户端。顾名思义，此处的 Sender 是多播数据的发送主体，Receiver 是需要多播组加入过程的数据接收主体。下面是示例，示例的运行场景如下：</p><ul><li>Sender : 向 AAA 组广播（Broadcasting）文件中保存的新闻信息</li><li>Receiver : 接收传递到 AAA 组的新闻信息。</li></ul><p>下面是两个代码：</p><ul><li><a href="https://github.com/riba2534/TCP-IP-NetworkNote/blob/master/ch14/news_sender.c">news_sender.c</a></li><li><a href="https://github.com/riba2534/TCP-IP-NetworkNote/blob/master/ch14/news_receiver.c">news_receiver.c</a></li></ul><p>编译运行：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">gcc</span> news_sender.c -o sender<br>gcc news_receiver.c -o receiver<br>./sender <span class="hljs-number">224.1.1.2</span> <span class="hljs-number">9190</span><br>./receiver <span class="hljs-number">224.1.1.2</span> <span class="hljs-number">9190</span><br></code></pre></td></tr></table></figure><p>结果：</p><p><img src="/.io//blog/blog/picture/5c4e85a9aabcc.png"></p><p>通过结果可以看出，使用 sender 多播信息，通过 receiver 接收广播，如果延迟运行 receiver 将无法接受之前发送的信息。</p><h3 id="14-2-广播"><a href="#14-2-广播" class="headerlink" title="14.2 广播"></a>14.2 广播</h3><p>广播（Broadcast）在「一次性向多个主机发送数据」这一点上与多播类似，但传输数据的范围有区别。多播即使在跨越不同网络的情况下，只要加入多播组就能接受数据。相反，广播只能向同一网络中的主机传输数据。</p><h4 id="14-2-1-广播的理解和实现方法"><a href="#14-2-1-广播的理解和实现方法" class="headerlink" title="14.2.1 广播的理解和实现方法"></a>14.2.1 广播的理解和实现方法</h4><p>广播是向同一网络中的所有主机传输数据的方法。与多播相同，广播也是通过 UDP 来完成的。根据传输数据时使用的IP地址形式，广播分为以下两种：</p><ul><li>直接广播（Directed Broadcast）</li><li>本地广播（Local Broadcast）</li></ul><p>二者在实现上的差别主要在于IP地址。直接广播的IP地址中除了网络地址外，其余主机地址全部设置成 1。例如，希望向网络地址 192.12.34 中的所有主机传输数据时，可以向 192.12.34.255 传输。换言之，可以采取直接广播的方式向特定区域内所有主机传输数据。</p><p>反之，本地广播中使用的IP地址限定为 255.255.255.255 。例如，192.32.24 网络中的主机向 255.255.255.255 传输数据时，数据将传输到 192.32.24 网络中所有主机。</p><p><strong>数据通信中使用的IP地址是与 UDP 示例的唯一区别。默认生成的套接字会阻止广播，因此，只需通过如下代码更改默认设置。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> send_sock;<br><span class="hljs-type">int</span> bcast;<br>...<br>send_sock=socket(PF_INET,SOCK_DGRAM,<span class="hljs-number">0</span>);<br>...<br>setsockopt(send_sock,SOL_SOCKET,SO_BROADCAST,(<span class="hljs-type">void</span>*)&amp;bcast,<span class="hljs-keyword">sizeof</span>(bcast));<br>...<br></code></pre></td></tr></table></figure><h3 id="14-2-2-实现广播数据的-Sender-和-Receiver"><a href="#14-2-2-实现广播数据的-Sender-和-Receiver" class="headerlink" title="14.2.2 实现广播数据的 Sender 和 Receiver"></a>14.2.2 实现广播数据的 Sender 和 Receiver</h3><p>下面是广播数据的 Sender 和 Receiver的代码：</p><ul><li><a href="https://github.com/riba2534/TCP-IP-NetworkNote/blob/master/ch14/news_sender_brd.c">news_sender_brd.c</a></li><li><a href="https://github.com/riba2534/TCP-IP-NetworkNote/blob/master/ch14/news_receiver_brd.c">news_receiver_brd.c</a></li></ul><p>编译运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">gcc news_receiver_brd.c -o receiver<br>gcc news_sender_brd.c -o sender<br>./sender 255.255.255.255 9190<br>./receiver 9190<br></code></pre></td></tr></table></figure><p>结果：</p><p><img src="/.io//blog/blog/picture/5c4e9113368dd.png"></p><h3 id="14-3-基于-Windows-的实现"><a href="#14-3-基于-Windows-的实现" class="headerlink" title="14.3 基于 Windows 的实现"></a>14.3 基于 Windows 的实现</h3><p>暂略</p><h3 id="14-4-习题"><a href="#14-4-习题" class="headerlink" title="14.4 习题"></a>14.4 习题</h3><blockquote><p>以下答案仅代表本人个人观点，可能不是正确答案。</p></blockquote><ol><li><p><strong>TTL 的含义是什么？请从路由器的角度说明较大的 TTL 值与较小的 TTL 值之间的区别及问题。</strong></p><p>答：TTL 是决定「数据包传递距离」的主要因素。TTL 每经过一个路由器就减一。TTL 变为 0 时，数据包就无法再被传递，只能销毁。因此，TTL设置过大会影响网络流量。当然，设置过小无法传递到目标。</p></li><li><p><strong>多播与广播的异同点是什么？请从数据通信的角度进行说明</strong>。</p><p>答：在「一次性向多个主机发送数据」这一点上与多播类似，但传输的数据范围有区别。多播即使在跨越不同网络的情况下，只要加入多播组就能接受数据。相反，广播只能向同意网络中的主机传输数据。</p></li><li><p><strong>下面关于多播的说法描述错误的是</strong>？</p><p>答：以下内容加粗的为描述正确</p><ol><li>多播是用来加入多播组的所有主机传输数据的协议</li><li>主机连接到同一网络才能加入到多播组，也就是说，多播组无法跨越多个网络</li><li><strong>能够加入多播组的主机数并无限制，但只能有 1个主机（Sender）向该组发送数据</strong></li><li><strong>多播时使用的套接字是 UDP 套接字，因为多播是基于 UDP 进行数据通信的。</strong></li></ol></li><li><p><strong>多播也对网络流量有利，请比较 TCP 交换方式解释其原因</strong></p><p>答：TCP 是必须建立一对一的连接，如果要向1000个主机发送文件，就得传递1000次。但是此时用多播方式传输数据，就只需要发送一次。</p></li><li><p><strong>多播方式的数据通信需要 MBone 虚拟网络。换言之，MBone 是用于多播的网络，但它是虚拟网络。请解释此处的「虚拟网络」</strong></p><p>答：可以理解为「通过网络中的特殊协议工作的软件概念上的网络」。也就是说， MBone 并非可以触及的物理网络。他是以物理网络为基础，通过软件方法实现的多播通信必备虚拟网络。</p></li></ol><h2 id="第-15-章-套接字和标准I-O"><a href="#第-15-章-套接字和标准I-O" class="headerlink" title="第 15 章 套接字和标准I&#x2F;O"></a>第 15 章 套接字和标准I&#x2F;O</h2><p>本章代码，在<a href="https://github.com/riba2534/TCP-IP-NetworkNote">TCP-IP-NetworkNote</a>中可以找到。</p><h3 id="15-1-标准-I-O-的优点"><a href="#15-1-标准-I-O-的优点" class="headerlink" title="15.1 标准 I&#x2F;O 的优点"></a>15.1 标准 I&#x2F;O 的优点</h3><h4 id="15-1-1-标准-I-O-函数的两个优点"><a href="#15-1-1-标准-I-O-函数的两个优点" class="headerlink" title="15.1.1 标准 I&#x2F;O 函数的两个优点"></a>15.1.1 标准 I&#x2F;O 函数的两个优点</h4><p>下面是标准 I&#x2F;O 函数的两个优点：</p><ul><li>标准 I&#x2F;O 函数具有良好的移植性</li><li>标准 I&#x2F;O 函数可以利用缓冲提高性能</li></ul><p>创建套接字时，操作系统会准备 I&#x2F;O 缓冲。此缓冲在执行 TCP 协议时发挥着非常重要的作用。此时若使用标准 I&#x2F;O 函数，将得到额外的缓冲支持。如下图：</p><p><img src="/.io//blog/blog/picture/5c500e53ad9aa.png"></p><p>假设使用 fputs 函数进行传输字符串 「Hello」时，首先将数据传递到标准 I&#x2F;O 缓冲，然后将数据移动到套接字输出缓冲，最后将字符串发送到对方主机。</p><p>设置缓冲的主要目的是为了提高性能。从以下两点可以说明性能的提高：</p><ul><li>传输的数据量</li><li>数据向输出缓冲移动的次数。</li></ul><p>比较 1 个字节的数据发送 10 次的情况和 10 个数据包发送 1 次的情况。发送数据时，数据包中含有头信息。头信与数据大小无关，是按照一定的格式填入的。假设头信息占 40 个字节，需要传输的数据量也存在较大区别：</p><ul><li>1 个字节 10 次：40*10&#x3D;400 字节</li><li>10个字节 1 次：40*1&#x3D;40 字节。</li></ul><h4 id="15-1-2-标准-I-O-函数和系统函数之间的性能对比"><a href="#15-1-2-标准-I-O-函数和系统函数之间的性能对比" class="headerlink" title="15.1.2 标准 I&#x2F;O 函数和系统函数之间的性能对比"></a>15.1.2 标准 I&#x2F;O 函数和系统函数之间的性能对比</h4><p>下面是利用系统函数的示例：</p><ul><li><a href="https://github.com/riba2534/TCP-IP-NetworkNote/blob/master/ch15/syscpy.c">syscpy.c</a></li></ul><p>下面是使用标准 I&#x2F;O 函数复制文件</p><ul><li><a href="https://github.com/riba2534/TCP-IP-NetworkNote/blob/master/ch15/stdcpy.c">stdcpy.c</a></li></ul><p>对于以上两个代码进行测试，明显基于标准 I&#x2F;O 函数的代码跑的更快</p><h4 id="15-1-3-标准-I-O-函数的几个缺点"><a href="#15-1-3-标准-I-O-函数的几个缺点" class="headerlink" title="15.1.3 标准 I&#x2F;O 函数的几个缺点"></a>15.1.3 标准 I&#x2F;O 函数的几个缺点</h4><p>标准 I&#x2F;O 函数存在以下几个缺点：</p><ul><li>不容易进行双向通信</li><li>有时可能频繁调用 fflush 函数<blockquote><p>fflush—切换读写工作状态</p></blockquote></li><li>需要以 FILE 结构体指针的形式返回文件描述符。</li></ul><h3 id="15-2-使用标准-I-O-函数"><a href="#15-2-使用标准-I-O-函数" class="headerlink" title="15.2 使用标准 I&#x2F;O 函数"></a>15.2 使用标准 I&#x2F;O 函数</h3><h4 id="15-2-1-利用-fdopen-函数转换为-FILE-结构体指针"><a href="#15-2-1-利用-fdopen-函数转换为-FILE-结构体指针" class="headerlink" title="15.2.1 利用 fdopen 函数转换为 FILE 结构体指针"></a>15.2.1 利用 fdopen 函数转换为 FILE 结构体指针</h4><p>函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br>FILE *<span class="hljs-title function_">fdopen</span><span class="hljs-params">(<span class="hljs-type">int</span> fildes, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *mode)</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">成功时返回转换的 FILE 结构体指针，失败时返回 NULL</span><br><span class="hljs-comment">fildes ： 需要转换的文件描述符</span><br><span class="hljs-comment">mode ： 将要创建的 FILE 结构体指针的模式信息</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>以下为示例：</p><ul><li><a href="https://github.com/riba2534/TCP-IP-NetworkNote/blob/master/ch15/desto.c">desto.c</a></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    FILE *fp;<br>    <span class="hljs-type">int</span> fd = open(<span class="hljs-string">&quot;data.dat&quot;</span>, O_WRONLY | O_CREAT | O_TRUNC); <span class="hljs-comment">//创建文件并返回文件描述符</span><br>    <span class="hljs-keyword">if</span> (fd == <span class="hljs-number">-1</span>)<br>    &#123;<br>        <span class="hljs-built_in">fputs</span>(<span class="hljs-string">&quot;file open error&quot;</span>, <span class="hljs-built_in">stdout</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    fd = fdopen(fd, <span class="hljs-string">&quot;w&quot;</span>); <span class="hljs-comment">//返回 写 模式的 FILE 指针</span><br>    <span class="hljs-built_in">fputs</span>(<span class="hljs-string">&quot;NetWork C programming \n&quot;</span>, fp);<br>    fclose(fp);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">gcc desto.c -o desto<br>./desto<br><span class="hljs-built_in">cat</span> data.dat<br></code></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/.io//blog/blog/picture/5c5018ff07b29.png"></p><p>文件描述符转换为 FILE 指针，并可以通过该指针调用标准 I&#x2F;O 函数。</p><h4 id="15-2-2-利用-fileno-函数转换为文件描述符"><a href="#15-2-2-利用-fileno-函数转换为文件描述符" class="headerlink" title="15.2.2 利用 fileno 函数转换为文件描述符"></a>15.2.2 利用 fileno 函数转换为文件描述符</h4><p>函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">fileno</span><span class="hljs-params">(FILE *stream)</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">成功时返回文件描述符，失败时返回 -1</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>示例：</p><ul><li><a href="https://github.com/riba2534/TCP-IP-NetworkNote/blob/master/ch15/todes.c">todes.c</a></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    FILE *fp;<br>    <span class="hljs-type">int</span> fd = open(<span class="hljs-string">&quot;data.dat&quot;</span>, O_WRONLY | O_CREAT | O_TRUNC);<br>    <span class="hljs-keyword">if</span> (fd == <span class="hljs-number">-1</span>)<br>    &#123;<br>        <span class="hljs-built_in">fputs</span>(<span class="hljs-string">&quot;file open error&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;First file descriptor : %d \n&quot;</span>, fd);<br>    fp = fdopen(fd, <span class="hljs-string">&quot;w&quot;</span>); <span class="hljs-comment">//转成 file 指针</span><br>    <span class="hljs-built_in">fputs</span>(<span class="hljs-string">&quot;TCP/IP SOCKET PROGRAMMING \n&quot;</span>, fp);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Second file descriptor: %d \n&quot;</span>, fileno(fp)); <span class="hljs-comment">//转回文件描述符</span><br>    fclose(fp);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="15-3-基于套接字的标准-I-O-函数使用"><a href="#15-3-基于套接字的标准-I-O-函数使用" class="headerlink" title="15.3 基于套接字的标准 I&#x2F;O 函数使用"></a>15.3 基于套接字的标准 I&#x2F;O 函数使用</h3><p>把第四章的回声客户端和回声服务端的内容改为基于标准 I&#x2F;O 函数的数据交换形式。</p><p>代码如下：</p><ul><li><a href="https://github.com/riba2534/TCP-IP-NetworkNote/blob/master/ch15/echo_client.c">echo_client.c</a></li><li><a href="https://github.com/riba2534/TCP-IP-NetworkNote/blob/master/ch15/echo_stdserv.c">echo_stdserv.c</a></li></ul><p>编译运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc echo_client.c -o eclient<br>gcc echo_stdserv.c -o eserver<br></code></pre></td></tr></table></figure><p>结果：</p><p><img src="/.io//blog/blog/picture/5c502001581bc.png"></p><p>可以看出，运行结果和第四章相同，这是利用标准 I&#x2F;O 实现的。</p><h3 id="15-4-习题"><a href="#15-4-习题" class="headerlink" title="15.4 习题"></a>15.4 习题</h3><blockquote><p>以下答案仅代表本人个人观点，可能不是正确答案。</p></blockquote><ol><li><p><strong>请说明标准 I&#x2F;O 的 2 个优点。他为何拥有这 2 个优点？</strong></p><p>答：①具有很高的移植性②有良好的缓冲提高性能。因为这些函数是由 ANSI C 标准定义的。适合所有编程领域。</p></li><li><p><strong>利用标准 I&#x2F;O 函数传输数据时，下面的说法是错误的</strong>：</p><blockquote><p>调用 fputs 函数传输数据时，调用后应立即开始发送！</p></blockquote><p><strong>为何上述说法是错误的？为达到这种效果应该添加哪些处理过程？</strong></p><p>答：只是传输到了缓冲中，应该利用 fflush 来刷新缓冲区。</p></li></ol><h2 id="第-16-章-关于-I-O-流分离的其他内容"><a href="#第-16-章-关于-I-O-流分离的其他内容" class="headerlink" title="第 16 章 关于 I&#x2F;O 流分离的其他内容"></a>第 16 章 关于 I&#x2F;O 流分离的其他内容</h2><p>本章代码，在<a href="https://github.com/riba2534/TCP-IP-NetworkNote">TCP-IP-NetworkNote</a>中可以找到。</p><h3 id="16-1-分离-I-O-流"><a href="#16-1-分离-I-O-流" class="headerlink" title="16.1 分离 I&#x2F;O 流"></a>16.1 分离 I&#x2F;O 流</h3><p>「分离 I&#x2F;O 流」是一种常用表达。有 I&#x2F;O 工具可区分二者，无论采用哪种方法，都可以认为是分离了 I&#x2F;O 流。</p><h4 id="16-1-1-2次-I-O-流分离"><a href="#16-1-1-2次-I-O-流分离" class="headerlink" title="16.1.1 2次  I&#x2F;O 流分离"></a>16.1.1 2次  I&#x2F;O 流分离</h4><p>之前有两种分离方法：</p><ul><li>第一种是第 10 章的「TCP I&#x2F;O 过程」分离。通过调用 fork 函数复制出一个文件描述符，以区分输入和输出中使用的文件描述符。虽然文件描述符本身不会根据输入和输出进行区分，但我们分开了 2 个文件描述符的用途，因此，这也属于「流」的分离。</li><li>第二种分离是在第 15 章。通过 2 次 fdopen 函数的调用，创建读模式 FILE 指针（FILE 结构体指针）和写模式 FILE 指针。换言之，我们分离了输入工具和输出工具，因此也可视为「流」的分离。下面是分离的理由。</li></ul><h4 id="16-1-2-分离「流」的好处"><a href="#16-1-2-分离「流」的好处" class="headerlink" title="16.1.2 分离「流」的好处"></a>16.1.2 分离「流」的好处</h4><p>首先是第 10 章「流」的分离目的：</p><ul><li>通过分开输入过程（代码）和输出过程降低实现难度</li><li>与输入无关的输出操作可以提高速度</li></ul><p>下面是第 15 章「流」分离的目的：</p><ul><li>为了将 FILE 指针按读模式和写模式加以区分</li><li>可以通过区分读写模式降低实现难度</li><li>通过区分 I&#x2F;O 缓冲提高缓冲性能</li></ul><h4 id="16-1-3-「流」分离带来的-EOF-问题"><a href="#16-1-3-「流」分离带来的-EOF-问题" class="headerlink" title="16.1.3 「流」分离带来的 EOF 问题"></a>16.1.3 「流」分离带来的 EOF 问题</h4><p>第 7 章介绍过 EOF 的传递方法和半关闭的必要性。有一个语句：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">shutdown(sock,SHUT_WR);<br></code></pre></td></tr></table></figure><p>当时说过调用 shutdown 函数的基于半关闭的 EOF 传递方法。第十章的 <a href="https://github.com/riba2534/TCP-IP-NetworkNote/blob/master/ch10/echo_mpclient.c">echo_mpclient.c</a> 添加了半关闭的相关代码。但是还没有讲采用 fdopen 函数怎么半关闭。那么是否是通过 fclose 函数关闭流呢？我们先试试</p><p>下面是服务端和客户端码：</p><ul><li><a href="https://github.com/riba2534/TCP-IP-NetworkNote/blob/master/ch16/sep_clnt.c">sep_clnt.c</a></li><li><a href="https://github.com/riba2534/TCP-IP-NetworkNote/blob/master/ch16/sep_serv.c">sep_serv.c</a></li></ul><p>编译运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc sep_clnt.c -o clnt<br>gcc sep_serv.c -o serv<br>./serv 9190<br>./clnt 127.0.0.1 9190<br></code></pre></td></tr></table></figure><p>结果：</p><p><img src="/.io//blog/blog/picture/5c512086a75d9.png"></p><p>从运行结果可以看出，服务端最终没有收到客户端发送的信息。那么这是什么原因呢？</p><p>原因是：服务端代码的 <code>fclose(writefp);</code> 这一句，完全关闭了套接字而不是半关闭。这才是这一章需要解决的问题。</p><h3 id="16-2-文件描述符的的复制和半关闭"><a href="#16-2-文件描述符的的复制和半关闭" class="headerlink" title="16.2 文件描述符的的复制和半关闭"></a>16.2 文件描述符的的复制和半关闭</h3><h4 id="16-2-1-终止「流」时无法半关闭原因"><a href="#16-2-1-终止「流」时无法半关闭原因" class="headerlink" title="16.2.1 终止「流」时无法半关闭原因"></a>16.2.1 终止「流」时无法半关闭原因</h4><p>下面的图描述的是服务端代码中的两个FILE 指针、文件描述符和套接字中的关系。</p><p><img src="/.io//blog/blog/picture/5c5121da89955.png"></p><p>从图中可以看到，两个指针都是基于同一文件描述符创建的。因此，针对于任何一个 FILE 指针调用 fclose 函数都会关闭文件描述符，如图所示：</p><p><img src="/.io//blog/blog/picture/5c51224051802.png"></p><p>从图中看到，销毁套接字时再也无法进行数据交换。那如何进入可以进入但是无法输出的半关闭状态呢？如下图所示：</p><p><img src="/.io//blog/blog/picture/5c5122a45c5f1.png"></p><p>只需要创建 FILE 指针前先复制文件描述符即可。复制后另外创建一个文件描述符，然后利用各自的文件描述符生成读模式的 FILE 指针和写模式的 FILE 指针。这就为半关闭创造好了环境，因为套接字和文件描述符具有如下关系：</p><blockquote><p>销毁所有文件描述符候才能销毁套接字</p></blockquote><p>也就是说，针对写模式 FILE 指针调用 fclose 函数时，只能销毁与该 FILE 指针相关的文件描述符，无法销毁套接字，如下图：</p><p><img src="/.io//blog/blog/picture/5c5123ad7df31.png"></p><p>那么调用 fclose 函数候还剩下 1 个文件描述符，因此没有销毁套接字。那此时的状态是否为半关闭状态？不是！只是准备好了进入半关闭状态，而不是已经进入了半关闭状态。仔细观察，还剩下一个文件描述符。而该文件描述符可以同时进行 I&#x2F;O 。因此，不但没有发送 EOF ，而且仍然可以利用文件描述符进行输出。</p><h4 id="16-2-2-复制文件描述符"><a href="#16-2-2-复制文件描述符" class="headerlink" title="16.2.2 复制文件描述符"></a>16.2.2 复制文件描述符</h4><p>与调用 fork 函数不同，调用 fork 函数将复制整个进程，此处讨论的是同一进程内完成对完成描述符的复制。如图：</p><p><img src="/.io//blog/blog/picture/5c512579c45b6.png"></p><p>复制完成后，两个文件描述符都可以访问文件，但是编号不同。</p><h4 id="16-2-3-dup-和-dup2"><a href="#16-2-3-dup-和-dup2" class="headerlink" title="16.2.3 dup 和 dup2"></a>16.2.3 dup 和 dup2</h4><p>下面给出两个函数原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">dup</span><span class="hljs-params">(<span class="hljs-type">int</span> fildes)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">dup2</span><span class="hljs-params">(<span class="hljs-type">int</span> fildes, <span class="hljs-type">int</span> fildes2)</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">成功时返回复制的文件描述符，失败时返回 -1</span><br><span class="hljs-comment">fildes : 需要复制的文件描述符</span><br><span class="hljs-comment">fildes2 : 明确指定的文件描述符的整数值。</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>dup2 函数明确指定复制的文件描述符的整数值。向其传递大于 0 且小于进程能生成的最大文件描述符值时，该值将成为复制出的文件描述符值。下面是代码示例：</p><ul><li><a href="https://github.com/riba2534/TCP-IP-NetworkNote/blob/master/ch16/dup.c">dup.c</a></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br>    <span class="hljs-type">int</span> cfd1, cfd2;<br>    <span class="hljs-type">char</span> str1[] = <span class="hljs-string">&quot;Hi~ \n&quot;</span>;<br>    <span class="hljs-type">char</span> str2[] = <span class="hljs-string">&quot;It&#x27;s nice day~ \n&quot;</span>;<br><br>    cfd1 = dup(<span class="hljs-number">1</span>);        <span class="hljs-comment">//复制文件描述符 1</span><br>    cfd2 = dup2(cfd1, <span class="hljs-number">7</span>); <span class="hljs-comment">//再次复制文件描述符,定为数值 7</span><br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fd1=%d , fd2=%d \n&quot;</span>, cfd1, cfd2);<br>    write(cfd1, str1, <span class="hljs-keyword">sizeof</span>(str1));<br>    write(cfd2, str2, <span class="hljs-keyword">sizeof</span>(str2));<br><br>    close(cfd1);<br>    close(cfd2); <span class="hljs-comment">//终止复制的文件描述符，但是仍有一个文件描述符</span><br>    write(<span class="hljs-number">1</span>, str1, <span class="hljs-keyword">sizeof</span>(str1));<br>    close(<span class="hljs-number">1</span>);<br>    write(<span class="hljs-number">1</span>, str2, <span class="hljs-keyword">sizeof</span>(str2)); <span class="hljs-comment">//无法完成输出</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>编译运行：</p><figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs hsp">gcc dup.c -o <span class="hljs-keyword">dup</span><br>./<span class="hljs-keyword">dup</span><br></code></pre></td></tr></table></figure><p>结果：</p><p><img src="/.io//blog/blog/picture/5c5135574d89a.png"></p><h4 id="16-2-4-复制文件描述符后「流」的分离"><a href="#16-2-4-复制文件描述符后「流」的分离" class="headerlink" title="16.2.4 复制文件描述符后「流」的分离"></a>16.2.4 复制文件描述符后「流」的分离</h4><p>下面更改 <a href="https://github.com/riba2534/TCP-IP-NetworkNote/blob/master/ch16/sep_clnt.c">sep_clnt.c</a> 和 <a href="https://github.com/riba2534/TCP-IP-NetworkNote/blob/master/ch16/sep_serv.c">sep_serv.c</a> 可以使得让它正常工作，正常工作是指通过服务器的半关闭状态接收客户端最后发送的字符串。</p><p><strong>该例子得出结论</strong></p><blockquote><p>无论复制出多少文件描述符，均应调用shutdown函数发送EOF并进入半关闭状态。</p></blockquote><p>下面是代码：</p><ul><li><a href="https://github.com/riba2534/TCP-IP-NetworkNote/blob/master/ch16/sep_serv2.c">sep_serv2.c</a></li></ul><p>这个代码可以与 <a href="https://github.com/riba2534/TCP-IP-NetworkNote/blob/master/ch16/sep_clnt.c">sep_clnt.c</a> 配合起来使用，编译过程和上面一样，运行结果为：</p><p><img src="/.io//blog/blog/picture/5c513d54a27e0.png"></p><h3 id="16-3-习题"><a href="#16-3-习题" class="headerlink" title="16.3 习题"></a>16.3 习题</h3><blockquote><p>以下答案仅代表本人个人观点，可能不是正确答案。</p></blockquote><ol><li><p><strong>下列关于 FILE 结构体指针和文件描述符的说法错误的是</strong>？</p><p>答：以下加粗内容代表说法正确。</p><ol><li>与 FILE 结构体指针相同，文件描述符也分输入描述符和输出描述符</li><li>复制文件描述符时将生成相同值的描述符，可以通过这 2 个描述符进行 I&#x2F;O</li><li><strong>可以利用创建套接字时返回的文件描述符进行 I&#x2F;O ，也可以不通过文件描述符，直接通过 FILE 结构体指针完成</strong></li><li><strong>可以从文件描述符生成 FILE 结构体指针，而且可以利用这种 FILE 结构体指针进行套接字 I&#x2F;O</strong></li><li>若文件描述符为读模式，则基于该描述符生成的 FILE 结构体指针同样是读模式；若文件描述符为写模式，则基于该描述符生成的 FILE 结构体指针同样是写模式</li></ol></li><li><p><strong>EOF 的发送相关描述中错误的是</strong>？</p><p>答：以下加粗内容代表说法正确。</p><ol><li>终止文件描述符时发送 EOF</li><li><strong>即使未完全终止文件描述符，关闭输出流时也会发送 EOF</strong></li><li>如果复制文件描述符，则包括复制的文件描述符在内，所有文件描述符都终止时才会发送 EOF</li><li><strong>即使复制文件描述符，也可以通过调用 shutdown 函数进入半关闭状态并发送 EOF</strong></li></ol></li></ol><h2 id="第-17-章-优于-select-的-epoll"><a href="#第-17-章-优于-select-的-epoll" class="headerlink" title="第 17 章 优于 select 的 epoll"></a>第 17 章 优于 select 的 epoll</h2><p>本章代码，在<a href="https://github.com/riba2534/TCP-IP-NetworkNote">TCP-IP-NetworkNote</a>中可以找到。</p><h3 id="17-1-epoll-理解及应用"><a href="#17-1-epoll-理解及应用" class="headerlink" title="17.1 epoll 理解及应用"></a>17.1 epoll 理解及应用</h3><p>select 复用方法由来已久，因此，利用该技术后，无论如何优化程序性能也无法同时介入上百个客户端。这种 select 方式并不适合以 web 服务器端开发为主流的现代开发环境，所以需要学习 Linux 环境下的 epoll</p><h4 id="17-1-1-基于-select-的-I-O-复用技术速度慢的原因"><a href="#17-1-1-基于-select-的-I-O-复用技术速度慢的原因" class="headerlink" title="17.1.1 基于 select 的 I&#x2F;O 复用技术速度慢的原因"></a>17.1.1 基于 select 的 I&#x2F;O 复用技术速度慢的原因</h4><p>第 12 章实现了基于 select 的 I&#x2F;O 复用技术服务端，其中有不合理的设计如下：</p><ul><li>调用 select 函数后常见的针对所有文件描述符的循环语句</li><li>每次调用 select 函数时都需要向该函数传递监视对象信息</li></ul><p>上述两点可以从 <a href="https://github.com/riba2534/TCP-IP-NetworkNote/blob/master/ch12/echo_selectserv.c">echo_selectserv.c</a> 得到确认，调用 select 函数后，并不是把发生变化的文件描述符单独集中在一起，而是通过作为监视对象的 fd_set 变量的变化，找出发生变化的文件描述符（54,56行），因此无法避免针对所有监视对象的循环语句。而且，作为监视对象的 fd_set 会发生变化，所以调用 select 函数前应该复制并保存原有信息，并在每次调用 select 函数时传递新的监视对象信息。</p><p>select 性能上最大的弱点是：每次传递监视对象信息，准确的说，select 是监视套接字变化的函数。而套接字是操作系统管理的，所以 select 函数要借助操作系统才能完成功能。select 函数的这一缺点可以通过如下方式弥补：</p><blockquote><p>仅向操作系统传递一次监视对象，监视范围或内容发生变化时只通知发生变化的事项</p></blockquote><p>这样就无需每次调用 select 函数时都想操作系统传递监视对象信息，但是前提操作系统支持这种处理方式。Linux 的支持方式是 epoll ，Windows 的支持方式是 IOCP。</p><h4 id="17-1-2-select-也有优点"><a href="#17-1-2-select-也有优点" class="headerlink" title="17.1.2 select 也有优点"></a>17.1.2 select 也有优点</h4><p>select 的兼容性比较高，这样就可以支持很多的操作系统，不受平台的限制，使用 select 函数满足以下两个条件：</p><ul><li>服务器接入者少</li><li>程序应该具有兼容性</li></ul><h4 id="17-1-3-实现-epoll-时必要的函数和结构体"><a href="#17-1-3-实现-epoll-时必要的函数和结构体" class="headerlink" title="17.1.3 实现 epoll 时必要的函数和结构体"></a>17.1.3 实现 epoll 时必要的函数和结构体</h4><p>能够克服 select 函数缺点的 epoll 函数具有以下优点，这些优点正好与之前的 select 函数缺点相反。</p><ul><li>无需编写以监视状态变化为目的的针对所有文件描述符的循环语句</li><li>调用对应于 select 函数的 epoll_wait 函数时无需每次传递监视对象信息。</li></ul><p>下面是 epoll 函数的功能：</p><ul><li>epoll_create：创建保存 epoll 文件描述符的空间</li><li>epoll_ctl：向空间注册并注销文件描述符</li><li>epoll_wait：与 select 函数类似，等待文件描述符发生变化</li></ul><p>select 函数中为了保存监视对象的文件描述符，直接声明了 fd_set 变量，但 epoll 方式下的操作系统负责保存监视对象文件描述符，因此需要向操作系统请求创建保存文件描述符的空间，此时用的函数就是 epoll_create 。</p><p>此外，为了添加和删除监视对象文件描述符，select 方式中需要 FD_SET、FD_CLR 函数。但在 epoll 方式中，通过 epoll_ctl 函数请求操作系统完成。最后，select 方式下调用 select 函数等待文件描述符的变化，而 epoll_wait 调用 epoll_wait 函数。还有，select 方式中通过 fd_set 变量查看监视对象的状态变化，而 epoll 方式通过如下结构体 epoll_event 将发生变化的文件描述符单独集中在一起。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epoll_event</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">__uint32_t</span> events;<br>    <span class="hljs-type">epoll_data_t</span> data;<br>&#125;;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">epoll_data</span> &#123;</span><br>    <span class="hljs-type">void</span> *ptr;<br>    <span class="hljs-type">int</span> fd;<br>    <span class="hljs-type">__uint32_t</span> u32;<br>    <span class="hljs-type">__uint64_t</span> u64;<br>&#125; <span class="hljs-type">epoll_data_t</span>;<br><br></code></pre></td></tr></table></figure><p>声明足够大的 epoll_event 结构体数组候，传递给 epoll_wait 函数时，发生变化的文件描述符信息将被填入数组。因此，无需像 select 函数那样针对所有文件描述符进行循环。</p><h4 id="17-1-4-epoll-create"><a href="#17-1-4-epoll-create" class="headerlink" title="17.1.4 epoll_create"></a>17.1.4 epoll_create</h4><p>epoll 是从 Linux 的 2.5.44 版内核开始引入的。通过以下命令可以查看 Linux 内核版本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat /proc/sys/kernel/osrelease<br></code></pre></td></tr></table></figure><p>下面是 epoll_create 函数的原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/epoll.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">epoll_create</span><span class="hljs-params">(<span class="hljs-type">int</span> size)</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">成功时返回 epoll 的文件描述符，失败时返回 -1</span><br><span class="hljs-comment">size：epoll 实例的大小</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>调用 epoll_create 函数时创建的文件描述符保存空间称为「epoll 例程」，但有些情况下名称不同，需要稍加注意。通过参数 size 传递的值决定 epoll 例程的大小，但该值只是向操作系统提出的建议。换言之，size 并不用来决定 epoll 的大小，而仅供操作系统参考。</p><blockquote><p>Linux 2.6.8 之后的内核将完全传入 epoll_create 函数的 size 函数，因此内核会根据情况调整 epoll 例程大小。但是本书程序并没有忽略 size</p></blockquote><p>epoll_create 函数创建的资源与套接字相同，也由操作系统管理。因此，该函数和创建套接字的情况相同，也会返回文件描述符，也就是说返回的文件描述符主要用于区分 epoll 例程。需要终止时，与其他文件描述符相同，也要调用 close 函数</p><h4 id="17-1-5-epoll-ctl"><a href="#17-1-5-epoll-ctl" class="headerlink" title="17.1.5 epoll_ctl"></a>17.1.5 epoll_ctl</h4><p>生成例程后，应在其内部注册监视对象文件描述符，此时使用 epoll_ctl 函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/epoll.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">epoll_ctl</span><span class="hljs-params">(<span class="hljs-type">int</span> epfd, <span class="hljs-type">int</span> op, <span class="hljs-type">int</span> fd, <span class="hljs-keyword">struct</span> epoll_event *event)</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">成功时返回 0 ，失败时返回 -1</span><br><span class="hljs-comment">epfd：用于注册监视对象的 epoll 例程的文件描述符</span><br><span class="hljs-comment">op：用于制定监视对象的添加、删除或更改等操作</span><br><span class="hljs-comment">fd：需要注册的监视对象文件描述符</span><br><span class="hljs-comment">event：监视对象的事件类型</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>与其他 epoll 函数相比，该函数看起来有些复杂，但通过调用语句就很容易理解，假设按照如下形式调用 epoll_ctl 函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs CQL">epoll_ctl(A,EPOLL_CTL_ADD,B,C);<br></code></pre></td></tr></table></figure><p>第二个参数 EPOLL_CTL_ADD 意味着「添加」，上述语句有如下意义：</p><blockquote><p>epoll  例程 A 中注册文件描述符 B ，主要目的是为了监视参数 C 中的事件</p></blockquote><p>再介绍一个调用语句。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">epoll_ctl(A,EPOLL_CTL_DEL,B,<span class="hljs-literal">NULL</span>);<br></code></pre></td></tr></table></figure><p>上述语句中第二个参数意味这「删除」，有以下含义：</p><blockquote><p>从 epoll 例程 A 中删除文件描述符 B</p></blockquote><p>从上述示例中可以看出，从监视对象中删除时，不需要监视类型，因此向第四个参数可以传递为 NULL</p><p>下面是第二个参数的含义：</p><ul><li>EPOLL_CTL_ADD：将文件描述符注册到 epoll 例程</li><li>EPOLL_CTL_DEL：从 epoll 例程中删除文件描述符</li><li>EPOLL_CTL_MOD：更改注册的文件描述符的关注事件发生情况</li></ul><p>epoll_event 结构体用于保存事件的文件描述符集合。但也可以在 epoll 例程中注册文件描述符时，用于注册关注的事件。该函数中 epoll_event 结构体的定义并不显眼，因此通过调用语句说明该结构体在 epoll_ctl 函数中的应用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epoll_event</span> <span class="hljs-title">event</span>;</span><br>...<br>event.events=EPOLLIN;<span class="hljs-comment">//发生需要读取数据的情况时</span><br>event.data.fd=sockfd;<br>epoll_ctl(epfd,EPOLL_CTL_ADD,sockfd,&amp;event);<br>...<br></code></pre></td></tr></table></figure><p>上述代码将 sockfd 注册到 epoll 例程 epfd 中，并在需要读取数据的情况下产生相应事件。接下来给出 epoll_event 的成员 events 中可以保存的常量及所指的事件类型。</p><ul><li>EPOLLIN：需要读取数据的情况</li><li>EPOLLOUT：输出缓冲为空，可以立即发送数据的情况</li><li>EPOLLPRI：收到 OOB 数据的情况</li><li>EPOLLRDHUP：断开连接或半关闭的情况，这在边缘触发方式下非常有用</li><li>EPOLLERR：发生错误的情况</li><li>EPOLLET：以边缘触发的方式得到事件通知</li><li>EPOLLONESHOT：发生一次事件后，相应文件描述符不再收到事件通知。因此需要向 epoll_ctl 函数的第二个参数传递 EPOLL_CTL_MOD ，再次设置事件。</li></ul><p>可通过位运算同时传递多个上述参数。</p><h4 id="17-1-6-epoll-wait"><a href="#17-1-6-epoll-wait" class="headerlink" title="17.1.6 epoll_wait"></a>17.1.6 epoll_wait</h4><p>下面是函数原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/epoll.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">epoll_wait</span><span class="hljs-params">(<span class="hljs-type">int</span> epfd, <span class="hljs-keyword">struct</span> epoll_event *events, <span class="hljs-type">int</span> maxevents, <span class="hljs-type">int</span> timeout)</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">成功时返回发生事件的文件描述符，失败时返回 -1</span><br><span class="hljs-comment">epfd : 表示事件发生监视范围的 epoll 例程的文件描述符</span><br><span class="hljs-comment">events : 保存发生事件的文件描述符集合的结构体地址值</span><br><span class="hljs-comment">maxevents : 第二个参数中可以保存的最大事件数</span><br><span class="hljs-comment">timeout : 以 1/1000 秒为单位的等待时间，传递 -1 时，一直等待直到发生事件</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>该函数调用方式如下。需要注意的是，第二个参数所指缓冲需要动态分配。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> event_cnt;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epoll_event</span> *<span class="hljs-title">ep_events</span>;</span><br>...<br>ep_events=<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> epoll_event)*EPOLL_SIZE);<span class="hljs-comment">//EPOLL_SIZE是宏常量</span><br>...<br>event_cnt=epoll_wait(epfd,ep_events,EPOLL_SIZE,<span class="hljs-number">-1</span>);<br>...<br></code></pre></td></tr></table></figure><p>调用函数后，返回发生事件的文件描述符，同时在第二个参数指向的缓冲中保存发生事件的文件描述符集合。因此，无需像 select 一样插入针对所有文件描述符的循环。</p><h4 id="17-1-7-基于-epoll-的回声服务器端"><a href="#17-1-7-基于-epoll-的回声服务器端" class="headerlink" title="17.1.7 基于 epoll 的回声服务器端"></a>17.1.7 基于 epoll 的回声服务器端</h4><p>下面是回声服务器端的代码（修改自第 12 章 <a href="https://github.com/riba2534/TCP-IP-NetworkNote/blob/master/ch12/echo_selectserv.c">echo_selectserv.c</a>）：</p><ul><li><a href="https://github.com/riba2534/TCP-IP-NetworkNote/blob/master/ch17/echo_epollserv.c">echo_epollserv.c</a></li></ul><p>编译运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc echo_epollserv.c -o serv<br>./serv 9190<br></code></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/.io//blog/blog/picture/5c53f5b6d4acf.png"></p><p>可以看出运行结果和以前 select 实现的和 fork 实现的结果一样，都可以支持多客户端同时运行。</p><p>但是这里运用了 epoll 效率高于 select</p><p>总结一下 epoll 的流程：</p><ol><li>epoll_create 创建一个保存 epoll 文件描述符的空间，可以没有参数</li><li>动态分配内存，给将要监视的 epoll_wait</li><li>利用 epoll_ctl 控制 添加 删除，监听事件</li><li>利用 epoll_wait 来获取改变的文件描述符,来执行程序</li></ol><p>select 和 epoll 的区别：</p><ul><li>每次调用 select 函数都会向操作系统传递监视对象信息，浪费大量时间</li><li>epoll 仅向操作系统传递一次监视对象，监视范围或内容发生变化时只通知发生变化的事项</li></ul><h3 id="17-2-条件触发和边缘触发"><a href="#17-2-条件触发和边缘触发" class="headerlink" title="17.2 条件触发和边缘触发"></a>17.2 条件触发和边缘触发</h3><p>学习 epoll 时要了解条件触发（Level Trigger）和边缘触发（Edge Trigger）。</p><h4 id="17-2-1-条件触发和边缘触发的区别在于发生事件的时间点"><a href="#17-2-1-条件触发和边缘触发的区别在于发生事件的时间点" class="headerlink" title="17.2.1 条件触发和边缘触发的区别在于发生事件的时间点"></a>17.2.1 条件触发和边缘触发的区别在于发生事件的时间点</h4><p><strong>条件触发的特性</strong>：</p><blockquote><p>条件触发方式中，只要输入缓冲有数据就会一直通知该事件</p></blockquote><p>例如，服务器端输入缓冲收到 50 字节数据时，服务器端操作系统将通知该事件（注册到发生变化的文件描述符）。但是服务器端读取 20 字节后还剩下 30 字节的情况下，仍会注册事件。也就是说，条件触发方式中，只要输入缓冲中还剩有数据，就将以事件方式再次注册。</p><p><strong>边缘触发特性</strong>：</p><p>边缘触发中输入缓冲收到数据时仅注册 1 次该事件。即使输入缓冲中还留有数据，也不会再进行注册。</p><h4 id="17-2-2-掌握条件触发的事件特性"><a href="#17-2-2-掌握条件触发的事件特性" class="headerlink" title="17.2.2 掌握条件触发的事件特性"></a>17.2.2 掌握条件触发的事件特性</h4><p>下面代码修改自 <a href="https://github.com/riba2534/TCP-IP-NetworkNote/blob/master/ch17/echo_epollserv.c">echo_epollserv.c</a> 。epoll 默认以条件触发的方式工作，因此可以通过该示例验证条件触发的特性。</p><ul><li><a href="https://github.com/riba2534/TCP-IP-NetworkNote/blob/master/ch17/echo_EPLTserv.c">echo_EPLTserv.c</a></li></ul><p>上面的代码把调用 read 函数时使用的缓冲大小缩小到了 4 个字节，插入了验证 epoll_wait 调用次数的验证函数。减少缓冲大小是为了阻止服务器端一次性读取接收的数据。换言之，调用 read 函数后，输入缓冲中仍有数据要读取，而且会因此注册新的事件并从 epoll_wait 函数返回时将循环输出「return epoll_wait」字符串。</p><p>编译运行:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc echo_EPLTserv.c -o serv<br>./serv 9190<br></code></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/.io//blog/blog/picture/5c540825ae415.png"></p><p>从结果可以看出，每当收到客户端数据时，都回注册该事件，并因此调用 epoll_wait 函数。</p><p>下面的代码是修改后的边缘触发方式的代码，仅仅是把上面的代码改为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">event.events = EPOLLIN | EPOLLET;<br></code></pre></td></tr></table></figure><p>代码：</p><ul><li><a href="https://github.com/riba2534/TCP-IP-NetworkNote/blob/master/ch17/echo_EDGEserv.c">echo_EDGEserv.c</a></li></ul><p>编译运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc echo_EDGEserv.c -o serv<br>./serv 9190<br></code></pre></td></tr></table></figure><p>结果：</p><p><img src="/.io//blog/blog/picture/5c54097b6469f.png"></p><p>从上面的例子看出，接收到客户端的消息时，只输出一次「return epoll_wait」字符串，这证明仅注册了一次事件。</p><p><strong>select 模型是以条件触发的方式工作的</strong>。</p><h4 id="17-2-3-边缘触发的服务器端必知的两点"><a href="#17-2-3-边缘触发的服务器端必知的两点" class="headerlink" title="17.2.3 边缘触发的服务器端必知的两点"></a>17.2.3 边缘触发的服务器端必知的两点</h4><ul><li>通过 errno 变量验证错误原因</li><li>为了完成非阻塞（Non-blocking）I&#x2F;O ，更改了套接字特性。</li></ul><p>Linux 套接字相关函数一般通过 -1 通知发生了错误。虽然知道发生了错误，但仅凭这些内容无法得知产生错误的原因。因此，为了在发生错误的时候提额外的信息，Linux 声明了如下全局变量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> errno;<br></code></pre></td></tr></table></figure><p>为了访问该变量，需要引入 <code>error.h</code> 头文件，因此此头文件有上述变量的 extren 声明。另外，每种函数发生错误时，保存在 errno 变量中的值都不同。</p><blockquote><p>read 函数发现输入缓冲中没有数据可读时返回 -1，同时在 errno 中保存 EAGAIN 常量</p></blockquote><p>下面是 Linux 中提供的改变和更改文件属性的办法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">fcntl</span><span class="hljs-params">(<span class="hljs-type">int</span> fields, <span class="hljs-type">int</span> cmd, ...)</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">成功时返回 cmd 参数相关值，失败时返回 -1</span><br><span class="hljs-comment">filedes : 属性更改目标的文件描述符</span><br><span class="hljs-comment">cmd : 表示函数调用目的</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>从上述声明可以看出 fcntl 有可变参数的形式。如果向第二个参数传递 F_GETFL ，可以获得第一个参数所指的文件描述符属性（int 型）。反之，如果传递 F_SETFL ，可以更改文件描述符属性。若希望将文件（套接字）改为非阻塞模式，需要如下  2 条语句。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> flag = fcntl(fd,F_GETFL,<span class="hljs-number">0</span>);<br>fcntl(fd,F_SETFL | O_NONBLOCK)<br></code></pre></td></tr></table></figure><p>通过第一条语句，获取之前设置的属性信息，通过第二条语句在此基础上添加非阻塞 O_NONBLOCK 标志。调用 read&#x2F;write 函数时，无论是否存在数据，都会形成非阻塞文件（套接字）。fcntl 函数的适用范围很广。</p><h4 id="17-2-4-实现边缘触发回声服务器端"><a href="#17-2-4-实现边缘触发回声服务器端" class="headerlink" title="17.2.4 实现边缘触发回声服务器端"></a>17.2.4 实现边缘触发回声服务器端</h4><p>通过 errno 确认错误的原因是：边缘触发方式中，接收数据仅注册一次该事件。</p><p>因为这种特点，一旦发生输入相关事件时，就应该读取输入缓冲中的全部数据。因此需要验证输入缓冲是否为空。</p><blockquote><p>read 函数返回 -1，变量 errno 中的值变成 EAGAIN 时，说明没有数据可读。</p></blockquote><p>既然如此，为什么要将套接字变成非阻塞模式？边缘触发条件下，以阻塞方式工作的 read &amp; write 函数有可能引起服务端的长时间停顿。因此，边缘触发方式中一定要采用非阻塞 read &amp; write 函数。</p><p>下面是以边缘触发方式工作的回声服务端代码：</p><ul><li><a href="https://github.com/riba2534/TCP-IP-NetworkNote/blob/master/ch17/echo_EPETserv.c">echo_EPETserv.c</a></li></ul><p>编译运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc echo_EPETserv.c -o serv<br>./serv<br></code></pre></td></tr></table></figure><p>结果：</p><p><img src="/.io//blog/blog/picture/5c542149c0cee.png"></p><h4 id="17-2-5-条件触发和边缘触发孰优孰劣"><a href="#17-2-5-条件触发和边缘触发孰优孰劣" class="headerlink" title="17.2.5 条件触发和边缘触发孰优孰劣"></a>17.2.5 条件触发和边缘触发孰优孰劣</h4><p>边缘触发方式可以做到这点：</p><blockquote><p>可以分离接收数据和处理数据的时间点！</p></blockquote><p>下面是边缘触发的图</p><p><img src="/.io//blog/blog/picture/5c5421e3b3f2b.png"></p><p>运行流程如下：</p><ul><li>服务器端分别从 A B C 接收数据</li><li>服务器端按照  A B C 的顺序重新组合接收到的数据</li><li>组合的数据将发送给任意主机。</li></ul><p>为了完成这个过程，如果可以按照如下流程运行，服务端的实现并不难：</p><ul><li>客户端按照 A B C 的顺序连接服务器，并且按照次序向服务器发送数据</li><li>需要接收数据的客户端应在客户端 A B C 之前连接到服务器端并等待</li></ul><p>但是实际情况中可能是下面这样：</p><ul><li>客户端 C 和 B 正在向服务器发送数据，但是 A 并没有连接到服务器</li><li>客户端 A B C 乱序发送数据</li><li>服务端已经接收到数据，但是要接收数据的目标客户端并没有连接到服务器端。</li></ul><p>因此，即使输入缓冲收到数据，服务器端也能决定读取和处理这些数据的时间点，这样就给服务器端的实现带来很大灵活性。</p><h3 id="17-3-习题"><a href="#17-3-习题" class="headerlink" title="17.3 习题"></a>17.3 习题</h3><blockquote><p>以下答案仅代表本人个人观点，可能不是正确答案。</p></blockquote><ol><li><p>利用 select 函数实现服务器端时，代码层面存在的两个缺点是？</p><p>答：①调用 select 函数后常见的针对所有文件描述符的循环语句②每次调用 select 函数时都要传递监视对象信息。</p></li><li><p>无论是 select 方式还是 epoll 方式，都需要将监视对象文件描述符信息通过函数调用传递给操作系统。请解释传递该信息的原因。</p><p>答：文件描述符是由操作系统管理的，所以必须要借助操作系统才能完成。</p></li><li><p>select 方式和 epoll 方式的最大差异在于监视对象文件描述符传递给操作系统的方式。请说明具体差异，并解释为何存在这种差异。</p><p>答：select 函数每次调用都要传递所有的监视对象信息，而 epoll 函数仅向操作系统传递 1 次监视对象，监视范围或内容发生变化时只通知发生变化的事项。select 采用这种方法是为了保持兼容性。</p></li><li><p>虽然 epoll 是 select 的改进方案，但 select 也有自己的优点。在何种情况下使用 select 更加合理。</p><p>答：①服务器端接入者少②程序应具有兼容性。</p></li><li><p>epoll 是以条件触发和边缘触发方式工作。二者有何差别？从输入缓冲的角度说明这两种方式通知事件的时间点差异。</p><p>答：在条件触发中，只要输入缓冲有数据，就会一直通知该事件。边缘触发中输入缓冲收到数据时仅注册 1 次该事件，即使输入缓冲中还留有数据，也不会再进行注册。</p></li><li><p>采用边缘触发时可以分离数据的接收和处理时间点。请说明其优点和原因。</p><p>答：分离接收数据和处理数据的时间点，给服务端的实现带来很大灵活性。</p></li></ol><h2 id="第-18-章-多线程服务器端的实现"><a href="#第-18-章-多线程服务器端的实现" class="headerlink" title="第 18 章 多线程服务器端的实现"></a>第 18 章 多线程服务器端的实现</h2><p>本章代码，在<a href="https://github.com/riba2534/TCP-IP-NetworkNote">TCP-IP-NetworkNote</a>中可以找到。</p><h3 id="18-1-理解线程的概念"><a href="#18-1-理解线程的概念" class="headerlink" title="18.1 理解线程的概念"></a>18.1 理解线程的概念</h3><h4 id="18-1-1-引入线程背景"><a href="#18-1-1-引入线程背景" class="headerlink" title="18.1.1 引入线程背景"></a>18.1.1 引入线程背景</h4><p>第 10 章介绍了多进程服务端的实现方法。多进程模型与 select 和 epoll 相比的确有自身的优点，但同时也有问题。如前所述，创建（复制）进程的工作本身会给操作系统带来相当沉重的负担。而且，每个进程都具有独立的内存空间，所以进程间通信的实现难度也会随之提高。换言之，多进程的缺点可概括为：</p><ul><li>创建进程的过程会带来一定的开销</li><li>为了完成进程间数据交换，需要特殊的 IPC 技术。</li></ul><p>但是更大的缺点是下面的：</p><ul><li>每秒少则 10 次，多则千次的「上下文切换」是创建进程的最大开销</li></ul><p>只有一个 CPU 的系统是将时间分成多个微小的块后分配给了多个进程。为了分时使用 CPU ，需要「上下文切换」的过程。「上下文切换」是指运行程序前需要将相应进程信息读入内存，如果运行进程 A 后紧接着需要运行进程 B ，就应该将进程 A 相关信息移出内存，并读入进程 B 相关信息。这就是上下文切换。但是此时进程 A 的数据将被移动到硬盘，所以上下文切换要很长时间，即使通过优化加快速度，也会存在一定的局限。</p><p>为了保持多进程的优点，同时在一定程度上克服其缺点，人们引入的线程（Thread）的概念。这是为了将进程的各种劣势降至最低程度（不是直接消除）而设立的一种「轻量级进程」。线程比进程具有如下优点：</p><ul><li>线程的创建和上下文切换比进程的创建和上下文切换更快</li><li>线程间交换数据无需特殊技术</li></ul><h4 id="18-1-2-线程和进程的差异"><a href="#18-1-2-线程和进程的差异" class="headerlink" title="18.1.2 线程和进程的差异"></a>18.1.2 线程和进程的差异</h4><p>线程是为了解决：为了得到多条代码执行流而复制整个内存区域的负担太重。</p><p>每个进程的内存空间都由保存全局变量的「数据区」、向 malloc 等函数动态分配提供空间的堆（Heap）、函数运行时间使用的栈（Stack）构成。每个进程都有独立的这种空间，多个进程的内存结构如图所示：</p><p><img src="/.io//blog/blog/picture/5c55aa57db3c7.png"></p><p>但如果以获得多个代码执行流为目的，则不应该像上图那样完全分离内存结构，而只需分离栈区域。通过这种方式可以获得如下优势：</p><ul><li>上下文切换时不需要切换数据区和堆</li><li>可以利用数据区和堆交换数据</li></ul><p>实际上这就是线程。线程为了保持多条代码执行流而隔开了栈区域，因此具有如下图所示的内存结构：</p><p><img src="/.io//blog/blog/picture/5c55ab455e399.png"></p><p>如图所示，多个线程共享数据区和堆。为了保持这种结构，线程将在进程内创建并运行。也就是说，进程和线程可以定义为如下形式：</p><ul><li>进程：在操作系统构成单独执行流的单位</li><li>线程：在进程构成单独执行流的单位</li></ul><p>如果说进程在操作系统内部生成多个执行流，那么线程就在同一进程内部创建多条执行流。因此，操作系统、进程、线程之间的关系可以表示为下图：</p><p><img src="/.io//blog/blog/picture/5c55ac20aa776.png"></p><h3 id="18-2-线程创建及运行"><a href="#18-2-线程创建及运行" class="headerlink" title="18.2 线程创建及运行"></a>18.2 线程创建及运行</h3><p>可移植操作系统接口（英语：Portable Operating System Interface，缩写为POSIX）是IEEE为要在各种UNIX操作系统上运行软件，而定义API的一系列互相关联的标准的总称，其正式称呼为IEEE Std 1003，而国际标准名称为ISO&#x2F;IEC 9945。此标准源于一个大约开始于1985年的项目。POSIX这个名称是由理查德·斯托曼（RMS）应IEEE的要求而提议的一个易于记忆的名称。它基本上是Portable Operating System Interface（可移植操作系统接口）的缩写，而X则表明其对Unix API的传承。</p><p>Linux基本上逐步实现了POSIX兼容，但并没有参加正式的POSIX认证。</p><p>微软的Windows NT声称部分实现了POSIX标准。</p><p>当前的POSIX主要分为四个部分：Base Definitions、System Interfaces、Shell and Utilities和Rationale。</p><h4 id="18-2-1-线程的创建和执行流程"><a href="#18-2-1-线程的创建和执行流程" class="headerlink" title="18.2.1 线程的创建和执行流程"></a>18.2.1 线程的创建和执行流程</h4><p>线程具有单独的执行流，因此需要单独定义线程的 main 函数，还需要请求操作系统在单独的执行流中执行该函数，完成函数功能的函数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_create</span><span class="hljs-params">(<span class="hljs-type">pthread_t</span> *<span class="hljs-keyword">restrict</span> thread,</span><br><span class="hljs-params">                   <span class="hljs-type">const</span> <span class="hljs-type">pthread_attr_t</span> *<span class="hljs-keyword">restrict</span> attr,</span><br><span class="hljs-params">                   <span class="hljs-type">void</span> *(*start_routine)(<span class="hljs-type">void</span> *),</span><br><span class="hljs-params">                   <span class="hljs-type">void</span> *<span class="hljs-keyword">restrict</span> arg)</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">成功时返回 0 ，失败时返回 -1</span><br><span class="hljs-comment">thread : 保存新创建线程 ID 的变量地址值。线程与进程相同，也需要用于区分不同线程的 ID</span><br><span class="hljs-comment">attr : 用于传递线程属性的参数，传递 NULL 时，创建默认属性的线程</span><br><span class="hljs-comment">start_routine : 相当于线程 main 函数的、在单独执行流中执行的函数地址值（函数指针）</span><br><span class="hljs-comment">arg : 通过第三个参数传递的调用函数时包含传递参数信息的变量地址值</span><br><span class="hljs-comment">    //传递参数变量的地址给start_routine函数</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>下面通过简单示例了解该函数功能：</p><ul><li><a href="https://github.com/riba2534/TCP-IP-NetworkNote/blob/master/ch18/thread1.c">thread1.c</a></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-type">void</span> *<span class="hljs-title function_">thread_main</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br>    <span class="hljs-type">pthread_t</span> t_id;<br>    <span class="hljs-type">int</span> thread_param = <span class="hljs-number">5</span>;<br>    <span class="hljs-comment">// 请求创建一个线程，从 thread_main 调用开始，在单独的执行流中运行。同时传递参数</span><br>    <span class="hljs-keyword">if</span> (pthread_create(&amp;t_id, <span class="hljs-literal">NULL</span>, thread_main, (<span class="hljs-type">void</span> *)&amp;thread_param) != <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;pthread_create() error&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    sleep(<span class="hljs-number">10</span>); <span class="hljs-comment">//延迟进程终止时间</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;end of main&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-type">void</span> *<span class="hljs-title function_">thread_main</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span> <span class="hljs-comment">//传入的参数是 pthread_create 的第四个</span><br>&#123;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-type">int</span> cnt = *((<span class="hljs-type">int</span> *)arg);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; cnt; i++)<br>    &#123;<br>        sleep(<span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;running thread&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc thread1.c -o tr1 -lpthread # 线程相关代码编译时需要添加 -lpthread 选项声明需要连接到线程库<br>./tr1<br></code></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/.io//blog/blog/picture/5c55b5eb4daf6.png"></p><p>上述程序的执行如图所示：</p><p><img src="/.io//blog/blog/picture/5c55b6943255b.png"></p><p>可以看出，程序在主进程没有结束时，生成的线程每隔一秒输出一次 <code>running thread</code> ，但是如果主进程没有等待十秒，而是直接结束，这样也会强制结束线程，不论线程有没有运行完毕。</p><p>那是否意味着主进程必须每次都 sleep 来等待线程执行完毕？并不需要，可以通过以下函数解决。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_join</span><span class="hljs-params">(<span class="hljs-type">pthread_t</span> thread, <span class="hljs-type">void</span> **status)</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">成功时返回 0 ，失败时返回 -1</span><br><span class="hljs-comment">thread : 该参数值 ID 的线程终止后才会从该函数返回</span><br><span class="hljs-comment">status : 保存线程的 main 函数返回值的指针变量地址值</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>作用就是调用该函数的进程（或线程）将进入等待状态，知道第一个参数为 ID 的线程终止为止。而且可以得到线程的 main 函数的返回值。下面是该函数的用法代码：</p><ul><li><a href="https://github.com/riba2534/TCP-IP-NetworkNote/blob/master/ch18/thread2.c">thread2.c</a></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-type">void</span> *<span class="hljs-title function_">thread_main</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br>    <span class="hljs-type">pthread_t</span> t_id;<br>    <span class="hljs-type">int</span> thread_param = <span class="hljs-number">5</span>;<br>    <span class="hljs-type">void</span> *thr_ret;<br>    <span class="hljs-comment">// 请求创建一个线程，从 thread_main 调用开始，在单独的执行流中运行。同时传递参数</span><br>    <span class="hljs-keyword">if</span> (pthread_create(&amp;t_id, <span class="hljs-literal">NULL</span>, thread_main, (<span class="hljs-type">void</span> *)&amp;thread_param) != <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;pthread_create() error&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-comment">//main函数将等待 ID 保存在 t_id 变量中的线程终止</span><br>    <span class="hljs-keyword">if</span> (pthread_join(t_id, &amp;thr_ret) != <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;pthread_join() error&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Thread return message : %s \n&quot;</span>, (<span class="hljs-type">char</span> *)thr_ret);<br>    <span class="hljs-built_in">free</span>(thr_ret);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-type">void</span> *<span class="hljs-title function_">thread_main</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span> <span class="hljs-comment">//传入的参数是 pthread_create 的第四个</span><br>&#123;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-type">int</span> cnt = *((<span class="hljs-type">int</span> *)arg);<br>    <span class="hljs-type">char</span> *msg = (<span class="hljs-type">char</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">char</span>) * <span class="hljs-number">50</span>);<br>    <span class="hljs-built_in">strcpy</span>(msg, <span class="hljs-string">&quot;Hello,I&#x27;am thread~ \n&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; cnt; i++)<br>    &#123;<br>        sleep(<span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;running thread&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-type">void</span> *)msg; <span class="hljs-comment">//返回值是 thread_main 函数中内部动态分配的内存空间地址值</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>关于<code>void *msg</code>和<code>void *thr_ret</code></strong></p><blockquote><p>将<code>pointer thr_ret</code>的地址改成<code>pointer msg</code>的地址，即 <code>*thr_ret</code>获得的是<code>msg</code>指向的数据，即<code>*msg</code>。也可以看作引用。</p></blockquote><p>编译运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc thread2.c -o tr2 -lpthread <br>./tr2<br></code></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/.io//blog/blog/picture/5c55bd6032f1e.png"></p><p>可以看出，线程输出了5次字符串，并且把返回值给了主进程</p><p>下面是该函数的执行流程图：</p><p><img src="/.io//blog/blog/picture/5c55bdd3bb3c8.png"></p><h4 id="18-2-2-可在临界区内调用的函数"><a href="#18-2-2-可在临界区内调用的函数" class="headerlink" title="18.2.2 可在临界区内调用的函数"></a>18.2.2 可在临界区内调用的函数</h4><p>在同步的程序设计中，临界区块（Critical section）指的是一个访问共享资源（例如：共享设备或是共享存储器）的程序片段，而这些共享资源有无法同时被多个线程访问的特性。</p><p>当有线程进入临界区块时，其他线程或是进程必须等待（例如：bounded waiting 等待法），有一些同步的机制必须在临界区块的进入点与离开点实现，以确保这些共享资源是被异或的使用，例如：semaphore。</p><p>只能被单一线程访问的设备，例如：打印机。</p><p>一个最简单的实现方法就是当线程（Thread）进入临界区块时，禁止改变处理器；在uni-processor系统上，可以用“禁止中断（CLI）”来完成，避免发生系统调用（System Call）导致的上下文交换（Context switching）；当离开临界区块时，处理器恢复原先的状态。</p><p>根据临界区是否引起问题，函数可以分为以下 2 类：</p><ul><li>线程安全函数（Thread-safe function）</li><li>非线程安全函数（Thread-unsafe function）</li></ul><p>线程安全函数被多个线程同时调用也不会发生问题。反之，非线程安全函数被同时调用时会引发问题。但这并非有关于临界区的讨论，线程安全的函数中同样可能存在临界区。只是在线程安全的函数中，同时被多个线程调用时可通过一些措施避免问题。</p><p>幸运的是，大多数标准函数都是线程安全函数。操作系统在定义非线程安全函数的同时，提供了具有相同功能的线程安全的函数。比如，第 8 章的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> hostent *<span class="hljs-title function_">gethostbyname</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *hostname)</span>;<br></code></pre></td></tr></table></figure><p>同时，也提供了同一功能的安全函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> hostent *<span class="hljs-title function_">gethostbyname_r</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name,</span><br><span class="hljs-params">                                <span class="hljs-keyword">struct</span> hostent *result,</span><br><span class="hljs-params">                                <span class="hljs-type">char</span> *buffer,</span><br><span class="hljs-params">                                <span class="hljs-type">int</span> intbuflen,</span><br><span class="hljs-params">                                <span class="hljs-type">int</span> *h_errnop)</span>;<br></code></pre></td></tr></table></figure><p>线程安全函数结尾通常是 <code>_r</code> 。但是使用线程安全函数会给程序员带来额外的负担，可以通过以下方法自动将 gethostbyname 函数调用改为 gethostbyname_r 函数调用。</p><blockquote><p>声明头文件前定义 <code>_REENTRANT</code> 宏。</p></blockquote><p>无需特意更改源代码加，可以在编译的时候指定编译参数定义宏。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc -D_REENTRANT mythread.c -o mthread -lpthread<br></code></pre></td></tr></table></figure><h4 id="18-2-3-工作（Worker）线程模型"><a href="#18-2-3-工作（Worker）线程模型" class="headerlink" title="18.2.3 工作（Worker）线程模型"></a>18.2.3 工作（Worker）线程模型</h4><p>下面的示例是计算从 1 到 10 的和，但并不是通过 main 函数进行运算，而是创建两个线程，其中一个线程计算 1 到 5 的和，另一个线程计算 6 到 10 的和，main 函数只负责输出运算结果。这种方式的线程模型称为「工作线程」。显示该程序的执行流程图：</p><p><img src="/.io//blog/blog/picture/5c55c330e8b5b.png"></p><p>下面是代码：</p><ul><li><a href="https://github.com/riba2534/TCP-IP-NetworkNote/blob/master/ch18/thread3.c">thread3.c</a></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-type">void</span> *<span class="hljs-title function_">thread_summation</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span>;<br><span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br>    <span class="hljs-type">pthread_t</span> id_t1, id_t2;<br>    <span class="hljs-type">int</span> range1[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">5</span>&#125;;<br>    <span class="hljs-type">int</span> range2[] = &#123;<span class="hljs-number">6</span>, <span class="hljs-number">10</span>&#125;;<br><br>    pthread_create(&amp;id_t1, <span class="hljs-literal">NULL</span>, thread_summation, (<span class="hljs-type">void</span> *)range1);<br>    pthread_create(&amp;id_t2, <span class="hljs-literal">NULL</span>, thread_summation, (<span class="hljs-type">void</span> *)range2);<br><br>    pthread_join(id_t1, <span class="hljs-literal">NULL</span>);<br>    pthread_join(id_t2, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;result: %d \n&quot;</span>, sum);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-type">void</span> *<span class="hljs-title function_">thread_summation</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span><br>&#123;<br>    <span class="hljs-type">int</span> start = ((<span class="hljs-type">int</span> *)arg)[<span class="hljs-number">0</span>];<br>    <span class="hljs-type">int</span> end = ((<span class="hljs-type">int</span> *)arg)[<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">while</span> (start &lt;= end)<br>    &#123;<br>        sum += start;<br>        start++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc thread3.c -D_REENTRANT -o tr3 -lpthread<br>./tr3<br></code></pre></td></tr></table></figure><p>结果：</p><p><img src="/.io//blog/blog/picture/5c55c53d70494.png"></p><p>可以看出计算结果正确，两个线程都用了全局变量 sum ,证明了 2 个线程共享保存全局变量的数据区。</p><p>但是本例子本身存在问题。存在临界区相关问题，可以从下面的代码看出，下面的代码和上面的代码相似，只是增加了发生临界区错误的可能性，即使在高配置系统环境下也容易产生的错误：</p><ul><li><a href="https://github.com/riba2534/TCP-IP-NetworkNote/blob/master/ch18/thread4.c">thread4.c</a></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NUM_THREAD 100</span><br><br><span class="hljs-type">void</span> *<span class="hljs-title function_">thread_inc</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span>;<br><span class="hljs-type">void</span> *<span class="hljs-title function_">thread_des</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span>;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> num = <span class="hljs-number">0</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br>    <span class="hljs-type">pthread_t</span> thread_id[NUM_THREAD];<br>    <span class="hljs-type">int</span> i;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;sizeof long long: %d \n&quot;</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">long</span> <span class="hljs-type">long</span>));<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; NUM_THREAD; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span>)<br>            pthread_create(&amp;(thread_id[i]), <span class="hljs-literal">NULL</span>, thread_inc, <span class="hljs-literal">NULL</span>);<br>        <span class="hljs-keyword">else</span><br>            pthread_create(&amp;(thread_id[i]), <span class="hljs-literal">NULL</span>, thread_des, <span class="hljs-literal">NULL</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; NUM_THREAD; i++)<br>        pthread_join(thread_id[i], <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;result: %lld \n&quot;</span>, num);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">void</span> *<span class="hljs-title function_">thread_inc</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span><br>&#123;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">50000000</span>; i++)<br>        num += <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><span class="hljs-type">void</span> *<span class="hljs-title function_">thread_des</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span><br>&#123;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">50000000</span>; i++)<br>        num -= <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc thread4.c -D_REENTRANT -o tr4 -lpthread<br>./tr4<br></code></pre></td></tr></table></figure><p>结果：</p><p><img src="/.io//blog/blog/picture/5c55c884e7c11.png"></p><p>从图上可以看出，每次运行的结果竟然不一样。理论上来说，上面代码的最后结果应该是 0 。原因暂时不得而知，但是可以肯定的是，这对于线程的应用是个大问题。</p><h3 id="18-3-线程存在的问题和临界区"><a href="#18-3-线程存在的问题和临界区" class="headerlink" title="18.3 线程存在的问题和临界区"></a>18.3 线程存在的问题和临界区</h3><p>下面分析 <a href="https://github.com/riba2534/TCP-IP-NetworkNote/blob/master/ch18/thread4.c">thread4.c</a> 中产生问题的原因，并给出解决方案。</p><h4 id="18-3-1-多个线程访问同一变量是问题"><a href="#18-3-1-多个线程访问同一变量是问题" class="headerlink" title="18.3.1 多个线程访问同一变量是问题"></a>18.3.1 多个线程访问同一变量是问题</h4><p> <a href="https://github.com/riba2534/TCP-IP-NetworkNote/blob/master/ch18/thread4.c">thread4.c</a> 的问题如下：</p><blockquote><p>2 个线程正在同时访问全局变量 num</p></blockquote><p>任何内存空间，只要被同时访问，都有可能发生问题。</p><p>因此，线程访问变量 num 时应该阻止其他线程访问，直到线程 1 运算完成。这就是同步（Synchronization）</p><h4 id="18-3-2-临界区位置"><a href="#18-3-2-临界区位置" class="headerlink" title="18.3.2 临界区位置"></a>18.3.2 临界区位置</h4><p>那么在刚才代码中的临界区位置是：</p><blockquote><p>函数内同时运行多个线程时引发问题的多条语句构成的代码块</p></blockquote><p>全局变量 num 不能视为临界区，因为他不是引起问题的语句，只是一个内存区域的声明。下面是刚才代码的两个 main 函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<span class="hljs-title function_">thread_inc</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span><br>&#123;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">50000000</span>; i++)<br>        num += <span class="hljs-number">1</span>;<span class="hljs-comment">//临界区</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><span class="hljs-type">void</span> *<span class="hljs-title function_">thread_des</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span><br>&#123;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">50000000</span>; i++)<br>        num -= <span class="hljs-number">1</span>;<span class="hljs-comment">//临界区</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>由上述代码可知，临界区并非 num 本身，而是访问 num 的两条语句，这两条语句可能由多个线程同时运行，也是引起这个问题的直接原因。产生问题的原因可以分为以下三种情况：</p><ul><li>2 个线程同时执行 thread_inc 函数</li><li>2 个线程同时执行 thread_des 函数</li><li>2 个线程分别执行 thread_inc 和 thread_des 函数</li></ul><p>比如发生以下情况：</p><blockquote><p>线程 1 执行 thread_inc 的 num+&#x3D;1 语句的同时，线程 2  执行 thread_des 函数的 num-&#x3D;1 语句</p></blockquote><p>也就是说，两条不同的语句由不同的线程执行时，也有可能构成临界区。前提是这 2 条语句访问同一内存空间。</p><h3 id="18-4-线程同步"><a href="#18-4-线程同步" class="headerlink" title="18.4 线程同步"></a>18.4 线程同步</h3><p>前面讨论了线程中存在的问题，下面就是解决方法，线程同步。</p><h4 id="18-4-1-同步的两面性"><a href="#18-4-1-同步的两面性" class="headerlink" title="18.4.1 同步的两面性"></a>18.4.1 同步的两面性</h4><p>线程同步用于解决线程访问顺序引发的问题。需要同步的情况可以从如下两方面考虑。</p><ul><li>同时访问同一内存空间时发生的情况</li><li>需要指定访问同一内存空间的线程顺序的情况</li></ul><p>情况一之前已经解释过，下面讨论情况二。这是「控制线程执行的顺序」的相关内容。假设有 A B 两个线程，线程 A 负责向指定的内存空间内写入数据，线程 B 负责取走该数据。所以这是有顺序的，不按照顺序就可能发生问题。所以这种也需要进行同步。</p><h4 id="18-4-2-互斥量"><a href="#18-4-2-互斥量" class="headerlink" title="18.4.2 互斥量"></a>18.4.2 互斥量</h4><p>互斥锁（英语：英语：Mutual exclusion，缩写 Mutex）是一种用于多线程编程中，防止两条线程同时对同一公共资源（比如全域变量）进行读写的机制。该目的通过将代码切片成一个一个的临界区域（critical section）达成。临界区域指的是一块对公共资源进行访问的代码，并非一种机制或是算法。一个程序、进程、线程可以拥有多个临界区域，但是并不一定会应用互斥锁。</p><p>通俗的说就互斥量就是一把优秀的锁，当临界区被占据的时候就上锁，等占用完毕然后再放开。</p><p>下面是互斥量的创建及销毁函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_mutex_init</span><span class="hljs-params">(<span class="hljs-type">pthread_mutex_t</span> *mutex,</span><br><span class="hljs-params">                       <span class="hljs-type">const</span> <span class="hljs-type">pthread_mutexattr_t</span> *attr)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_mutex_destroy</span><span class="hljs-params">(<span class="hljs-type">pthread_mutex_t</span> *mutex)</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">成功时返回 0，失败时返回其他值</span><br><span class="hljs-comment">mutex : 创建互斥量时传递保存互斥量的变量地址值，销毁时传递需要销毁的互斥量地址</span><br><span class="hljs-comment">attr : 传递即将创建的互斥量属性，没有特别需要指定的属性时传递 NULL</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>从上述函数声明中可以看出，为了创建相当于锁系统的互斥量，需要声明如下 pthread_mutex_t 型变量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">pthread_mutex_t</span> mutex<br></code></pre></td></tr></table></figure><p>该变量的地址值传递给 pthread_mutex_init 函数，用来保存操作系统创建的互斥量（锁系统）。调用 pthread_mutex_destroy 函数时同样需要该信息。如果不需要配置特殊的互斥量属性，则向第二个参数传递 NULL 时，可以利用 PTHREAD_MUTEX_INITIALIZER 进行如下声明：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;<br></code></pre></td></tr></table></figure><p>推荐尽可能的使用 pthread_mutex_init 函数进行初始化，因为通过宏进行初始化时很难发现发生的错误。</p><p>下面是利用互斥量锁住或释放临界区时使用的函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_mutex_lock</span><span class="hljs-params">(<span class="hljs-type">pthread_mutex_t</span> *mutex)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_mutex_unlock</span><span class="hljs-params">(<span class="hljs-type">pthread_mutex_t</span> *mutex)</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">成功时返回 0 ，失败时返回其他值</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>函数本身含有 lock unlock 等词汇，很容易理解其含义。进入临界区前调用的函数就是 pthread_mutex_lock 。调用该函数时，发现有其他线程已经进入临界区，则 pthread_mutex_lock 函数不会返回，直到里面的线程调用 pthread_mutex_unlock 函数退出临界区位置。也就是说，其他线程让出临界区之前，当前线程一直处于阻塞状态。接下来整理一下代码的编写方式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">pthread_mutex_lock(&amp;mutex);<br><span class="hljs-comment">//临界区开始</span><br><span class="hljs-comment">//...</span><br><span class="hljs-comment">//临界区结束</span><br>pthread_mutex_unlock(&amp;mutex);<br></code></pre></td></tr></table></figure><p>简言之，就是利用 lock 和 unlock 函数围住临界区的两端。此时互斥量相当于一把锁，阻止多个线程同时访问，还有一点要注意，线程退出临界区时，如果忘了调用 pthread_mutex_unlock 函数，那么其他为了进入临界区而调用 pthread_mutex_lock 的函数无法摆脱阻塞状态。这种情况称为「死锁」。需要格外注意，下面是利用互斥量解决示例 <a href="https://github.com/riba2534/TCP-IP-NetworkNote/blob/master/ch18/thread4.c">thread4.c</a> 中遇到的问题代码：</p><ul><li><a href="https://github.com/riba2534/TCP-IP-NetworkNote/blob/master/ch18/mutex.c">mutex.c</a></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NUM_THREAD 100</span><br><span class="hljs-type">void</span> *<span class="hljs-title function_">thread_inc</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span>;<br><span class="hljs-type">void</span> *<span class="hljs-title function_">thread_des</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span>;<br><br><span class="hljs-type">long</span> <span class="hljs-type">long</span> num = <span class="hljs-number">0</span>;<br><span class="hljs-type">pthread_mutex_t</span> mutex; <span class="hljs-comment">//保存互斥量读取值的变量</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br>    <span class="hljs-type">pthread_t</span> thread_id[NUM_THREAD];<br>    <span class="hljs-type">int</span> i;<br><br>    pthread_mutex_init(&amp;mutex, <span class="hljs-literal">NULL</span>); <span class="hljs-comment">//创建互斥量</span><br><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; NUM_THREAD; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span>)<br>            pthread_create(&amp;(thread_id[i]), <span class="hljs-literal">NULL</span>, thread_inc, <span class="hljs-literal">NULL</span>);<br>        <span class="hljs-keyword">else</span><br>            pthread_create(&amp;(thread_id[i]), <span class="hljs-literal">NULL</span>, thread_des, <span class="hljs-literal">NULL</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; NUM_THREAD; i++)<br>        pthread_join(thread_id[i], <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;result: %lld \n&quot;</span>, num);<br>    pthread_mutex_destroy(&amp;mutex); <span class="hljs-comment">//销毁互斥量</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">void</span> *<span class="hljs-title function_">thread_inc</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span><br>&#123;<br>    <span class="hljs-type">int</span> i;<br>    pthread_mutex_lock(&amp;mutex); <span class="hljs-comment">//上锁</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">50000000</span>; i++)<br>        num += <span class="hljs-number">1</span>;<br>    pthread_mutex_unlock(&amp;mutex); <span class="hljs-comment">//解锁</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><span class="hljs-type">void</span> *<span class="hljs-title function_">thread_des</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span><br>&#123;<br>    <span class="hljs-type">int</span> i;<br>    pthread_mutex_lock(&amp;mutex);<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">50000000</span>; i++)<br>        num -= <span class="hljs-number">1</span>;<br>    pthread_mutex_unlock(&amp;mutex);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc mutex.c -D_REENTRANT -o mutex -lpthread<br>./mutex<br></code></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/.io//blog/blog/picture/5c567e4aafbb8.png"></p><p>从运行结果可以看出，通过互斥量机制得出了正确的运行结果。</p><p>在代码中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<span class="hljs-title function_">thread_inc</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span><br>&#123;<br>    <span class="hljs-type">int</span> i;<br>    pthread_mutex_lock(&amp;mutex); <span class="hljs-comment">//上锁</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">50000000</span>; i++)<br>        num += <span class="hljs-number">1</span>;<br>    pthread_mutex_unlock(&amp;mutex); <span class="hljs-comment">//解锁</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上代码的临界区划分范围较大，但这是考虑如下优点所做的决定:</p><blockquote><p>最大限度减少互斥量 lock unlock 函数的调用次数</p></blockquote><h4 id="18-4-3-信号量"><a href="#18-4-3-信号量" class="headerlink" title="18.4.3 信号量"></a>18.4.3 信号量</h4><p>信号量（英语：Semaphore）又称为信号标，是一个同步对象，用于保持在0至指定最大值之间的一个计数值。当线程完成一次对该semaphore对象的等待（wait）时，该计数值减一；当线程完成一次对semaphore对象的释放（release）时，计数值加一。当计数值为0，则线程等待该semaphore对象不再能成功直至该semaphore对象变成signaled状态。semaphore对象的计数值大于0，为signaled状态；计数值等于0，为nonsignaled状态.</p><p>semaphore对象适用于控制一个仅支持有限个用户的共享资源，是一种不需要使用忙碌等待（busy waiting）的方法。</p><p>信号量的概念是由荷兰计算机科学家艾兹赫尔·戴克斯特拉（Edsger W. Dijkstra）发明的，广泛的应用于不同的操作系统中。在系统中，给予每一个进程一个信号量，代表每个进程当前的状态，未得到控制权的进程会在特定地方被强迫停下来，等待可以继续进行的信号到来。如果信号量是一个任意的整数，通常被称为计数信号量（Counting semaphore），或一般信号量（general semaphore）；如果信号量只有二进制的0或1，称为二进制信号量（binary semaphore）。在linux系统中，二进制信号量（binary semaphore）又称互斥锁（Mutex）。</p><p>下面介绍信号量，在互斥量的基础上，很容易理解信号量。此处只涉及利用「二进制信号量」（只用 0 和 1）完成「控制线程顺序」为中心的同步方法。下面是信号量的创建及销毁方法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;semaphore.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sem_init</span><span class="hljs-params">(<span class="hljs-type">sem_t</span> *sem, <span class="hljs-type">int</span> pshared, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> value)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">sem_destroy</span><span class="hljs-params">(<span class="hljs-type">sem_t</span> *sem)</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">成功时返回 0 ，失败时返回其他值</span><br><span class="hljs-comment">sem : 创建信号量时保存信号量的变量地址值，销毁时传递需要销毁的信号量变量地址值</span><br><span class="hljs-comment">pshared : 传递其他值时，创建可由多个进程共享的信号量；传递 0 时，创建只允许 1 个进程内部使用的信号量。需要完成同一进程的线程同步，故为0</span><br><span class="hljs-comment">value : 指定创建信号量的初始值</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>上述的 shared 参数超出了我们的关注范围，故默认向其传递为 0 。下面是信号量中相当于互斥量 lock unlock 的函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;semaphore.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sem_post</span><span class="hljs-params">(<span class="hljs-type">sem_t</span> *sem)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">sem_wait</span><span class="hljs-params">(<span class="hljs-type">sem_t</span> *sem)</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">成功时返回 0 ，失败时返回其他值</span><br><span class="hljs-comment">sem : 传递保存信号量读取值的变量地址值，传递给 sem_post 的信号量增1，传递给 sem_wait 时信号量减一</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>调用 sem_init 函数时，操作系统将创建信号量对象，此对象中记录这「信号量值」（Semaphore Value）整数。该值在调用 sem_post 函数时增加 1 ，调用 wait_wait 函数时减一。但信号量的值不能小于 0 ，因此，在信号量为 0 的情况下调用 sem_wait 函数时，调用的线程将进入阻塞状态（因为函数未返回）。当然，此时如果有其他线程调用 sem_post 函数，信号量的值将变为 1 ，而原本阻塞的线程可以将该信号重新减为 0 并跳出阻塞状态。实际上就是通过这种特性完成临界区的同步操作，可以通过如下形式同步临界区（假设信号量的初始值为 1）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">sem_wait(&amp;sem);<span class="hljs-comment">//信号量变为0...</span><br><span class="hljs-comment">// 临界区的开始</span><br><span class="hljs-comment">//...</span><br><span class="hljs-comment">//临界区的结束</span><br>sem_post(&amp;sem);<span class="hljs-comment">//信号量变为1...</span><br></code></pre></td></tr></table></figure><p>上述代码结构中，调用 sem_wait 函数进入临界区的线程在调用 sem_post 函数前不允许其他线程进入临界区。信号量的值在 0 和  1 之间跳转，因此，具有这种特性的机制称为「二进制信号量」。接下来的代码是信号量机制的代码。下面代码并非是同时访问的同步，而是关于控制访问顺序的同步，该场景为：</p><blockquote><p>线程  A 从用户输入得到值后存入全局变量 num ，此时线程 B 将取走该值并累加。该过程一共进行 5 次，完成后输出总和并退出程序。</p></blockquote><p>下面是代码：</p><ul><li><a href="https://github.com/riba2534/TCP-IP-NetworkNote/blob/master/ch18/semaphore.c">semaphore.c</a></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;semaphore.h&gt;</span></span><br><br><span class="hljs-type">void</span> *<span class="hljs-title function_">read</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span>;<br><span class="hljs-type">void</span> *<span class="hljs-title function_">accu</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span>;<br><span class="hljs-type">static</span> <span class="hljs-type">sem_t</span> sem_one;<br><span class="hljs-type">static</span> <span class="hljs-type">sem_t</span> sem_two;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> num;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> <span class="hljs-type">const</span> *argv[])</span><br>&#123;<br>    <span class="hljs-type">pthread_t</span> id_t1, id_t2;<br>    sem_init(&amp;sem_one, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    sem_init(&amp;sem_two, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br><br>    pthread_create(&amp;id_t1, <span class="hljs-literal">NULL</span>, read, <span class="hljs-literal">NULL</span>);<br>    pthread_create(&amp;id_t2, <span class="hljs-literal">NULL</span>, accu, <span class="hljs-literal">NULL</span>);<br><br>    pthread_join(id_t1, <span class="hljs-literal">NULL</span>);<br>    pthread_join(id_t2, <span class="hljs-literal">NULL</span>);<br><br>    sem_destroy(&amp;sem_one);<br>    sem_destroy(&amp;sem_two);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">void</span> *<span class="hljs-title function_">read</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span><br>&#123;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)<br>    &#123;<br>        <span class="hljs-built_in">fputs</span>(<span class="hljs-string">&quot;Input num: &quot;</span>, <span class="hljs-built_in">stdout</span>);<br><br>        sem_wait(&amp;sem_two);<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;num);<br>        sem_post(&amp;sem_one);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><span class="hljs-type">void</span> *<span class="hljs-title function_">accu</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span><br>&#123;<br>    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>, i;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)<br>    &#123;<br>        sem_wait(&amp;sem_one);<br>        sum += num;<br>        sem_post(&amp;sem_two);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Result: %d \n&quot;</span>, sum);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc semaphore.c -D_REENTRANT -o sema -lpthread<br>./sema<br></code></pre></td></tr></table></figure><p>结果：</p><p><img src="/.io//blog/blog/picture/5c568c2717d1e.png"></p><p>从上述代码可以看出，设置了两个信号量 one 的初始值为 0 ，two 的初始值为 1，然后在调用函数的时候，「读」的前提是 two 可以减一，如果不能减一就会阻塞在这里，一直等到「计算」操作完毕后，给 two 加一，然后就可以继续执行下一句输入。对于「计算」函数，也一样。</p><h3 id="18-5-线程的销毁和多线程并发服务器端的实现"><a href="#18-5-线程的销毁和多线程并发服务器端的实现" class="headerlink" title="18.5 线程的销毁和多线程并发服务器端的实现"></a>18.5 线程的销毁和多线程并发服务器端的实现</h3><p>先介绍线程的销毁，然后再介绍多线程服务端</p><h4 id="18-5-1-销毁线程的-3-种方法"><a href="#18-5-1-销毁线程的-3-种方法" class="headerlink" title="18.5.1 销毁线程的 3 种方法"></a>18.5.1 销毁线程的 3 种方法</h4><p>Linux 的线程并不是在首次调用的线程 main 函数返回时自动销毁，所以利用如下方法之一加以明确。否则由线程创建的内存空间将一直存在。</p><ul><li>调用 pthread_join 函数</li><li>调用 pthread_detach 函数</li></ul><p>之前调用过 pthread_join 函数。调用该函数时，不仅会等待线程终止，还会引导线程销毁。但该函数的问题是，线程终止前，调用该函数的线程将进入阻塞状态。因此，通过如下函数调用引导线程销毁。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_detach</span><span class="hljs-params">(<span class="hljs-type">pthread_t</span> th)</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">成功时返回 0 ，失败时返回其他值</span><br><span class="hljs-comment">thread : 终止的同时需要销毁的线程 ID</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>调用上述函数不会引起线程终止或进入阻塞状态，可以通过该函数引导销毁线程创建的内存空间。调用该函数后不能再针对相应线程调用 pthread_join 函数。</p><h4 id="18-5-2-多线程并发服务器端的实现"><a href="#18-5-2-多线程并发服务器端的实现" class="headerlink" title="18.5.2 多线程并发服务器端的实现"></a>18.5.2 多线程并发服务器端的实现</h4><p>下面是多个客户端之间可以交换信息的简单聊天程序。</p><ul><li><a href="https://github.com/riba2534/TCP-IP-NetworkNote/blob/master/ch18/chat_server.c">chat_server.c</a></li><li><a href="https://github.com/riba2534/TCP-IP-NetworkNote/blob/master/ch18/chat_clnt.c">chat_clnt.c</a></li></ul><p>上面的服务端示例中，需要掌握临界区的构成，访问全局变量 clnt_cnt 和数组 clnt_socks 的代码将构成临界区，添加和删除客户端时，变量 clnt_cnt 和数组 clnt_socks 将同时发生变化。因此下列情形会导致数据不一致，从而引发错误：</p><ul><li>线程 A 从数组 clnt_socks 中删除套接字信息，同时线程 B 读取 clnt_cnt 变量</li><li>线程 A 读取变量 clnt_cnt ，同时线程 B 将套接字信息添加到 clnt_socks 数组</li></ul><p>编译运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc chat_server.c -D_REENTRANT -o cserv -lpthread<br>gcc chat_clnt.c -D_REENTRANT -o cclnt -lpthread<br>./cserv 9191<br>./cclnt 127.0.0.1 9191 张三<br>./cclnt 127.0.0.1 9191 李四<br></code></pre></td></tr></table></figure><p>结果：</p><p><img src="/.io//blog/blog/picture/5c569b70634ff.png"></p><h3 id="18-6-习题"><a href="#18-6-习题" class="headerlink" title="18.6 习题"></a>18.6 习题</h3><blockquote><p>以下答案仅代表本人个人观点，可能不是正确答案。</p></blockquote><ol><li><p><strong>单 CPU 系统中如何同时执行多个进程？请解释该过程中发生的上下文切换</strong>。</p><p>答：系统将 CPU 时间分成多个微笑的块后分配给了多个进程。为了分时使用 CPU ，需要「上下文切换」过程。运行程序前需要将相应进程信息读入内存，如果运行进程 A 后需要紧接着运行进程 B ，就应该将进程 A 相关今夕移出内存，并读入进程 B 的信息。这就是上下文切换</p></li><li><p><strong>为何线程的上下文切换速度相对更快？线程间数据交换为何不需要类似 IPC 特别技术</strong>。</p><p>答：线程上下文切换过程不需要切换数据区和堆。可以利用数据区和堆交换数据。</p></li><li><p><strong>请从执行流角度说明进程和线程的区别</strong>。</p><p>答：进程：在操作系统构成单独执行流的单位。线程：在进程内部构成单独执行流的单位。线程为了保持多条代码执行流而隔开了栈区域。</p></li><li><p><strong>下面关于临界区的说法错误的是</strong>？</p><p>答：下面加粗的选项为说法正确。（全错）</p><ol><li>临界区是多个线程同时访问时发生问题的区域</li><li>线程安全的函数中不存在临界区，即便多个线程同时调用也不会发生问题</li><li>1 个临界区只能由 1 个代码块，而非多个代码块构成。换言之，线程 A 执行的代码块 A 和线程 B 执行的代码块 B 之间绝对不会构成临界区。</li><li>临界区由访问全局变量的代码构成。其他变量中不会发生问题。</li></ol></li><li><p><strong>下列关于线程同步的说法错误的是</strong>？</p><p>答：下面加粗的选项为说法正确。</p><ol><li>线程同步就是限制访问临界区</li><li><strong>线程同步也具有控制线程执行顺序的含义</strong></li><li><strong>互斥量和信号量是典型的同步技术</strong></li><li>线程同步是代替进程 IPC 的技术。</li></ol></li><li><p><strong>请说明完全销毁 Linux 线程的 2 种办法</strong></p><p>答：①调用 pthread_join 函数②调用 pthread_detach 函数。第一个会阻塞调用的线程，而第二个不阻塞。都可以引导线程销毁。</p></li></ol><h2 id="第-19-章-Windows-平台下线程的使用"><a href="#第-19-章-Windows-平台下线程的使用" class="headerlink" title="第 19 章 Windows 平台下线程的使用"></a>第 19 章 Windows 平台下线程的使用</h2><h2 id="第-20-章-Windows-中的线程同步"><a href="#第-20-章-Windows-中的线程同步" class="headerlink" title="第 20 章 Windows 中的线程同步"></a>第 20 章 Windows 中的线程同步</h2><p>暂略</p><h2 id="第-21-章-异步通知-I-O-模型"><a href="#第-21-章-异步通知-I-O-模型" class="headerlink" title="第 21 章 异步通知 I&#x2F;O 模型"></a>第 21 章 异步通知 I&#x2F;O 模型</h2><p>暂略</p><h2 id="第-22-章-重叠-I-O-模型"><a href="#第-22-章-重叠-I-O-模型" class="headerlink" title="第 22 章 重叠 I&#x2F;O 模型"></a>第 22 章 重叠 I&#x2F;O 模型</h2><p>暂略</p><h2 id="第-23-章-IOCP"><a href="#第-23-章-IOCP" class="headerlink" title="第 23 章 IOCP"></a>第 23 章 IOCP</h2><p>暂略</p><h2 id="第-24-章-制作-HTTP-服务器端"><a href="#第-24-章-制作-HTTP-服务器端" class="headerlink" title="第 24 章 制作 HTTP 服务器端"></a>第 24 章 制作 HTTP 服务器端</h2><p>本章代码，在<a href="https://github.com/riba2534/TCP-IP-NetworkNote">TCP-IP-NetworkNote</a>中可以找到。</p><h3 id="24-1-HTTP-概要"><a href="#24-1-HTTP-概要" class="headerlink" title="24.1 HTTP 概要"></a>24.1 HTTP 概要</h3><p>本章将编写 HTTP（HyperText Transfer Protocol，超文本传输协议）服务器端，即 Web 服务器端。</p><h4 id="24-1-1-理解-Web-服务器端"><a href="#24-1-1-理解-Web-服务器端" class="headerlink" title="24.1.1 理解 Web 服务器端"></a>24.1.1 理解 Web 服务器端</h4><p>web服务器端就是要基于 HTTP 协议，将网页对应文件传输给客户端的服务器端。</p><h4 id="24-1-2-HTTP"><a href="#24-1-2-HTTP" class="headerlink" title="24.1.2 HTTP"></a>24.1.2 HTTP</h4><p>无状态的 Stateless 协议</p><p><img src="/.io//blog/blog/picture/5c5bc6973a4d0.png"></p><p>从上图可以看出，服务器端相应客户端请求后立即断开连接。换言之，服务器端不会维持客户端状态。即使同一客户端再次发送请求，服务器端也无法辨认出是原先那个，而会以相同方式处理新请求。因此，HTTP 又称「无状态的 Stateless 协议」</p><p><strong>Cookie &amp; Session</strong></p><blockquote><p>为了弥补HTTP无法保持连接的缺点,Web编程中通常会使用Cookie和Session技术。相信各位都接触过购物网站的购物车功能,即使关闭浏览器也不会丢失购物车内的信息(甚至不用登录)。这种保持状态的功能都是通过Cookie和 Session技术实现的。</p></blockquote><h4 id="24-1-3-请求消息（Request-Message）的结构"><a href="#24-1-3-请求消息（Request-Message）的结构" class="headerlink" title="24.1.3 请求消息（Request Message）的结构"></a>24.1.3 请求消息（Request Message）的结构</h4><p>下面是客户端向服务端发起请求消息的结构：</p><p><img src="/.io//blog/blog/picture/5c5bcbb75202f.png"></p><p>从图中可以看出，请求消息可以分为请求头、消息头、消息体 3 个部分。其中，请求行含有请求方式（请求目的）信息。典型的请求方式有 GET 和 POST ，GET 主要用于请求数据，POST 主要用于传输数据。为了降低复杂度，我们实现只能响应 GET 请求的 Web 服务器端，下面解释图中的请求行信息。其中「GET&#x2F;index.html HTTP&#x2F;1.1」 具有如下含义：</p><blockquote><p>请求（GET）index.html 文件，通常以 1.1 版本的 HTTP 协议进行通信。</p></blockquote><p>请求行只能通过  1 行（line）发送，因此，服务器端很容易从 HTTP 请求中提取第一行，并分别分析请求行中的信息。</p><p>请求行下面的消息头中包含发送请求的浏览器信息、用户认证信息等关于 HTTP 消息的附加信息。最后的消息体中装有客户端向服务端传输的数据，为了装入数据，需要以 POST 方式发送请求。但是我们的目标是实现 GET 方式的服务器端，所以可以忽略这部分内容。另外，消息体和消息头与之间以空行隔开，因此不会发生边界问题</p><h4 id="24-1-4-响应消息（Response-Message）的结构"><a href="#24-1-4-响应消息（Response-Message）的结构" class="headerlink" title="24.1.4 响应消息（Response Message）的结构"></a>24.1.4 响应消息（Response Message）的结构</h4><p>下面是 Web 服务器端向客户端传递的响应信息的结构。从图中可以看出，该响应消息由状态行、头信息、消息体等 3 个部分组成。状态行中有关于请求的状态信息，这是与请求消息相比最为显著地区别。</p><p><img src="/.io//blog/blog/picture/5c5bf9ad1b5f9.png"></p><p>第一个字符串状态行中含有关于客户端请求的处理结果。例如，客户端请求 index.html 文件时，表示 index.html 文件是否存在、服务端是否发生问题而无法响应等不同情况的信息写入状态行。图中的「HTTP&#x2F;1.1 200 OK」具有如下含义：</p><ul><li>200 OK : 成功处理了请求!</li><li>404 Not Found : 请求的文件不存在!</li><li>400 Bad Request : 请求方式错误，请检查！</li></ul><p>消息头中含有传输的数据类型和长度等信息。图中的消息头含有如下信息：</p><blockquote><p>服务端名为 SimpleWebServer ，传输的数据类型为 text&#x2F;html。数据长度不超过 2048 个字节。</p></blockquote><p>最后插入一个空行后，通过消息体发送客户端请求的文件数据。以上就是实现 Web 服务端过程中必要的 HTTP 协议。</p><h3 id="24-2-实现简单的-Web-服务器端"><a href="#24-2-实现简单的-Web-服务器端" class="headerlink" title="24.2 实现简单的 Web 服务器端"></a>24.2 实现简单的 Web 服务器端</h3><h4 id="24-2-1-实现基于-Windows-的多线程-Web-服务器端"><a href="#24-2-1-实现基于-Windows-的多线程-Web-服务器端" class="headerlink" title="24.2.1 实现基于 Windows 的多线程 Web 服务器端"></a>24.2.1 实现基于 Windows 的多线程 Web 服务器端</h4><p>暂略</p><h4 id="24-2-2-实现基于-Linux-的多线程-Web-服务器端"><a href="#24-2-2-实现基于-Linux-的多线程-Web-服务器端" class="headerlink" title="24.2.2 实现基于 Linux 的多线程 Web 服务器端"></a>24.2.2 实现基于 Linux 的多线程 Web 服务器端</h4><p>下面是代码：</p><ul><li><a href="https://github.com/riba2534/TCP-IP-NetworkNote/blob/master/ch24/webserv_linux.c">webserv_linux.c</a></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BUF_SIZE 1024</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SMALL_BUF 100</span><br><br><span class="hljs-type">void</span> *<span class="hljs-title function_">request_handler</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">send_data</span><span class="hljs-params">(FILE *fp, <span class="hljs-type">char</span> *ct, <span class="hljs-type">char</span> *file_name)</span>;<br><span class="hljs-type">char</span> *<span class="hljs-title function_">content_type</span><span class="hljs-params">(<span class="hljs-type">char</span> *file)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">send_error</span><span class="hljs-params">(FILE *fp)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">error_handling</span><span class="hljs-params">(<span class="hljs-type">char</span> *message)</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br>    <span class="hljs-type">int</span> serv_sock, clnt_sock;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">serv_adr</span>, <span class="hljs-title">clnt_adr</span>;</span><br>    <span class="hljs-type">int</span> clnt_adr_size;<br>    <span class="hljs-type">char</span> buf[BUF_SIZE];<br>    <span class="hljs-type">pthread_t</span> t_id;<br>    <span class="hljs-keyword">if</span> (argc != <span class="hljs-number">2</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Usage : %s &lt;port&gt;\n&quot;</span>, argv[<span class="hljs-number">0</span>]);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    serv_sock = socket(PF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">memset</span>(&amp;serv_adr, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(serv_adr));<br>    serv_adr.sin_family = AF_INET;<br>    serv_adr.sin_addr.s_addr = htonl(INADDR_ANY);<br>    serv_adr.sin_port = htons(atoi(argv[<span class="hljs-number">1</span>]));<br>    <span class="hljs-keyword">if</span> (bind(serv_sock, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;serv_adr, <span class="hljs-keyword">sizeof</span>(serv_adr)) == <span class="hljs-number">-1</span>)<br>        error_handling(<span class="hljs-string">&quot;bind() error&quot;</span>);<br>    <span class="hljs-keyword">if</span> (listen(serv_sock, <span class="hljs-number">20</span>) == <span class="hljs-number">-1</span>)<br>        error_handling(<span class="hljs-string">&quot;listen() error&quot;</span>);<br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        clnt_adr_size = <span class="hljs-keyword">sizeof</span>(clnt_adr);<br>        clnt_sock = accept(serv_sock, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;clnt_adr, &amp;clnt_adr_size);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Connection Request : %s:%d\n&quot;</span>,<br>               inet_ntoa(clnt_adr.sin_addr), ntohs(clnt_adr.sin_port));<br>        pthread_create(&amp;t_id, <span class="hljs-literal">NULL</span>, request_handler, &amp;clnt_sock);<br>        pthread_detach(t_id);<br>    &#125;<br>    close(serv_sock);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">void</span> *<span class="hljs-title function_">request_handler</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span><br>&#123;<br>    <span class="hljs-type">int</span> clnt_sock = *((<span class="hljs-type">int</span> *)arg);<br>    <span class="hljs-type">char</span> req_line[SMALL_BUF];<br>    FILE *clnt_read;<br>    FILE *clnt_write;<br><br>    <span class="hljs-type">char</span> method[<span class="hljs-number">10</span>];<br>    <span class="hljs-type">char</span> ct[<span class="hljs-number">15</span>];<br>    <span class="hljs-type">char</span> file_name[<span class="hljs-number">30</span>];<br><br>    clnt_read = fdopen(clnt_sock, <span class="hljs-string">&quot;r&quot;</span>);<br>    clnt_write = fdopen(dup(clnt_sock), <span class="hljs-string">&quot;w&quot;</span>);<br>    fgets(req_line, SMALL_BUF, clnt_read);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strstr</span>(req_line, <span class="hljs-string">&quot;HTTP/&quot;</span>) == <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        send_error(clnt_write);<br>        fclose(clnt_read);<br>        fclose(clnt_write);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-built_in">strcpy</span>(method, strtok(req_line, <span class="hljs-string">&quot; /&quot;</span>));<br>    <span class="hljs-built_in">strcpy</span>(file_name, strtok(<span class="hljs-literal">NULL</span>, <span class="hljs-string">&quot; /&quot;</span>));<br>    <span class="hljs-built_in">strcpy</span>(ct, content_type(file_name));<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(method, <span class="hljs-string">&quot;GET&quot;</span>) != <span class="hljs-number">0</span>)<br>    &#123;<br>        send_error(clnt_write);<br>        fclose(clnt_read);<br>        fclose(clnt_write);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    fclose(clnt_read);<br>    send_data(clnt_write, ct, file_name);<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">send_data</span><span class="hljs-params">(FILE *fp, <span class="hljs-type">char</span> *ct, <span class="hljs-type">char</span> *file_name)</span><br>&#123;<br>    <span class="hljs-type">char</span> protocol[] = <span class="hljs-string">&quot;HTTP/1.0 200 OK\r\n&quot;</span>;<br>    <span class="hljs-type">char</span> server[] = <span class="hljs-string">&quot;Server:Linux Web Server \r\n&quot;</span>;<br>    <span class="hljs-type">char</span> cnt_len[] = <span class="hljs-string">&quot;Content-length:2048\r\n&quot;</span>;<br>    <span class="hljs-type">char</span> cnt_type[SMALL_BUF];<br>    <span class="hljs-type">char</span> buf[BUF_SIZE];<br>    FILE *send_file;<br><br>    <span class="hljs-built_in">sprintf</span>(cnt_type, <span class="hljs-string">&quot;Content-type:%s\r\n\r\n&quot;</span>, ct);<br>    send_file = fopen(file_name, <span class="hljs-string">&quot;r&quot;</span>);<br>    <span class="hljs-keyword">if</span> (send_file == <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        send_error(fp);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//传输头信息</span><br>    <span class="hljs-built_in">fputs</span>(protocol, fp);<br>    <span class="hljs-built_in">fputs</span>(server, fp);<br>    <span class="hljs-built_in">fputs</span>(cnt_len, fp);<br>    <span class="hljs-built_in">fputs</span>(cnt_type, fp);<br><br>    <span class="hljs-comment">//传输请求数据</span><br>    <span class="hljs-keyword">while</span> (fgets(buf, BUF_SIZE, send_file) != <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        <span class="hljs-built_in">fputs</span>(buf, fp);<br>        fflush(fp);<br>    &#125;<br>    fflush(fp);<br>    fclose(fp);<br>&#125;<br><span class="hljs-type">char</span> *<span class="hljs-title function_">content_type</span><span class="hljs-params">(<span class="hljs-type">char</span> *file)</span><br>&#123;<br>    <span class="hljs-type">char</span> extension[SMALL_BUF];<br>    <span class="hljs-type">char</span> file_name[SMALL_BUF];<br>    <span class="hljs-built_in">strcpy</span>(file_name, file);<br>    strtok(file_name, <span class="hljs-string">&quot;.&quot;</span>);<br>    <span class="hljs-built_in">strcpy</span>(extension, strtok(<span class="hljs-literal">NULL</span>, <span class="hljs-string">&quot;.&quot;</span>));<br><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(extension, <span class="hljs-string">&quot;html&quot;</span>) || !<span class="hljs-built_in">strcmp</span>(extension, <span class="hljs-string">&quot;htm&quot;</span>))<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;text/html&quot;</span>;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;text/plain&quot;</span>;<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">send_error</span><span class="hljs-params">(FILE *fp)</span><br>&#123;<br>    <span class="hljs-type">char</span> protocol[] = <span class="hljs-string">&quot;HTTP/1.0 400 Bad Request\r\n&quot;</span>;<br>    <span class="hljs-type">char</span> server[] = <span class="hljs-string">&quot;Server:Linux Web Server \r\n&quot;</span>;<br>    <span class="hljs-type">char</span> cnt_len[] = <span class="hljs-string">&quot;Content-length:2048\r\n&quot;</span>;<br>    <span class="hljs-type">char</span> cnt_type[] = <span class="hljs-string">&quot;Content-type:text/html\r\n\r\n&quot;</span>;<br>    <span class="hljs-type">char</span> content[] = <span class="hljs-string">&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;NETWORK&lt;/title&gt;&lt;/head&gt;&quot;</span><br>                     <span class="hljs-string">&quot;&lt;body&gt;&lt;font size=+5&gt;&lt;br&gt;发生错误！ 查看请求文件名和请求方式!&quot;</span><br>                     <span class="hljs-string">&quot;&lt;/font&gt;&lt;/body&gt;&lt;/html&gt;&quot;</span>;<br>    <span class="hljs-built_in">fputs</span>(protocol, fp);<br>    <span class="hljs-built_in">fputs</span>(server, fp);<br>    <span class="hljs-built_in">fputs</span>(cnt_len, fp);<br>    <span class="hljs-built_in">fputs</span>(cnt_type, fp);<br>    fflush(fp);<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">error_handling</span><span class="hljs-params">(<span class="hljs-type">char</span> *message)</span><br>&#123;<br>    <span class="hljs-built_in">fputs</span>(message, <span class="hljs-built_in">stderr</span>);<br>    fputc(<span class="hljs-string">&#x27;\n&#x27;</span>, <span class="hljs-built_in">stderr</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>编译运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc webserv_linux.c -D_REENTRANT -o web_serv -lpthread<br>./web_serv 9190<br></code></pre></td></tr></table></figure><p>结果：</p><p><img src="/.io//blog/blog/picture/5c5c107deba11.png"></p><p><img src="/.io//blog/blog/picture/5c5c19cbb3718.png"></p><p>经过测试，这个简单的 HTTP 服务器可以正常的显示出页面。</p><h3 id="24-3-习题"><a href="#24-3-习题" class="headerlink" title="24.3 习题"></a>24.3 习题</h3><blockquote><p>以下答案仅代表本人个人观点，可能不是正确答案。</p></blockquote><ol><li><p><strong>下列关于 Web 服务器端和 Web 浏览器端的说法错误的是</strong>？</p><p>答：以下加粗选项代表正确。</p><ol><li><strong>Web 浏览器并不是通过自身创建的套接字连接服务端的客户端</strong></li><li>Web 服务器端通过 TCP 套接字提供服务，因为它将保持较长的客户端连接并交换数据</li><li>超文本与普通文本的最大区别是其具有可跳转的特性</li><li>Web 浏览器可视为向浏览器提供请求文件的文件传输服务器端</li><li>除 Web 浏览器外，其他客户端都无法访问 Web 服务器端。</li></ol></li><li><p><strong>下列关于 HTTP 协议的描述错误的是</strong>？</p><p>答：以下加粗选项代表正确。</p><ol><li>HTTP 协议是无状态的 Stateless 协议，不仅可以通过 TCP 实现，还可以通过 UDP 来实现</li><li><strong>HTTP 协议是无状态的 Stateless 协议，因为其在 1 次请求和响应过程完成后立即断开连接。因此，如果同一服务器端和客户端需要  3 次请求及响应，则意味着需要经过 3 次套接字的创建过程</strong>。</li><li><strong>服务端向客户端传递的状态码中含有请求处理结果的信息</strong>。</li><li><strong>HTTP 协议是基于因特网的协议，因此，为了同时向大量客户端提供服务，HTTP 协议被设计为 Stateless 协议</strong>。</li></ol></li></ol><p><strong>我的笔记到此结束</strong> :grin:</p><h2 id="memo-License"><a href="#memo-License" class="headerlink" title=":memo:License"></a>:memo:License</h2><p>本仓库遵循 CC BY-NC-SA 4.0（署名 - 非商业性使用） 协议，转载请注明出处。</p><p><a href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img src="/.io//blog/blog/picture/88x31.png" alt="CC BY-NC-SA 4.0"></a></p>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cs-学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计组</title>
    <link href="/2025/02/19/%E8%AE%A1%E7%BB%84/"/>
    <url>/2025/02/19/%E8%AE%A1%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<p><img src="/.io//blog/blog/picture/float-point02.png" alt="float-point02"></p><p>浮点数的表示形式<br><code>N = ( − 1 )^S × M × R^E </code></p><p>S：浮点数的符号<br>M：一个二进制定点小数，称为尾数（mantissa），一般用定点原码小数表示<br>E：一个二进制定点整数，称为阶码或指数，用移码表示<br>R：基数（隐含），可约定为2、4、16等</p><h1 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>计算机技术的进步几乎用想着社会的方方面面。硬件的进步是的程序员能够创造除奇妙有用的软件，进而证明了为什么计算机无处不在。现在的科学幻想往往预示着未来最具影响力的应用。</p><h3 id="传统计算应用分类及其特点"><a href="#传统计算应用分类及其特点" class="headerlink" title="传统计算应用分类及其特点"></a>传统计算应用分类及其特点</h3><p><strong>个人计算机</strong>：PC机，家家户户都在用的电脑</p><p><strong>服务器</strong>：用于为多个用户并行运行大型程序的计算机，通常只能通过网络访问。</p><p><strong>超级计算机</strong>：具有最好的性能和成本的一类计算机，一般被配置为服务器且通常耗费数千万美元甚至数亿美元。</p><p><strong>嵌入式计算机</strong>：用于运行某预定应用程序或软件集合的计算机，一般内嵌于其他设备中。</p><h3 id="欢迎来到后PC时代"><a href="#欢迎来到后PC时代" class="headerlink" title="欢迎来到后PC时代"></a>欢迎来到后PC时代</h3><p>技术的持续进步给计算机硬件带来了技术性的代际变迁，个人移动设备盛行。</p><p><strong>云计算</strong>：接替了传统服务器，它依赖于现在称为仓储级计算机的巨型数据中心。像亚马逊和谷歌这样的公司构建包含了100000台服务器的仓储级计算机，一些公司租用其中的一小部分为个人移动设备提供软件服务而无需建立自己的仓储级计算机。事实上，通过云计算实现的<strong>软件即服务</strong>正在彻底改变软件行业。当今的软件开发人员经常会将应用的一部分运行在个人移动设备上，另一部分则部署在云上。</p><h3 id="能从本书中学到什么"><a href="#能从本书中学到什么" class="headerlink" title="能从本书中学到什么"></a>能从本书中学到什么</h3><p>我们在解读这个革命性的计算机器中的内容，并阐明程序之下的软件以及机箱覆盖下的硬件是如何工作的。并以此为基础提升程序的性能。</p><h2 id="计算机体系结构中的8个伟大思想"><a href="#计算机体系结构中的8个伟大思想" class="headerlink" title="计算机体系结构中的8个伟大思想"></a>计算机体系结构中的8个伟大思想</h2><h3 id="一、面向摩尔定律的设计"><a href="#一、面向摩尔定律的设计" class="headerlink" title="一、面向摩尔定律的设计"></a>一、面向摩尔定律的设计</h3><p>单芯片上所继承的晶体管资源每18和24个月翻一番。</p><h3 id="二、使用抽象简化设计"><a href="#二、使用抽象简化设计" class="headerlink" title="二、使用抽象简化设计"></a>二、使用抽象简化设计</h3><p>使用抽象来表示不同的设计层次，隐藏底层细节以提供给高层一个更简单的模型。</p><h3 id="三、加速经常性事件"><a href="#三、加速经常性事件" class="headerlink" title="三、加速经常性事件"></a>三、加速经常性事件</h3><p>比优化罕见情形能够更好的提升性能。但是需要通过仔细地实验和测量才可能得出什么是常识性事件</p><h3 id="四、通过并行提高性能"><a href="#四、通过并行提高性能" class="headerlink" title="四、通过并行提高性能"></a>四、通过并行提高性能</h3><p>通过并行计算操作来获得更高性能</p><h3 id="五、通过流水线提高性能"><a href="#五、通过流水线提高性能" class="headerlink" title="五、通过流水线提高性能"></a>五、通过流水线提高性能</h3><p>并行性的一种页数场景在计算机体系结构中非常普遍，他有着专有名称–<strong>流水线</strong>。</p><h3 id="六、通过预测提高性能"><a href="#六、通过预测提高性能" class="headerlink" title="六、通过预测提高性能"></a>六、通过预测提高性能</h3><p>假设从预测错误中恢复的代价并不高，且预测相对准确，则平均来说进行预测并开始工作可能会比等到明确结果后再执行更快</p><h3 id="七、存储层次"><a href="#七、存储层次" class="headerlink" title="七、存储层次"></a>七、存储层次</h3><p>存储器的速度通常会影响性能，存储器的容量限制了可被解决问题的规模，且当今的内存成本常常是计算机成本的主要部分，因此程序员希望存储器速度更快，容量更大，价格更便宜。结构师发现可以通过<strong>存储层次</strong>来处理这些冲突的需求。在存储层次中，速度最快容量最小并且每位价格最贵的存储器处于顶层，而速度最慢容量最大且每位价格最便宜的存储器处于底层。高速缓存给了程序员这样的错觉：主存与存储层次顶层几乎一样快，且与存储层次底层拥有几乎一样大的容量和便宜的价格。</p><h3 id="八、通过冗余提高可能性"><a href="#八、通过冗余提高可能性" class="headerlink" title="八、通过冗余提高可能性"></a>八、通过冗余提高可能性</h3><p>计算机不仅要速度快，更需要工作可靠。由于任何物理设备都可能发生故障，因此我们必须引入冗余组件来使系统可靠，该组件在系统发生故障时可以替代失效组件并帮助检测故障。</p><h2 id="程序表象之下"><a href="#程序表象之下" class="headerlink" title="程序表象之下"></a>程序表象之下</h2><p>一个典型的应用程序，如字处理程序或大型数据库系统，可以有数百万行代码构成，并依靠软件库来实现异常复杂的功能。众所周知，计算机的硬件只能执行极为简单的低级指令。从复杂的应用程序到原始的指令涉及若干软件层次来将高层次操作解释或翻译成简单的计算机指令，这可以作为伟大的<strong>抽象</strong>思想的一个例子。</p><p>系统软件有很多种，其中有两种对于现代计算机系统来说是必须的：操作系统和编译器。</p><p><strong>操作系统</strong>是用户程序和硬件之间的接口，为用户提供各种服务和监控功能。作用为</p><ul><li>处理输入输出操作</li><li>分配内存外存</li><li>为多个应用程序提供共享计算机资源的服务</li></ul><p><strong>编译器</strong>将高级语言编译成硬件能执行的指令。</p><h3 id="从高级语言到硬件语言"><a href="#从高级语言到硬件语言" class="headerlink" title="从高级语言到硬件语言"></a>从高级语言到硬件语言</h3><p>计算机中的字符只有0和1，每一个字符都是一个<strong>二进制位</strong>或一个<strong>位</strong>（bit）。计算机能够执行指令，指令能被计算机识别并且执行的位串，可以将其视为数字。如：1001010100101110该数据串告诉计算机将两个数相加。</p><p>第一代程序员直接使用二进制数与计算机通信，这非常困难，于是他们发明了助记符，用助记符写好程序之后需要编译成二进制程序，程序人员开发了能够自动编译汇编程序的<strong>汇编器</strong>。这种结合助记符的语言就是<strong>汇编语言</strong>，而那些能被计算机理解的数字叫做<strong>机器语言</strong>。</p><p>尽管汇编语言为编程提供了便利，但是仍然和人类思维的语言不一样，汇编的机制要求程序员向计算机一样思考，于是程序员在汇编的基础上抽象出了高级编程语言，并写了相应的编译器将高级语言编译成汇编语言，汇编器在编译成机器语言。</p><h2 id="箱盖后的硬件"><a href="#箱盖后的硬件" class="headerlink" title="&#x3D;&#x3D;箱盖后的硬件&#x3D;&#x3D;"></a>&#x3D;&#x3D;箱盖后的硬件&#x3D;&#x3D;</h2><p>这是本书第一个需要重点记忆的知识点，即计算机是由输入，输出，处理和存储数据任务的5个部件。 输入为计算机提供证据，输出将计算结果送给用户。</p><h3 id="显示器"><a href="#显示器" class="headerlink" title="显示器"></a>显示器</h3><p>大多数个人移动设备都用液晶显示（LCD），今天的大多数LCD采用<strong>动态矩阵显示技术</strong>。</p><h3 id="触摸屏"><a href="#触摸屏" class="headerlink" title="触摸屏"></a>触摸屏</h3><p>后PC时代的平板电脑和智能手机使用接触敏感的设备替代了鼠标键盘，使其拥有良好的用户界面。</p><h3 id="打开机箱"><a href="#打开机箱" class="headerlink" title="打开机箱"></a>打开机箱</h3><p><strong>集成电路</strong>：俗称芯片，一种结合了几十个甚至上亿个晶体管的设备。</p><p><strong>中央处理单元</strong>：也成为处理器，处理器是计算机中最活跃的部分，包括数据通路和控制器，能完成数据相加，数据测试，按结果发出控制信号使I&#x2F;O设备做出动作等操作。</p><p><strong>数据通路</strong>：处理器中执行算术操作的部分。</p><p><strong>控制器</strong>：处理器中根据程序的指令只会数据通路、存储器和I&#x2F;O设备的部分。</p><p><strong>内存</strong>：程序运行时的存储空间，同时还存储程序运行时所需的数据。</p><p><strong>DRAM</strong>：动态随机访问存储器，集成电路形式的存储器，可随机访问任何地址的内存。在2012年，其访问时间大约是50ms，每GB的价格为5~10美元。</p><p><strong>高速缓存</strong>：高速缓存是一种小而快的存储器，一般作为大而慢的存储器的缓冲。</p><p><strong>静态随机访问存储器</strong>：另一种集成电路形式的存储器，但是比DRAM更快，集成度更低。</p><p><strong>指令系统体系结构</strong>：也叫体系结构，是低层次软件和硬件之间的抽象接口，包含了需要编写正确运行的机器语言程序所需要的全部信息，包括指令，寄存器，存储器访问和I&#x2F;O等。</p><p><strong>应用二进制接口</strong>：用户部分的指令加上应用程序员调用的操作系统接口，定义了二进制层次可移植的计算机的标准。</p><p><strong>实现</strong>：遵循体系结构抽象的硬件。</p><h3 id="数据安全"><a href="#数据安全" class="headerlink" title="数据安全"></a>数据安全</h3><p><strong>易失性存储</strong>：类似DRAM的存储器，仅在加电时保存数据。</p><p><strong>非易失性存储</strong>：在掉电时仍可保持数据的存储器，用于存储需运行的程序，例如DVD。</p><p><strong>主存储</strong>：也叫主要存储。这种存储用来保持运行中的程序，在现代计算机中一般由DRAM组成。</p><p><strong>辅助存储</strong>：非易失性存储，用来保存两次运行之间的程序和数据。在个人移动设备中一般由闪存组成，在服务器中有磁盘组成.</p><p><strong>磁盘</strong>：也叫硬盘，是使用磁介质材料构成的以旋转盘片为基础的非易失性二级存储设备。因为是旋转的机械设备，所依磁盘的访问时间大约是5~20毫秒。</p><p><strong>闪存</strong>：一种非易失性半导体内存，单位价格和速度低于DRAM，但单位价格比磁盘高，速度比磁盘块。其访问时间大约为5~50毫秒.</p><h3 id="与其他计算机通信"><a href="#与其他计算机通信" class="headerlink" title="与其他计算机通信"></a>与其他计算机通信</h3><p>通过网络，计算机可与其他的计算机通信，从而拓展计算能力。联网计算机有几个优点。</p><ul><li>通信：信息可在计算机之间高速转换</li><li>资源共享：I&#x2F;O设备可以通过网络共享，不必每台计算机都配享。</li><li>远距离访问：用户无需再要使用的计算机旁，可远距离连接计算机。</li></ul><p><strong>局域网</strong>：一种用于在一定地理区域内传输数据的网络。</p><p><strong>广域网</strong>：一种可以跨越大陆数百公里的网络。</p><h2 id="处理器和存储制造技术"><a href="#处理器和存储制造技术" class="headerlink" title="处理器和存储制造技术"></a>处理器和存储制造技术</h2><p><strong>晶体管</strong>是一种受电流控制的开关。集成电路事由成千上万个晶体管组成的芯片。集成电路的制造是从硅锭开始的。</p><p><strong>晶圆</strong>：由硅锭经切片机切成厚度不超过0.1英寸的硅锭切片，用于制造芯片。</p><p><strong>缺陷</strong>：晶圆或者曝光成像过程中的一个微小的瑕疵，镜片可能因为包含这个缺陷而失败。</p><p>缺陷的存在使得制成一个完美的晶圆是不可能的，为解决这一问题，将许多独立组件放置在某一晶圆上，然后再曝光成像后切割为晶片。</p><p><strong>晶片</strong>：从晶圆中切割出来的一个单独的矩形区域，非正式的名称是芯片。</p><h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><h3 id="性能的定义"><a href="#性能的定义" class="headerlink" title="性能的定义"></a>性能的定义</h3><p>不同的计算机，衡量性能的因素有很多，个人计算机用户会对降低<strong>响应时间</strong>感兴趣。</p><p><strong>响应时间</strong>：也叫执行时间，是计算机完成某任务所需的总时间，包括硬盘访问，内存访问I&#x2F;O活动，操作系统开销和CPU执行时间等。</p><p>而数据中心的管理者更感兴趣的常常是提高<strong>吞吐率</strong>或者<strong>带宽</strong>。</p><p><strong>带宽</strong>：也叫吞吐率，性能的另外一个度量参数，表示单位时间内完成的任务数量。</p><p>当任务量过大时，吞吐量大也会导致响应时间变短。当我们想说提高性能时，一般说<strong>增加性能</strong>和<strong>减少执行时间</strong></p><h3 id="性能的度量"><a href="#性能的度量" class="headerlink" title="性能的度量"></a>性能的度量</h3><p>时间是计算机性能的衡量标准，完成同样的计算任务，需要时间最少的计算机是最快的。程序的执行时间一般是以秒为单位。</p><p><strong>CPU执行时间</strong>：简称为CPU时间，执行某一任务在CPU上所花费的时间。</p><p><strong>用户CPU时间</strong>：程序本身所花费的CPU时间。</p><p><strong>系统CPU时间</strong>：为执行程序而花费在操作系统上的时间。</p><p>我们使用<strong>系统性能</strong>表示空载系统的响应时间。用术语<strong>CPU性能</strong>表示用户CPU时间。几乎所有的计算机的构建都需要基于时钟，该时钟确定各类时间在硬件中何时发生。这些离散时间间隔被称为时钟周期数，每个时钟周期的长度称为<strong>周期长度</strong>。</p><h3 id="CPU性能机器度量因素"><a href="#CPU性能机器度量因素" class="headerlink" title="CPU性能机器度量因素"></a>CPU性能机器度量因素</h3><p>性能度量的基本指标是CPU执行时间。</p><p>CPU执行时间&#x3D;CPU时钟周期数*时钟周期长度</p><p>CPU执行时间&#x3D;CPU时钟周期数&#x2F;时钟频率</p><h3 id="指令性能"><a href="#指令性能" class="headerlink" title="指令性能"></a>指令性能</h3><p><strong>指令平均时钟周期数</strong>：表示执行某个程序或者程序片段时每条指令所需的时钟周期平均数。简称<strong>CPI</strong></p><p>CPU时钟周期数&#x3D;程序的指令数* CPI *时钟周期长度</p><p>CPU时间&#x3D;指令数*CPI&#x2F;时钟频率</p><h3 id="经典的CPU性能公式"><a href="#经典的CPU性能公式" class="headerlink" title="经典的CPU性能公式"></a>经典的CPU性能公式</h3><p>CPU时间&#x3D;指令数*CPI *时钟周期长度</p><p>CPU时间&#x3D;指令数* CPI&#x2F;时钟频率</p><h2 id="功耗墙"><a href="#功耗墙" class="headerlink" title="功耗墙"></a>功耗墙</h2><p>近几年，Intel处理器的性能增长速度有所缓和，放缓的原因是功率已经达到了实际极限，无法将普通商用处理器冷却下来。</p><p>后PC时代电池寿命比性能更加关键。对于百万级服务器的仓储式计算机来说，冷却费用非常之高，因此必须降低冷却成本。对于计算机来说，用焦耳每秒这样的能耗单位比瓦这样的功率单位更能直观的体现出计算机所消耗能量的多少。</p><p>集成电路技术中每个晶体管需要的功耗是一次反转需要的能耗和开关频率的乘积：</p><p>功耗正比于负载电容*电压^2 *开关频率 *0.5</p><h2 id="从单处理器向多处理器转变"><a href="#从单处理器向多处理器转变" class="headerlink" title="从单处理器向多处理器转变"></a>从单处理器向多处理器转变</h2><p>功耗的极限迫使微处理器的设计发生了巨变。很多公司在单个微处理器芯片中加入了多个核（为避免混淆，将处理器称作核）这种微处理器称作多核处理器。</p><p>单核处理器时代，程序员可以不修改代码而是将依赖于硬件，体系结构和编译器的创新就能够实现程序的性能翻倍，但是到了多核处理器时代，程序员必须修改代码以便利用多核的优势，才能够实现性能上的提升。</p><p>为了强调软件系统和硬件系统的协同工作，我们在本书中用“硬件&#x2F;软件接口”的概念来进行描述，介绍了一些重要的观点：</p><p>并行性对计算性能一直十分重要，通过指令重叠执行使程序运行的更快，在抽取了硬件的并行本质之后，程序员或编译器可认为在硬件中指令是串行执行的。但是程序员编写显示并行程序是十分困难的。</p><ul><li>原因一：并行编程以提高性能为目的，这必然增加编程的难度。不仅程序必须要正确，能够解决重要问题，而且运行速度要快，还需要为用户或其他程序员提供接口以便使用。如果不关心性能的话，编写一个串行程序就足够了。</li><li>原因二：为了发挥并行硬件的速度，程序员必须要将应用划分为每个核上大致相同数量的任务，并同时完成。该要尽可能减少调度的开销，不浪费并行性能。</li></ul><h2 id="谬误与陷阱"><a href="#谬误与陷阱" class="headerlink" title="谬误与陷阱"></a>谬误与陷阱</h2><p><strong>陷阱：在改进计算机的某个方向时期望总性能的提高与改进大小成正比</strong></p><p><strong>谬误：低利用率的计算机有着更低的功耗</strong></p><p><strong>谬误：面向性能的设计和面向能效的设计具有不相关的目标</strong></p><p>在优化架构时，即使优化后的部分需要比之前更多的能量，计算机的能耗还是减小了，这是因为优化后能够减少运行时间，所以从总体上看，能耗还是减小的。</p><p><strong>陷阱：用性能公式的一个字集去度量性能</strong></p><p>有一种取代时间以度量性能的尺度是每秒百万条指令数MIPS</p><p>MIPS&#x3D;指令数&#x2F;(执行时间*10^6)</p><p>MIPS&#x3D;时钟频率&#x2F;(CPI*10^6)</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>硬件和软件设计者都采用分层的方法构建计算机系统，每个下层都对其上层隐藏本层的细节。<strong>抽象思想</strong>是理解当今计算机系统的基础。也许最重要的抽象层次是硬件和底层软件之间的接口，成为<strong>指令系统体系结构</strong>保持指令系统体系结构恒定，是的机遇该指令系统体系结构的不同硬件实现能够运行相同的软件。这种方法的一个可能不足是，会阻止某些需要修改该接口的创新。</p><h1 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h1><h2 id="引言-1"><a href="#引言-1" class="headerlink" title="引言"></a>引言</h2><p>人和人谈话需要说对方能够听懂的语言，和计算机谈话也如此，想要让计算机执行相应的命令，就要说计算机的语言，即为<strong>指令</strong>，本章目的在于讲述一个遵循硬件简单性的指令系统，同时给出计算机结构的基本原理</p><h2 id="计算机硬件的操作"><a href="#计算机硬件的操作" class="headerlink" title="计算机硬件的操作"></a>计算机硬件的操作</h2><p>每台计算机必须能够实现算术运算</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">add</span> <span class="hljs-selector-tag">a</span>,<span class="hljs-selector-tag">b</span>,<span class="hljs-selector-tag">c</span>   <span class="hljs-comment">//a=b+c</span><br></code></pre></td></tr></table></figure><p><strong>注</strong>：RISC-V指令集每行只能包含一条指令</p><p>加法要求每条指令恰好有三个操作数，不能多也不能少，符合硬件简单原则：<strong>操作固定数量的硬件比可变数量的硬件更简单</strong>，由此我们可见硬件设计的三条基本原则：</p><p><strong>原则1：简单源于规整</strong></p><h2 id="计算机硬件的操作数"><a href="#计算机硬件的操作数" class="headerlink" title="计算机硬件的操作数"></a>计算机硬件的操作数</h2><p>不同于高级语言，算术指令的操作数会受到限制：他们必须曲子寄存器。到那时寄存器依赖于硬件（数量有限）。在RISC-V体系中，寄存器的大小为64位。在计算机中访问的基本单位有两种</p><ul><li><strong>双字</strong>：64位一组</li><li><strong>字</strong>：32位一组</li></ul><p>RISC-V架构下的寄存器有32个，其原因可以在硬件设计第二个原则上找到</p><p><strong>原则2：更少就更快</strong></p><p>更少的寄存器意味着更短的时钟周期，处理速度就会更快。因为电信号传播越远距离，所花时间就越长。但是这并不是绝对的，31个寄存器并不会比32个更快，之所以这么设计式设计人员对于更多寄存器和更短的时钟周期之间做出的选择。同时，指令格式的位数限制，也是寄存器的数量不能超过32个。</p><h3 id="存储器操作数"><a href="#存储器操作数" class="headerlink" title="存储器操作数"></a>存储器操作数</h3><p>计算机利用内存存储数组和结构体这种巨大的数据结构，但是指令只能作用于寄存器中，所以想访问内存中的数据，就需要有在内存和寄存器之间传输数据的指令，<strong>数据传输指令</strong>。指令必须提供内存地址。内存是一个大型的以为数组，其地址作为数组下标，从零开始。RISC-V使用字节寻址，每个双字代表8个字节。</p><p>载入指令是<strong>ld（load）</strong></p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm">ld <span class="hljs-keyword">x</span><span class="hljs-number">9</span><span class="hljs-punctuation">,</span><span class="hljs-number">8</span>(<span class="hljs-keyword">x</span><span class="hljs-number">22</span>)   //<span class="hljs-keyword">x</span><span class="hljs-number">22</span>是数组的基地址，<span class="hljs-number">8</span>是偏移量，<span class="hljs-keyword">x</span><span class="hljs-number">9</span>是将数据从内存中读取到的目标寄存器<br></code></pre></td></tr></table></figure><p>与载入指令相反的是存储指令<strong>sd(store)<strong>，从寄存器把数据复制到内存，格式与</strong>ld</strong>相同。</p><p>因为加载和存储指令中的地址是二进制数，所以作为主存的DRAM用二进制数来表示容量大小，而不是十进制</p><h3 id="常数或立即操作数"><a href="#常数或立即操作数" class="headerlink" title="常数或立即操作数"></a>常数或立即操作数</h3><p>程序经常会用到常数</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm">addi <span class="hljs-keyword">x</span><span class="hljs-number">22</span><span class="hljs-punctuation">,</span><span class="hljs-keyword">x</span><span class="hljs-number">22</span><span class="hljs-punctuation">,</span><span class="hljs-number">4</span>   //<span class="hljs-keyword">x</span><span class="hljs-number">22</span><span class="hljs-operator">=</span><span class="hljs-keyword">x</span><span class="hljs-number">22</span><span class="hljs-number">+4</span><br></code></pre></td></tr></table></figure><p>常数0十分重要用x0硬连线到0。</p><h2 id="有符号数和无符号数"><a href="#有符号数和无符号数" class="headerlink" title="有符号数和无符号数"></a>有符号数和无符号数</h2><p>计算机中所有信息都由<strong>二进制数位</strong>表示（bit）在64位双字中，从右往左依次编号为0，1，2，3，……63</p><p>（为叙述方便，该笔记接下来会有更少的位数表示）</p><ul><li>最低有效位：最右侧的位置，即第0位</li><li>最高有效位：最左侧的位置，即第63位</li></ul><p>64位可以表示0到2^64-1的数，若计算机计算后的结果不能用最右端的硬件位表示，则称<strong>溢出发生</strong></p><p>计算机程序可以用来计算正数还有负数，但是对于计算机来说，需要一种编码能够表示正负数。这样，数据在计算机内部是以<strong>编码</strong>形式存储的。</p><p>最简单的办法就是增加一个单独的符号位，这样的编码称为<strong>原码</strong>，但是这样就会面对0的符号问题，这会给程序员带来大意，而且当一个小数减去大数的时候，就会发生不断向前借位，最终产生无数前导1的问题。于是人们用另外一种编码表示数据，<strong>补码</strong>。</p><p>在补码中最左一位用来表示符号，0为正1为负</p><p>0000—–&gt;0</p><p>0001—–&gt;1</p><p>1000—–&gt;-8</p><p>1111—–&gt;-1</p><p>64位补码可表示范围为，0~2^63-1</p><p>观察得出，除去第一位的符号位，其余数位表示的是数的大小关系，如000表示最小，111表示最大</p><p>所以0000是最小的正数，0111是最大的正数，1000是最小的负数，1111是最大的负数</p><p>这是基于<strong>对称性原理</strong>得出的，这样使得正数补码的范围与负数补码的范围相同，而且每一个正数都有与之对应的负数，同时避免了正负0的问题。</p><p><strong>注</strong>：当二进制模式下最左面的保留位与左面的无线数位不相同时（符号位不正确）溢出发生：0负1正</p><p>补码转换规则</p><ul><li><strong>正数</strong>：与原码相同</li><li><strong>负数</strong>：原码取反后加一</li></ul><p><em><strong>补码的数学原理</strong></em></p><p>在计算机进行数学运算时，不同的运算往往需要不同的硬件加以适配，加减法需要用到不同的运算电路，为了简化这一过程，利用数学定律将减法转换为加法，这样就可以在只用一种硬件电路的情况下，实现假发减法的运算</p><p>补码的作用是将减法转为加法即2+（-5）&#x3D;2-5，其内在原理是利用了2+（0-5）&#x3D;2+0-5&#x3D;2-5</p><p>也就是<strong>5+（-5）&#x3D;0</strong></p><p>对此，只要找到一种数的表达方式能使该等式成立，就是补码的设计原理</p><p>假设一个四位运算器，5表示为0101，对于四位运算器来说，0000与10000与1….10000是一样的，在运算器中都只会存储0000，由此我们可以得出补码的转换步骤</p><ul><li>取反，0101-&gt;1010<strong>取反是将每位上的01换成10，等效于用1111减去原码</strong></li><li>加一，原码加上取反原码之后一定是1111，这是取反的原理，在加一就变成了10000，在四位运算器中还是相当于0000</li></ul><p>因此，只要将原码取反加一，就可表示源码的相反数（相加等于0）</p><p><strong>注</strong>：补码的转换规则是由观察补码，总结其性质以及一些数学计算得出的，而不是先制定转换规则，在由规则计算补码，因果关系不能倒。</p><h2 id="计算机中的指令表示"><a href="#计算机中的指令表示" class="headerlink" title="计算机中的指令表示"></a>计算机中的指令表示</h2><p>人使用指令和计算机识别指令的方式是不同的，指令在计算机用数字表示，指令的每个部分都可被视为一个独立的数，这些数组合在一起就构成了指令。</p><p>由于16是2的幂，所以经常用16进制数代替2进制数，每四位一换。在用数字表示指令时，计算机会将指令分段，为了使计算机不用额外的设计就能够执行指令，我们希望所有指令的格式相同。但是分段后，每一段都限制了最大数位长，但是有时候我们需要从内存中调取数据，内存地址的长度远远大于最大限制数位长，这就会使指令变长。至此我们发现，指令格式的统一与指令长度产生了矛盾，于是引出了第三个设计原则。</p><p><strong>原则3：优秀的设计需要适当的折中</strong></p><p>对此我们采取的措施是，保持所有的指令长度相同。但是对指令进行分类，不同的指令使用不同的格式</p><h3 id="1-R-型指令（Register-type）"><a href="#1-R-型指令（Register-type）" class="headerlink" title="1. R 型指令（Register-type）"></a>1. <strong>R 型指令（Register-type）</strong></h3><p>R 型指令是 RISC-V 中最基本的指令类型，主要用于&#x3D;&#x3D;<strong>寄存器</strong>&#x3D;&#x3D;之间的操作。它通常用于&#x3D;&#x3D;<strong>算术、逻辑运算等指令</strong>&#x3D;&#x3D;，需要三个寄存器作为操作数。</p><h4 id="格式"><a href="#格式" class="headerlink" title="格式"></a><strong>格式</strong></h4><p>R 型指令的格式是固定的，32 位的指令，其中的字段如下：</p><table><thead><tr><th>字段</th><th>位数</th><th>说明</th></tr></thead><tbody><tr><td><code>opcode</code></td><td>7</td><td>操作码，定义了指令的基本操作类型</td></tr><tr><td><code>rd</code></td><td>5</td><td>目标寄存器，用来存放运算结果</td></tr><tr><td><code>funct3</code></td><td>3</td><td>功能码，用于区分不同的运算类型</td></tr><tr><td><code>rs1</code></td><td>5</td><td>第一个源寄存器</td></tr><tr><td><code>rs2</code></td><td>5</td><td>第二个源寄存器</td></tr><tr><td><code>funct7</code></td><td>7</td><td>扩展功能码，进一步定义指令的行为</td></tr></tbody></table><h3 id="2-S-型指令（Store-type）"><a href="#2-S-型指令（Store-type）" class="headerlink" title="2. S 型指令（Store-type）"></a>2. <strong>S 型指令（Store-type）</strong></h3><p>S 型指令主要用于&#x3D;&#x3D;<strong>存储指令</strong>&#x3D;&#x3D;，即将数据从&#x3D;&#x3D;<strong>寄存器存储到内存</strong>&#x3D;&#x3D;中。它通常涉及到一个源寄存器（提供要存储的数据），以及一个基址寄存器（提供内存地址）。</p><h4 id="格式-1"><a href="#格式-1" class="headerlink" title="格式"></a><strong>格式</strong></h4><p>S 型指令的格式如下：</p><table><thead><tr><th>字段</th><th>位数</th><th>说明</th></tr></thead><tbody><tr><td><code>opcode</code></td><td>7</td><td>操作码，定义了指令的基本操作类型</td></tr><tr><td><code>imm[11:5]</code></td><td>7</td><td>存储地址的高 7 位</td></tr><tr><td><code>rs2</code></td><td>5</td><td>源寄存器，提供要存储的数据</td></tr><tr><td><code>rs1</code></td><td>5</td><td>基址寄存器，提供内存地址</td></tr><tr><td><code>funct3</code></td><td>3</td><td>功能码，定义存储类型</td></tr><tr><td><code>imm[4:0]</code></td><td>5</td><td>存储地址的低 5 位</td></tr></tbody></table><h3 id="3-I-型指令（Immediate-type）"><a href="#3-I-型指令（Immediate-type）" class="headerlink" title="3. I 型指令（Immediate-type）"></a>3. <strong>I 型指令（Immediate-type）</strong></h3><p>I 型指令用于操作数为&#x3D;&#x3D;<strong>立即数</strong>&#x3D;&#x3D;的情况。它常用于与&#x3D;&#x3D;<strong>常量或立即数值进行算术或逻辑运算</strong>&#x3D;&#x3D;，或者进行&#x3D;&#x3D;<strong>加载数据到寄存器</strong>&#x3D;&#x3D;。</p><h4 id="格式-2"><a href="#格式-2" class="headerlink" title="格式"></a><strong>格式</strong></h4><p>I 型指令的格式如下：</p><table><thead><tr><th>字段</th><th>位数</th><th>说明</th></tr></thead><tbody><tr><td><code>opcode</code></td><td>7</td><td>操作码，定义了指令的基本操作类型</td></tr><tr><td><code>rd</code></td><td>5</td><td>目标寄存器，存放运算结果</td></tr><tr><td><code>funct3</code></td><td>3</td><td>功能码，定义运算类型</td></tr><tr><td><code>rs1</code></td><td>5</td><td>第一个源寄存器</td></tr><tr><td><code>imm</code></td><td>12</td><td>立即数（常数）</td></tr></tbody></table><ul><li><strong>R 型指令</strong> 主要用于寄存器之间的算术和逻辑运算。</li><li><strong>S 型指令</strong> 主要用于将数据从寄存器存储到内存。</li><li><strong>I 型指令</strong> 主要用于操作寄存器与立即数的运算，或从内存加载数据到寄存器。</li></ul><p>通过这些类型的指令，RISC-V 架构实现了简单而高效的计算和数据处理方式。</p><h3 id="4-J型指令（Jump-type"><a href="#4-J型指令（Jump-type" class="headerlink" title="4. J型指令（Jump-type)"></a>4. J型指令（Jump-type)</h3><p><strong>跳转</strong>：<code>JAL</code> 会无条件地跳转到一个计算出的地址（目标地址）。这个目标地址是通过立即数和当前指令的地址相加计算得到的。</p><p><strong>链接</strong>：<code>JAL</code> 指令的链接功能是将当前指令的地址存入指定的寄存器（<code>rd</code> 寄存器），以便后续进行函数返回操作。通常，<code>rd</code> 寄存器用于存储返回地址，也就是跳转到新地址之前的位置。</p><table><thead><tr><th>字段</th><th>位数</th><th>说明</th></tr></thead><tbody><tr><td><code>opcode</code></td><td>7</td><td>操作码，固定为 <code>1101111</code></td></tr><tr><td><code>rd</code></td><td>5</td><td>目标寄存器（通常用于存储返回地址）</td></tr><tr><td><code>imm[20]</code></td><td>1</td><td>立即数的第 20 位</td></tr><tr><td><code>imm[10:1]</code></td><td>10</td><td>立即数的第 10 到 1 位</td></tr><tr><td><code>imm[11]</code></td><td>1</td><td>立即数的第 11 位</td></tr><tr><td><code>imm[19:12]</code></td><td>8</td><td>立即数的第 19 到 12 位</td></tr><tr><td><code>imm</code></td><td>20</td><td>立即数，用于计算跳转目标地址</td></tr></tbody></table><p>在需要执行函数时，jump会跳转函数的入口地址（通过立即数计算得出），而后通过存储在目标寄存器中的地址返回</p><h2 id="逻辑操作"><a href="#逻辑操作" class="headerlink" title="逻辑操作"></a>逻辑操作</h2><p>最初的计算机只对整字进行操作，但是随着需要进一步增长，我们发现对字段甚至单字操作都是很有必要的，由此诞生了逻辑操作。</p><table><thead><tr><th>按位与</th><th><code>and rd, rs1, rs2</code></th><th>按位与</th></tr></thead><tbody><tr><td></td><td><code>andi rd, rs1, imm</code></td><td>按位与（立即数）</td></tr><tr><td>按位或</td><td><code>or rd, rs1, rs2</code></td><td>按位或</td></tr><tr><td></td><td><code>ori rd, rs1, imm</code></td><td>按位或（立即数）</td></tr><tr><td>按位异或</td><td><code>xor rd, rs1, rs2</code></td><td>按位异或</td></tr><tr><td></td><td><code>xori rd, rs1, imm</code></td><td>按位异或（立即数）</td></tr><tr><td>按位取反</td><td><code>xori rd, rs1, -1</code></td><td>按位取反（通过 XOR 实现）</td></tr><tr><td>左移</td><td><code>sll rd, rs1, rs2</code></td><td>左移</td></tr><tr><td></td><td><code>slli rd, rs1, imm</code></td><td>左移（立即数）</td></tr><tr><td>逻辑右移</td><td><code>srl rd, rs1, rs2</code></td><td>逻辑右移</td></tr><tr><td></td><td><code>srli rd, rs1, imm</code></td><td>逻辑右移（立即数）</td></tr><tr><td>算术右移</td><td><code>sra rd, rs1, rs2</code></td><td>算术右移</td></tr><tr><td></td><td><code>srai rd, rs1, imm</code></td><td>算术右移（立即数）</td></tr></tbody></table><p>以上为所有逻辑操作及其格式</p><h3 id="移位"><a href="#移位" class="headerlink" title="移位"></a>移位</h3><p>一个双字中所有位都向左移或者右移，用0填补空缺</p><p><strong>如</strong>：00001001左移两位—-&gt;00100100</p> <figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs llvm">slli 左移立即数 srli 右移立即数<br>slli <span class="hljs-keyword">x</span><span class="hljs-number">11</span>，<span class="hljs-keyword">x</span><span class="hljs-number">19</span>，<span class="hljs-number">4</span>   //将<span class="hljs-keyword">x</span><span class="hljs-number">19</span>中的数左移<span class="hljs-number">4</span>位，并存放到<span class="hljs-keyword">x</span><span class="hljs-number">11</span><br></code></pre></td></tr></table></figure><p>移位指令通常为I型指令，因为不能对64位寄存器进行63位的左移活动，只有I型的12位immediate字段的低6位被使用。同时逻辑左移对二进制数来说，相当于乘2^i。</p><h3 id="与"><a href="#与" class="headerlink" title="与"></a>与</h3><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-keyword">and</span> <span class="hljs-built_in">x9</span>,<span class="hljs-built_in">x10</span>,<span class="hljs-built_in">x11</span>   <br></code></pre></td></tr></table></figure><p>按位操作，当两个操作数的位都是1时，结果才是1</p><p><strong>如</strong>：100011 and 110001——&gt;100001</p><h3 id="或"><a href="#或" class="headerlink" title="或"></a>或</h3><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">or</span> <span class="hljs-built_in">x9</span>,<span class="hljs-built_in">x10</span>,<span class="hljs-built_in">x11</span><br></code></pre></td></tr></table></figure><p>两个操作数有一个是1，结果是1</p><p><strong>如</strong>：100011 or 110001——-&gt;110011</p><h3 id="异或"><a href="#异或" class="headerlink" title="异或"></a>异或</h3><p>先介绍取反<strong>not</strong>只有一个操作数，将每一位的0，1互换，但是为了保证三个操作数就引入了<strong>异或</strong></p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm"><span class="hljs-keyword">xor</span> <span class="hljs-keyword">x</span><span class="hljs-number">9</span><span class="hljs-punctuation">,</span><span class="hljs-keyword">x</span><span class="hljs-number">10</span><span class="hljs-punctuation">,</span><span class="hljs-keyword">x</span><span class="hljs-number">11</span><br></code></pre></td></tr></table></figure><p>当两个位相同时为0，不同时为1</p><h2 id="用于决策的指令"><a href="#用于决策的指令" class="headerlink" title="用于决策的指令"></a>用于决策的指令</h2><p>计算机不同于普通计算器，计算机有着决策能力，可以根据输入数据和计算中产生的不同的值来执行不同的指令</p><p>RISC-V包含两个决策类指令</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-keyword">beq</span> rs1,rs2,L1   <span class="hljs-comment">//若rs1等于rs2则跳转到标签L1的语句执行</span><br></code></pre></td></tr></table></figure><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-keyword">bne</span> rs1,rs2,L1   <span class="hljs-comment">//若rs1不等于rs2则跳转到标签L1的语句执行</span><br></code></pre></td></tr></table></figure><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><p>判断循环条件是需要进行很多的比较，但是尽管比较的关系不同，指令的格式却是相同的</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-keyword">blt</span>    <span class="hljs-comment">//用于小于则分支</span><br><span class="hljs-keyword">bge</span>    <span class="hljs-comment">//用于大于则分支</span><br><span class="hljs-symbol">bltu</span>   <span class="hljs-comment">//无符号的小于则分支</span><br><span class="hljs-symbol">bgeu</span>   <span class="hljs-comment">//无符号的大于则分支</span><br></code></pre></td></tr></table></figure><p><strong>但是条件代码存在一个缺点，如果许多指令总是设置他们，就会生成让流水线执行困难的依赖关系</strong></p><h3 id="边界检查的简便方法"><a href="#边界检查的简便方法" class="headerlink" title="边界检查的简便方法"></a>边界检查的简便方法</h3><p>将有符号数当作而无符号数处理，给我们提供了一种低成本的检查是否0&lt;&#x3D;x&lt;y，如果x大于一定范围，就可视为越界并将其视为负数</p><h3 id="case-switch语句"><a href="#case-switch语句" class="headerlink" title="case&#x2F;switch语句"></a>case&#x2F;switch语句</h3><p>该语句包含多个分支，实现他的有效方式是编码形成指令序列的地址表，称为分支地址表，程序只需要索引到表中，然后跳转到相应的指令序列</p><p>分支表只是一个双字数组，包含着代码与标签相对应的地址。程序将分指标中的相应条目加载到寄存器中，然后需要使用寄存器中的地址进行跳转。jalr指令便是用于此目的。</p><h2 id="计算机硬件对于过程的支持"><a href="#计算机硬件对于过程的支持" class="headerlink" title="计算机硬件对于过程的支持"></a>计算机硬件对于过程的支持</h2><p><strong>过程（procedure）</strong>或函数适用于结构化编程的工具，有助于提高程序的可阅读性和可理解性。过程允许程序员一次只专注于程序的一部分，过程的参数可以传递数值并返回结果，相当于连接程序于过程之间的桥梁，因此充当程序于数据的接口。</p><p>就像警察处理案件时需要请侦探帮忙一样，侦探不需要知道太多，只需要明确什么需要查明白就可以了，任务结束之后也不需要过问其他细节。</p><p>在执行过程是，程序必须遵循以下的六个步骤</p><ol><li>将参数放在过程可以访问到的位置</li><li>将控制权转交给过程</li><li>获取过程所需的存储资源</li><li>执行所需的任务</li><li>将结果值放在调用程序可以访问到的位置</li><li>将控制返回到初始点，因为过程可以从程序中的多个点调用</li></ol><p>如上所示，在调用过程时需要频繁的传输数据。为了提高访问数据的效率，我们希望调用过程时尽量用计算机内部访问数据最快的位置—<strong>寄存器</strong></p><p>寄存器是计算机中访问数据最快的存储位置，因此期望尽可能使用寄存器处理数据。在<strong>RISC-V</strong>架构下，分配寄存器时遵从以下约定</p><table><thead><tr><th>编号</th><th>名称</th><th>功能描述</th></tr></thead><tbody><tr><td>x0</td><td>zero</td><td>恒为零</td></tr><tr><td>x1</td><td>ra</td><td>返回地址</td></tr><tr><td>x2</td><td>sp</td><td>栈指针</td></tr><tr><td>x3</td><td>gp</td><td>全局指针</td></tr><tr><td>x4</td><td>tp</td><td>线程指针</td></tr><tr><td>x5-x7</td><td>t0-t2</td><td>临时寄存器</td></tr><tr><td>x8-x9</td><td>s0-s1</td><td>被调用者保存寄存器（含 fp）</td></tr><tr><td>x10-x17</td><td>a0-a7</td><td>参数寄存器（含返回值）</td></tr><tr><td>x18-x27</td><td>s2-s11</td><td>被调用者保存寄存器</td></tr><tr><td>x28-x31</td><td>t3-t6</td><td>临时寄存器</td></tr></tbody></table><p>除此之外，还包含一个跳转连接指令<strong>jal</strong></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">jal</span> <span class="hljs-built_in">x1</span>,ProcedureAddress   <span class="hljs-comment">//跳转到ProdureAddress 并将此地址写进x1</span><br></code></pre></td></tr></table></figure><p>当过程结束后，需要返回指令。返回地址已经写进了x1，但是仍需要一条指令实现返回跳转。</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">jalr</span> <span class="hljs-built_in">x0</span>,<span class="hljs-number">0</span>(<span class="hljs-built_in">x1</span>)<br></code></pre></td></tr></table></figure><p>在存储程序概念中，需要一个寄存器保存大哥前执行指令的地址，由于历史原因，这个寄存器总是被称为<strong>程序计数器</strong>（program counter）尽管更合理的名字是指令地址寄存器。jal指令实际上将PC+4保存在指定寄存器（x1）中，已连接到后续指令的字节地址来设置过程返回</p><p>其原理为：PC总是储存当前指令的执行地址，当执行到<strong>jal</strong>跳转时，PC存储的也是jal指令的地址，但是我们都知道，过程返回时通常回到jal的下一条指令，而在RISC-V架构下，指令都是32位长的，即四个字节，所以保存在x1的地址是PC+4</p><h3 id="使用更多的寄存器"><a href="#使用更多的寄存器" class="headerlink" title="使用更多的寄存器"></a>使用更多的寄存器</h3><p>在上述调用过程时，我们最多只有8个寄存器可以使用，但是实际情况往往更加复杂，当我们已经使用了所有8个寄存器之后，还需要保存计算的中间结果，这时就需要将寄存器换到存储器。对此我们使用<strong>栈</strong>来实现上述操作</p><p><strong>栈</strong>是一种后进先出的队列。使用时，需要一个指向栈中新分配地址的指针，以表示下一个过程应该放置换出寄存器的位置。在RISC-V架构中，<strong>栈指针</strong>（stack pointer）是寄存器x2，也成为sp。将数据放入栈中成为<strong>压栈</strong>，将数据移出栈中成为<strong>弹栈</strong>，栈将按照从高到低的地址顺序增长。</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">addi</span> <span class="hljs-built_in">sp</span>,<span class="hljs-built_in">sp</span>,-<span class="hljs-number">24</span>  <span class="hljs-comment">//为新数据申请3个单位空间，每个空间是一个双字，所以是8*3=24</span><br>                <span class="hljs-comment">//同时栈地址从高到低，所以是-24</span><br></code></pre></td></tr></table></figure><h3 id="嵌套过程"><a href="#嵌套过程" class="headerlink" title="嵌套过程"></a>嵌套过程</h3><p>不调用其他过程的成为叶子过程（leaf），但是实际应用时，一个过程往往需要另外一个过程。就如一个侦探做任务时可能需要其他侦探一样。但是在调用叶程序时，会用到jal跳转链接命令，但这时，存在x1的地址就变成了两个，会引起寄存器的冲突。</p><p>对此的解决方法是将必须保存的寄存器压栈。</p>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cs-学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构</title>
    <link href="/2024/12/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <url>/2024/12/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<p>最近期末考，开始复习数据结构，后期等有时间在系统学习吧</p><h1 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h1><h2 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h2><p>单链表基本定义</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">typedef struct <span class="hljs-keyword">node</span><br><span class="hljs-title">&#123;</span><br><span class="hljs-title">Element</span> element;<br>struct <span class="hljs-keyword">node</span> <span class="hljs-title">*link</span>;<br>&#125;<span class="hljs-keyword">Node</span><span class="hljs-title">;</span><br></code></pre></td></tr></table></figure><p>其中，为了实现链表的连续性，需要每一个结点的指针域指向下一个结点，而下一个节点是node型，所以就需要<strong>同为node类型的指针</strong>(指针的类型决定了该指针指向的地址中可以存放哪些元素)</p><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="稀疏矩阵"><a href="#稀疏矩阵" class="headerlink" title="稀疏矩阵"></a>稀疏矩阵</h2><h3 id="稀疏矩阵的快速转置"><a href="#稀疏矩阵的快速转置" class="headerlink" title="稀疏矩阵的快速转置"></a>稀疏矩阵的快速转置</h3><p>基本思路是用空间换时间，即引入额外的数组来记录矩阵中的一些信息<br>num数组用于存放每列的非零元素数，k数组用于实现转置</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">//初始化num数组</span><br><span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)<br>&#123;<br><span class="hljs-built_in">num</span>[j]=<span class="hljs-number">0</span>;     <br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;t;i++)<br>&#123;<br><span class="hljs-comment">//A为稀疏矩阵，table为三元组表，因为三元组表本质上是一个长数组，每个单元存放一个三元组</span><br><span class="hljs-comment">//所以table[i]的位置即为三元组表中第i个三元组</span><br><span class="hljs-comment">//table[i].col代表该三元组里存放列下标为col的元素，使其加一</span><br><span class="hljs-comment">//因为num数组有n个元素，与稀疏矩阵的列数相同，且一一对应，就完成了统计列元素数的操作</span><br><span class="hljs-built_in">num</span>[A.table[i].col]++;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于num数组，我们可以想象成标在矩阵列下标上的一组数据，数组下标与矩阵列下标一一对应，存放着该列的非零元素数，上述加一操作是在下标为col的位置加一，现实意义是该元素位于矩阵的col处，加一操作让对应col下标的num数组单元里存放的数据加一</p><p><img src="/.io//blog/blog/picture/image-20241231160607294.png" alt="image-20241231160607294"></p><p>k数组比较复杂，k[j]存放着从0到j-1列的所有非零元素个数和，转置矩阵B是按照顺序存储的，对应的A中元素所在列的前几列有几个元素，转置后B中元素的前几行就会有几个元素，所以该元素在表中的位置就是k[j]的值（<strong>若该元素所在列有多个元素，k[j]等于第一个元素的位置，访问后就要进行自加操作，将位置后移，以存放该列第二个非零元素</strong>&#x3D;&#x3D;<strong>因为对于A中同一列的两个元素，k[j]相等，所以加一代表位置后移</strong>&#x3D;&#x3D;）</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;t;i++)<br>&#123;<br>//A中i行元素所在列数，转置后为B中该元素的行数，k数组就可存储A中该元素所在列前几列的元素<br>//总和，即为转置后B中该元素所在行前几行的元素总和，就是该元素在行优先存储的三元组表的位置  //下标<br><span class="hljs-type">int</span> <span class="hljs-keyword">index</span>=k[A.<span class="hljs-keyword">table</span>[i].col]++;<br>//常见的交换操作<br>B.<span class="hljs-keyword">table</span>[<span class="hljs-keyword">index</span>].col=A.<span class="hljs-keyword">table</span>[i].<span class="hljs-keyword">row</span>;<br>B.<span class="hljs-keyword">table</span>[<span class="hljs-keyword">index</span>].<span class="hljs-keyword">row</span>=A.<span class="hljs-keyword">table</span>[i].col;<br>B.<span class="hljs-keyword">table</span>[<span class="hljs-keyword">index</span>].<span class="hljs-keyword">value</span>=A.<span class="hljs-keyword">table</span>[i].<span class="hljs-keyword">value</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="关于新增二叉树时一定要用Binarytree结构体，而不是直接BTnode一个新的结点"><a href="#关于新增二叉树时一定要用Binarytree结构体，而不是直接BTnode一个新的结点" class="headerlink" title="关于新增二叉树时一定要用Binarytree结构体，而不是直接BTnode一个新的结点"></a>关于新增二叉树时一定要用Binarytree结构体，而不是直接BTnode一个新的结点</h3><p>因为树是递归结构，对于复杂的树来说，可能会涉及到合并，新增加结点等等操作，使用Binarytree可以更方便得管理树，因为它通过管理有指向的根结点来管理整棵树，这在树的合并时起到巨大的作用。</p><p>而BTnode只能管理单一结点，在简单的程序中区别不大，但是程序操作越复杂BTnode的局限性越大。</p><p>所以为了方便管理，外加增加代码可复用性，在简单的程序中也要使用Binarytree</p><h2 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h2><h3 id="关于哈夫曼算法为什么是最小加权树"><a href="#关于哈夫曼算法为什么是最小加权树" class="headerlink" title="关于哈夫曼算法为什么是最小加权树"></a>关于哈夫曼算法为什么是最小加权树</h3><p>哈夫曼算法的核心在于<strong>越大的权应该离根节点越近</strong>，基于此，哈夫曼算法主要分为以下几个步骤</p><ol><li>将给定权值集合中的每个数据都作为一棵树的根结点</li><li>将最小的两个结点合并，权相加的和作为新的根结点，习惯上通常将较小的结点作为左子树</li><li>知道仅有一个根结点，即权值集合都已转为一棵二叉树的叶结点，否则重复第二条</li></ol><p>而为什么这样就可以做到让加权路径长度最小呢？</p><p>我们先把全职集合转化的二叉树叫做最终二叉树，便于下面叙述</p><p>首先，该算法将最小的两个结点结合，这就保证了离最终二叉树根结点最远的叶结点的权值最小，根据加权路径长度等于权值乘路径可知，这样使路径最长的结点的权最小，故乘积最小，同理，因为选最小的结点相加，权值较大的结点的层级就越高，就越靠近根结点，使得权值越大，路径就短</p><h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><h2 id="图的邻接表"><a href="#图的邻接表" class="headerlink" title="图的邻接表"></a>图的邻接表</h2><p>边的插入运算核心思想为，想插入边&lt;u,v&gt;建立一个新结点，将其插入进u的单链表的最前面</p><p>这样较之插入单链表末尾，可以省去遍历单链表，找到末尾节点的步骤，降低时间复杂度</p><p>插入运算核心代码为</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs xl">Status Insert(LGraph* lg, int u, int v)<br>&#123;<br>    ENode* p;<br>    <span class="hljs-function"><span class="hljs-title">if</span> (u &lt; 0 || v &lt; 0 || u &gt;= lg-&gt;</span><span class="hljs-function"><span class="hljs-title">n</span> || v &gt;= lg-&gt;</span>n)<br>    &#123;<br>        return ERROR;  <span class="hljs-comment">// 输入的顶点编号无效</span><br>    &#125;<br>    p = (ENode*)malloc(sizeof(ENode));<br>    <span class="hljs-keyword">if</span> (!p)<br>    &#123;<br>        return Overflow;  <span class="hljs-comment">// 内存分配失败</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">p</span>-&gt;</span>adjVex = v;<br>    <span class="hljs-function"><span class="hljs-title">p</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">nextArc</span> = lg-&gt;</span><span class="hljs-function"><span class="hljs-title">a</span>[u];  // lg-&gt;</span><span class="hljs-function"><span class="hljs-title">a</span>[u]意为，lg-&gt;</span>a指向的数组中a[u]位置存放的地址，即为单链表<br>                               头结点的地址，<span class="hljs-function"><span class="hljs-title">p</span>-&gt;</span>nextArc经此操作，也成为存放头结点地址的指针变量<br>    <span class="hljs-function"><span class="hljs-title">lg</span>-&gt;</span>a[u] = p;  <span class="hljs-comment">// 将a[u]存放的地址更改为p的地址，是的头结点变为p</span><br>    <span class="hljs-function"><span class="hljs-title">lg</span>-&gt;</span>e++;  <span class="hljs-comment">// 增加边数</span><br>    return OK;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h2><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs xl">void DFS(LGraph *lg, int v, int *visited) <br>&#123;<br>    ENode *p;<br>    printf(<span class="hljs-string">&quot;%d &quot;</span>, v);  <span class="hljs-comment">// 访问当前顶点</span><br>    visited[v] = <span class="hljs-number">1</span>;     <span class="hljs-comment">// 标记顶点 v 已访问</span><br>    <br>    <span class="hljs-function"><span class="hljs-title">p</span> = lg-&gt;</span>a[v];  <span class="hljs-comment">// 获取顶点 v 的邻接链表</span><br>    <span class="hljs-keyword">while</span> (p) <br>    &#123;<br>        <span class="hljs-function"><span class="hljs-title">if</span> (!visited[p-&gt;</span>adjVex]) <br>        &#123;  <span class="hljs-comment">// 如果邻接点 p-&gt;adjVex 没有被访问</span><br>            DFS(<span class="hljs-function"><span class="hljs-title">lg</span>, p-&gt;</span>adjVex, visited);  <span class="hljs-comment">// 递归访问邻接点</span><br>        &#125;<br>        <span class="hljs-function"><span class="hljs-title">p</span> = p-&gt;</span>nextArc;  <span class="hljs-comment">// 移动到下一个邻接点</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 外部接口函数：遍历图的所有顶点</span><br>void DFSgraph(LGraph *lg) &#123;<br>    int visited[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">0</span>&#125;;  <span class="hljs-comment">// 访问标志数组，初始化为 0</span><br>    <br>    <span class="hljs-function"><span class="hljs-title">for</span> (int i = 0; i &lt; lg-&gt;</span>n; i++) <br>    &#123;<br>        <span class="hljs-keyword">if</span> (!visited[i])<br>        &#123;  <span class="hljs-comment">// 如果顶点 i 没有被访问</span><br>            DFS(lg, i, visited);  <span class="hljs-comment">// 从顶点 i 开始深度优先遍历</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>传递 <code>lg</code> 而不是 <code>&amp;lg</code> 的原因在于 <code>lg</code> 已经是一个指向 <code>LGraph</code> 结构体的指针（即 <code>LGraph *lg</code>）。具体来说，<code>lg</code> 是 <code>DFS</code> 函数的参数，它指向一个图的结构体，而在递归调用时，我们并不需要修改 <code>lg</code> 的指向（即不需要修改 <code>LGraph *lg</code> 变量本身的地址），所以直接传递 <code>lg</code> 就可以了。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><p><a href="https://www.cnblogs.com/jelly12345/p/15726833.html">https://www.cnblogs.com/jelly12345/p/15726833.html</a></p>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cs-学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络学习</title>
    <link href="/2024/11/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0/"/>
    <url>/2024/11/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p>做项目涉及到好多计网的知识，但是系统学习的话实在是太浪费时间了</p><p>只能边做边学，不定期更新各种计网学习知识。。。。（学习过于碎片化导致没有办法很系统的记笔记。。sorry啦~)</p><p>然后会慢慢放上自己的理解，有时间再整理笔记</p><h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><p><a href="https://zh.wikipedia.org/wiki/%E8%B7%AF%E7%94%B1#">https://zh.wikipedia.org/wiki/%E8%B7%AF%E7%94%B1#</a></p><p><strong>路由</strong>是计算机网络中决定数据包从源设备到目的设备的路径选择过程。它是网络通信的核心组成部分之一，负责在不同的网络设备之间转发数据包，以便信息能够从一个设备传输到另一个设备，直到数据包到达目标设备。</p><h3 id="1-路由的基本概念"><a href="#1-路由的基本概念" class="headerlink" title="1. 路由的基本概念"></a>1. <strong>路由的基本概念</strong></h3><p>路由（Routing）是指通过网络设备（通常是路由器）来确定并选择数据包从源主机到目标主机的传输路径。路由不仅涉及选择路径，还包括如何处理不同网络之间的数据传输。</p><h3 id="2-路由器的角色"><a href="#2-路由器的角色" class="headerlink" title="2. 路由器的角色"></a>2. <strong>路由器的角色</strong></h3><p>路由器是专门设计用来处理和转发数据包的网络设备。它连接着多个网络，并决定数据包的最佳转发路径。路由器根据<strong>路由表</strong>来决定将数据包转发到哪个方向（即下一跳）。</p><ul><li><strong>路由表</strong>：路由器内部维护的表格，包含了目的地址、下一跳（下一台路由器的地址）以及到达目标的路径等信息。</li><li><strong>跳数</strong>：数据包从源到目的地通过的路由器的数量。</li></ul><h3 id="3-路由的工作原理"><a href="#3-路由的工作原理" class="headerlink" title="3. 路由的工作原理"></a>3. <strong>路由的工作原理</strong></h3><p>在网络中，当一个设备（如计算机、手机等）需要发送数据时，它首先要确定数据包的目标地址（通常是IP地址）。数据包会通过路由器一路传递，直到到达目标设备。路由器根据数据包的目标地址和自己的路由表，决定如何将数据包转发到下一个路由器或最终的目的设备。</p><h3 id="4-路由的类型"><a href="#4-路由的类型" class="headerlink" title="4. 路由的类型"></a>4. <strong>路由的类型</strong></h3><p>根据路由的实现方式和所用的协议，路由可以分为以下几种类型：</p><h4 id="a-静态路由（Static-Routing）"><a href="#a-静态路由（Static-Routing）" class="headerlink" title="a. 静态路由（Static Routing）"></a>a. 静态路由（Static Routing）</h4><p>静态路由是由网络管理员手动配置的固定路由路径。静态路由不会自动变化，需要手动更新。这种路由适用于网络结构稳定、变化较少的环境。</p><ul><li>优点：<ul><li>配置简单</li><li>无需消耗额外的带宽</li><li>安全性高（不容易受到路由协议的攻击）</li></ul></li><li>缺点：<ul><li>配置不灵活，若网络发生变化需要手动修改路由表</li><li>不适用于规模较大的网络或变化频繁的网络</li></ul></li></ul><h4 id="b-动态路由（Dynamic-Routing）"><a href="#b-动态路由（Dynamic-Routing）" class="headerlink" title="b. 动态路由（Dynamic Routing）"></a>b. 动态路由（Dynamic Routing）</h4><p>动态路由使用协议自动学习和更新路由表。网络中的路由器通过交换信息来动态地调整路径选择，以适应网络拓扑变化。这些路由协议包括<strong>RIP</strong>、<strong>OSPF</strong>、<strong>BGP</strong>等。</p><ul><li>优点：<ul><li>路由器可以自动更新路由表，适应网络变化</li><li>不需要手动配置路径，适合大规模、复杂的网络环境</li></ul></li><li>缺点：<ul><li>增加了带宽开销和计算开销</li><li>路由协议本身可能存在安全风险</li></ul></li></ul><h4 id="c-默认路由（Default-Routing）"><a href="#c-默认路由（Default-Routing）" class="headerlink" title="c. 默认路由（Default Routing）"></a>c. 默认路由（Default Routing）</h4><p>默认路由是一种特殊的路由，它为所有没有明确匹配路径的数据包提供“默认”转发路径。当路由表中没有找到特定的路由时，数据包会通过默认路由转发。</p><p>例如，一个路由器的默认路由可能指向出口路由器，它处理所有外部流量。</p><h4 id="d-路由策略（Policy-Based-Routing）"><a href="#d-路由策略（Policy-Based-Routing）" class="headerlink" title="d. 路由策略（Policy-Based Routing）"></a>d. 路由策略（Policy-Based Routing）</h4><p>在某些情况下，管理员希望基于某些条件（如源IP地址、目的IP地址、协议类型等）来指定数据包的路由。路由策略允许根据这些条件定义路由规则。</p><h3 id="5-路由选择算法"><a href="#5-路由选择算法" class="headerlink" title="5. 路由选择算法"></a>5. <strong>路由选择算法</strong></h3><p>路由选择算法用于帮助路由器选择最佳路径。常见的路由选择算法包括：</p><h4 id="a-距离向量协议（Distance-Vector-Protocol）"><a href="#a-距离向量协议（Distance-Vector-Protocol）" class="headerlink" title="a. 距离向量协议（Distance Vector Protocol）"></a>a. 距离向量协议（Distance Vector Protocol）</h4><p>距离向量路由协议的每个路由器与其邻居交换路由信息，维护到目的地的距离（即跳数）。路由器根据最小跳数选择路径。<strong>RIP</strong>（Routing Information Protocol）就是一种常见的距离向量协议。</p><ul><li><strong>优点：</strong> 配置简单，适合小型网络。</li><li><strong>缺点：</strong> 路由更新较慢，存在环路风险（跳数无限递增），不适合大型或复杂网络。</li></ul><h4 id="b-链路状态协议（Link-State-Protocol）"><a href="#b-链路状态协议（Link-State-Protocol）" class="headerlink" title="b. 链路状态协议（Link-State Protocol）"></a>b. 链路状态协议（Link-State Protocol）</h4><p>链路状态协议要求路由器收集关于网络中每个节点和链路的完整信息，并通过广播将其发送到其他路由器。每个路由器根据收到的信息构建网络的拓扑图，然后使用最短路径算法（如Dijkstra算法）来计算最优路径。<strong>OSPF</strong>（Open Shortest Path First）是最著名的链路状态协议。</p><ul><li><strong>优点：</strong> 可以快速适应网络变化，适用于大型网络。</li><li><strong>缺点：</strong> 配置复杂，消耗更多的带宽和计算资源。</li></ul><h4 id="c-路由信息协议（RIP）"><a href="#c-路由信息协议（RIP）" class="headerlink" title="c. 路由信息协议（RIP）"></a>c. 路由信息协议（RIP）</h4><p>RIP（Routing Information Protocol）是一种经典的距离向量协议，用于选择最佳路径。它基于跳数（跳数&lt;&#x3D;15）来决定路径长度。RIP协议的局限性在于它的跳数上限为15，这使得它不适用于大型网络。</p><h4 id="d-边界网关协议（BGP）"><a href="#d-边界网关协议（BGP）" class="headerlink" title="d. 边界网关协议（BGP）"></a>d. 边界网关协议（BGP）</h4><p>BGP（Border Gateway Protocol）是一种外部网关协议，主要用于不同自治系统（AS）之间的路由选择。BGP使用路径向量协议，通过交换路径信息来决定路由。它是互联网路由的基础协议。</p><ul><li><strong>优点：</strong> 支持非常大的网络，可以处理互联网级别的路由。</li><li><strong>缺点：</strong> 配置复杂，延迟较高。</li></ul><h3 id="6-路由表"><a href="#6-路由表" class="headerlink" title="6. 路由表"></a>6. <strong>路由表</strong></h3><p>路由器根据路由表来选择最优路径。路由表包含了到达不同目的地的路径信息，每个路由条目通常包含以下信息：</p><ul><li><strong>目标地址：</strong> 目标网络或主机的IP地址。</li><li><strong>子网掩码：</strong> 用来匹配目标地址的网络部分。</li><li><strong>下一跳（Next Hop）：</strong> 到达目标地址的下一跳路由器的IP地址。</li><li><strong>接口：</strong> 数据包通过哪个物理接口转发。</li><li><strong>路由协议：</strong> 路由条目的来源（如静态路由、RIP、OSPF等）。</li><li><strong>度量值（Metric）：</strong> 路由的成本，通常用于选择最优路径，较低的度量值表示更优的路径。</li></ul><h3 id="7-路由的过程"><a href="#7-路由的过程" class="headerlink" title="7. 路由的过程"></a>7. <strong>路由的过程</strong></h3><ol><li><strong>源设备发起请求：</strong> 当源设备需要与目标设备通信时，它会先确定目标的IP地址。</li><li><strong>路由选择：</strong> 源设备会查询路由表，确定将数据包发送到哪个路由器，或直接发送到目标设备。如果目标不在本地网络，数据包会被发送到路由器。</li><li><strong>数据包传递：</strong> 数据包通过路由器逐级转发，直到到达目标路由器或目标设备。</li><li><strong>到达目的地：</strong> 当数据包到达目标设备时，目标设备会根据数据包中的目标IP地址进行处理。</li></ol><h3 id="8-路由的挑战"><a href="#8-路由的挑战" class="headerlink" title="8. 路由的挑战"></a>8. <strong>路由的挑战</strong></h3><ul><li><strong>路由环路：</strong> 由于网络拓扑变化，可能会导致数据包在多个路由器之间循环，造成网络拥堵和资源浪费。为避免此问题，动态路由协议通常会使用“跳数”限制或环路检测机制（如TTL、路径向量等）。</li><li><strong>路由收敛：</strong> 当网络发生变化（如路由器故障），路由器需要重新计算最佳路径，这个过程叫做路由收敛。路由收敛速度越快，网络恢复的速度越快。</li><li><strong>带宽和延迟：</strong> 路由选择不仅考虑路径的可达性，还会考虑带宽、延迟等网络质量因素，以选择最优路径。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>路由是网络通信中至关重要的一环，通过确定数据包的传输路径，确保信息能够准确无误地从源设备传送到目标设备。静态和动态路由各有优缺点，动态路由可以自动适应网络拓扑变化，而静态路由则适用于相对简单和固定的网络环境。不同的路由协议（如RIP、OSPF、BGP等）根据网络的规模和复杂性选择合适的路由策略。</p><h2 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h2><p><a href="https://blog.csdn.net/weixin_73466540/article/details/131934302">https://blog.csdn.net/weixin_73466540/article/details/131934302</a></p><p>IP地址就相当于现实中的节点，可以用来标注一个主机在网络中的位置</p><p>IP地址实际上时使用二进制表达的，但是人类读写二进制不方便，所以需要转化成十进制</p><h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><p>IPv4格式：点分十进制， 如 192.168.1.1 这个格式一共有32bit等于4个字节</p><p>bit:占据一个位置，单位。<br>字节Byte，1Byte&#x3D;8bit<br>二进制：0或者1<br>IP地址最小是全0：0.0.0.0<br>IP地址最大是全1：11111111.11111111. 11111111.1111111 化成十进制255.255.255.255<br>IPv4地址范围：0.0.0.0~255.255.255.255。</p><h3 id="IP地址构成"><a href="#IP地址构成" class="headerlink" title="IP地址构成"></a>IP地址构成</h3><p><strong>网络部分</strong>：标识网络</p><p><strong>主机部分</strong>：标识主机</p><p>IP地址分为几类，不同的掩码意味着不同的网络号位和主机号位，例如10.1.12.1，根据掩码来判断第几位是网络号，第几位是主机号</p><p><strong>&#x2F;8  A类地址 255.0.0.0</strong>（IP地址实际上由4个8位二进制数存储，&#x2F;8意为前8位是网络号，&#x2F;16，&#x2F;24同理）</p><p><strong>&#x2F;16  B类地址 255.255.0.0</strong></p><p><strong>&#x2F;24  C类地址 255.255.255.0</strong></p><p>我们通常把一个网络号所定义的网络范围称为一个网段。</p><p>网络号：范围，不能直接配置在某个接口；<strong>主机位全为0</strong>，得出网络地址</p><p>广播地址：用于向该网络中的所有主机发送数据的特殊地址。<strong>主机位全为1</strong>，得出广播地址</p><h3 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h3><p><a href="https://www.cnblogs.com/weq0805/p/14775138.html">https://www.cnblogs.com/weq0805/p/14775138.html</a></p><p>用来标注在子网中，主机所获得的IP地址的哪几位是网络号，哪几位是主机号</p><p><strong>网络号都是1，主机号都是0，如255.0.0.0（11111111.00000000.00000000.00000000）</strong></p><p>原文链接：<a href="https://blog.csdn.net/weixin_73466540/article/details/131934302">https://blog.csdn.net/weixin_73466540/article/details/131934302</a></p><p>因为过于菜，所以每次更新都是上网上看大佬的链接然后把他们搬过来学习。。。</p><h2 id="关于代理的一些事"><a href="#关于代理的一些事" class="headerlink" title="关于代理的一些事"></a>关于代理的一些事</h2><h3 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h3><p>中转服务器，介于用户端与数据服务器之间，提高用户查找数据的效率。。。</p><p>网络上有很多平台，比如知乎，b站，当你在这些平台上访问数据时，实际在互联网中会经过如下操作</p><ul><li>用户端向平台存储服务器发送获取请求</li><li>请求通过网络中的路由器，一步一步到达目标服务器</li><li>服务器接受请求之后同样得路发送你想获取数据</li></ul><p>这就存在一个问题，如果你距离服务器得距离过于远，请求需要经过得路由器就会越多，换句话说，他在网络中走过的距离就会越长，延迟就会越高</p><p>所以，cdn起到了驿站的作用，请求时，会先向cdn发送请求，如果有需要的数据就会直接发回，如果没有就会向上一级服务器请求，由此大大减小了所需时间</p><p><img src="/.io//blog/blog/picture/148231357a1c098c61ae3cadd43c96e3.jpeg" alt="img"></p><h3 id="代理服务器"><a href="#代理服务器" class="headerlink" title="代理服务器"></a>代理服务器</h3><p>将连接到代理服务器的用户端打包，与公网隔绝，用户端任何与公网的交互都有代理服务器进行，不需要用户端自身连入公网。</p><p>由于其不需要用户端连入公网，所以经常用来翻墙(小朋友不要学习)，其原理与上述内容一致。</p><ul><li>用户端向距离较远的服务器**(防止被谈话得说法，大家懂得都懂。。。。)**发送请求时，请求会被墙拦截，墙本质上也是一个大型服务器，你向境外服务器请求时，会先经过墙</li><li>当你连入代理服务器时，你的请求不会经过墙，而是你自己配置的代理服务器，所以可以访问</li></ul><p><img src="/.io//blog/blog/picture/e5ff2d88cfc341e0693d2294b6532c81.jpeg" alt="在这里插入图片描述"></p><h3 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h3><p>与代理服务器不只是名字相似，其原理同样相似。如果说代理服务器是用户端的代理，那反向代理就是服务器的代理，因原理与上述一直，就不过多叙述了</p><p><img src="/.io//blog/blog/picture/b94b6cda68742af5a087e7ea5d83ba49.jpeg" alt="在这里插入图片描述"></p><h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><p>大型电话本，用于根据域名查询ip地址</p><h2 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h2><p><strong>数据划分：</strong></p><ul><li>在发送端，待传输的数据（如一个文件、一个消息等）会被切割成多个固定大小的“数据包”。</li><li>每个数据包包含数据的一部分，并且每个数据包都会有一些<strong>控制信息</strong>，比如标识符、顺序号、来源地址、目标地址等。这些控制信息帮助网络设备正确地路由数据包，并确保目的地能够重新组装所有数据包。</li></ul><p><strong>控制信息：</strong> 每个数据包除了包含数据部分外，还包含以下几类控制信息：</p><ul><li><strong>源地址和目的地址：</strong> 确定数据包的发送方和接收方。</li><li><strong>序列号：</strong> 用来标识数据包的顺序。接收端根据序列号来重新组装数据包。</li><li><strong>校验和：</strong> 用于检测数据包在传输过程中是否发生了损坏。</li><li><strong>协议标识：</strong> 指定该数据包属于哪个协议（如TCP、UDP、ICMP等）。</li></ul><p><strong>发送数据包：</strong></p><ul><li>切割后的数据包会通过网络逐个发送。每个数据包可能会通过不同的路径到达目的地，依赖于网络的路由机制。它们在经过路由器、交换机等网络设备时可能会被缓冲、转发或者路由。</li></ul><p><strong>网络拥塞和丢包处理：</strong></p><ul><li>网络中的每个数据包是独立传输的，因此在传输过程中如果发生丢包或延迟，只有某个特定数据包受到影响，其他数据包仍然可以继续传输。这种机制避免了整个数据传输过程中断。</li><li>如果某个数据包丢失或出现错误，接收端会请求重新发送那个丢失的数据包（这通常由<strong>TCP协议</strong>来保证）。</li></ul><p><strong>接收和重组：</strong></p><ul><li>在接收端，所有数据包会被按照序列号进行排序，并且如果存在丢失的包，接收端会请求重发，直到所有数据包都正确到达。</li><li>接收端根据数据包中的控制信息，使用<strong>序列号</strong>将数据包按照正确顺序重新组装成完整的数据。</li></ul><h3 id="数据分组的优势"><a href="#数据分组的优势" class="headerlink" title="数据分组的优势"></a>数据分组的优势</h3><ol><li><strong>效率：</strong><ul><li>数据分组使得网络能够更高效地利用带宽。通过将数据拆分成较小的包，可以避免因某个大数据包丢失而影响整个数据传输。</li><li>各个数据包的大小可以根据网络的带宽和延迟动态调整，以优化传输效率。</li></ul></li><li><strong>错误恢复：</strong><ul><li>如果某个数据包在传输中丢失或者损坏，只有该数据包需要重新传输，而不需要重新发送整个数据。这提高了传输的可靠性和效率。</li></ul></li><li><strong>并行处理：</strong><ul><li><strong>数据包可以通过不同的路由同时传输（多路径路由），从而提高数据传输速度。</strong></li><li>数据包也可以利用网络中空闲的带宽，减少传输时间。</li></ul></li></ol><h1 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h1><h2 id="什么是Internet"><a href="#什么是Internet" class="headerlink" title="什么是Internet"></a>什么是Internet</h2><h3 id="什么是网络"><a href="#什么是网络" class="headerlink" title="什么是网络"></a>什么是网络</h3><p><strong>网络</strong>：节点与边的关系，与形状大小无关。</p><p><strong>计算机网络</strong>：</p><ul><li>节点：主机节点（个人pc，服务器，家用智能电器）&#x3D;&#x3D;方形代替&#x3D;&#x3D;，数据交换结点（路由器，交换机）&#x3D;&#x3D;圆形代替&#x3D;&#x3D;。</li><li>边：节点之间的通信链路构成边。<ul><li>接入网链路：主机连接到互联网的链路。</li><li>主干链路：路由器间的链路。</li></ul></li><li>协议：&#x3D;&#x3D;<strong>对等层</strong>&#x3D;&#x3D;（网络层，应用层等）的实体在通信过程中应该遵守的规则集合。只要 遵守同一协议，不同厂商生产的设备就可以实现通信。</li></ul><p><strong>互联网</strong>：按照TCP&#x2F;IP协议为主的协议工作的网络</p><ul><li>数以亿计的计算设备<ul><li>主机&#x3D;端系统：pc，server</li><li>端系统上运行的软件：操作系统，应用程序</li></ul></li><li>通信链路：<ul><li>协议：&#x3D;&#x3D;<strong>对等层</strong>&#x3D;&#x3D;（网络层，应用层等）的实体在通信过程中应该遵守的规则集合。规定了通信报文的<strong>格式</strong>，<strong>次序</strong>以及其他事件方面所采取的动作</li></ul></li></ul><h3 id="从服务角度看互联网"><a href="#从服务角度看互联网" class="headerlink" title="从服务角度看互联网"></a>从服务角度看互联网</h3><p><strong>分布式应用进程</strong>加上应用层以下的，为进程提供通信服务的<strong>基础设施</strong></p><h2 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h2><p>网络也可以看作由三部分组成</p><ul><li>网络边缘</li><li>网络核心</li><li>接入式网络</li></ul><h3 id="网络边缘"><a href="#网络边缘" class="headerlink" title="网络边缘"></a>网络边缘</h3><p> <strong>端系统</strong>：运行应用程序，如web，email位于网络边缘</p>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cs-学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>moectf-wp</title>
    <link href="/2024/11/06/moectf-wp/"/>
    <url>/2024/11/06/moectf-wp/</url>
    
    <content type="html"><![CDATA[<h1 id="moectf"><a href="#moectf" class="headerlink" title="moectf"></a>moectf</h1><h2 id="web"><a href="#web" class="headerlink" title="web"></a>web</h2><h3 id="垫刀之路03"><a href="#垫刀之路03" class="headerlink" title="垫刀之路03"></a>垫刀之路03</h3><p>其实相当简单，只需要本地写一个php一句话木马之后，修改文件名为.jpg。上传后用burpsuit拦截即可。</p><p>但是由于不可抗力，我的bp一直没办法抓到post的包，所以暂时没有做出来</p><h3 id="垫刀之路04"><a href="#垫刀之路04" class="headerlink" title="垫刀之路04"></a>垫刀之路04</h3><p>说实话这题蛮莫名其妙的，直接就是一个目录穿越，访问..&#x2F;..&#x2F;..&#x2F;..&#x2F;就行了。以下是原出题人的意思</p><p>打开网页之后发现url里有 <code>?urc=</code> 再加上readme里写了本文档没有作用，所以猜测是目录穿越。。。emmm就。。。蛮莫名其妙的</p><h3 id="垫刀之路05"><a href="#垫刀之路05" class="headerlink" title="垫刀之路05"></a>垫刀之路05</h3><p>这题更是重量级，随便一个万能密码绕过就ok了</p><p><code>111 or 1=1 #</code></p>]]></content>
    
    
    <categories>
      
      <category>ctf</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ctf-web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>web-wp</title>
    <link href="/2024/11/04/wp/"/>
    <url>/2024/11/04/wp/</url>
    
    <content type="html"><![CDATA[<h2 id="做题狗"><a href="#做题狗" class="headerlink" title="做题狗"></a>做题狗</h2><p>正在学习web漏洞，感觉以后还是web层面的漏洞更多一些</p><p>学习链接：<a href="https://github.com/hongriSec/Web-Security-Attack.git">https://github.com/hongriSec/Web-Security-Attack.git</a></p><p>以后不定期更新各种web题的wp(希望日更一道web,一道re)。。。</p>]]></content>
    
    
    <categories>
      
      <category>ctf</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ctf-web</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
